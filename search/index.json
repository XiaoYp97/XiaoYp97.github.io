[{"content":"什么是第一性原理？ 第一性原理（First Principles） 是一种从最基本、最本质的层面思考问题的方法，要求我们抛开所有假设和成见，从最基础的真理出发重新构建认知。这种思维方式强调从根本问题出发，剖析和理解事物本质，而不是依赖传统认知或经验。\n起源 第一性原理的概念最早可以追溯到亚里士多德的哲学思想。 他认为，在任何系统中，都存在一些最基本的命题或假设，这些命题不能进一步简化或从其他命题推导出来。 这些基本命题构成了所有知识的基础，是我们认知的出发点。 与传统思维的区别 类比思维：\n基于已知经验，寻找相似性，容易受限于现有认知，创新性有限。 第一性原理思维：\n回归本质，剖析问题的基本组成要素，突破认知局限，有可能产生突破性的创新。 实际应用案例 特斯拉的电池革新 马斯克运用第一性原理思维降低电池成本：\n不是直接压缩现有电池的利润空间。 而是从最基本的组成材料（如锂、钴、镍等）入手。 通过分析原材料的成本，重新设计生产流程。 最终成功将电池成本降低约50%。 SpaceX 的火箭研发 传统思维：火箭很贵，因为\u0026quot;火箭一直都很贵\u0026quot;\n运用第一性原理：\n分析火箭的基本组成材料，计算原材料成本。 重新设计火箭制造流程。 通过实现可重复使用的火箭，大幅降低了发射成本。 如何运用第一性原理 基本步骤 识别问题：\n明确要解决的核心问题，避免被表象迷惑。 拆解组成：\n将问题拆解为最基本的要素，识别关键变量和约束条件。 重新构建：\n从基本要素出发，构建新的解决方案，探索创新的方法。 验证方案：\n测试新方案的可行性，并持续优化改进。 注意事项 避免过度简化：\n确保不遗漏重要因素，避免忽视系统复杂性。 平衡效率：\n不是所有问题都需要追溯到最基础层面，视情况决定是否采用第一性原理思维。 保持开放性：\n不断质疑现有认知，愿意接受新的可能性和解决方案。 应用领域 技术创新：\n通过第一性原理突破技术瓶颈，开发新产品或技术。 商业模式：\n重新定义市场、颠覆传统商业模式，创造新的商业机会。 问题解决：\n解决复杂技术问题，优化现有流程。 个人成长：\n在个人学习和职业发展中，突破思维局限，找到更高效的成长路径。 在软件开发中的应用 1. 编程语言设计 传统思维：\n借鉴已有语言的特性，模仿流行语言的语法结构。 第一性原理思维：\n深入思考编程语言的本质：人与机器的沟通桥梁。\n分析目标用户的实际需求，设计符合需求的语言特性。\n例如Rust语言，从系统编程的基本需求出发，设计了所有权、借用和生命周期等独特特性，以确保内存安全和高效并发。\nRust的所有权模型：\n所有权确保每个值只能有一个所有者，这使得内存管理变得更可控，避免了内存泄漏和悬挂指针的问题。 借用和生命周期的概念，使得Rust能够通过编译时检查，确保数据不会在不合法的情况下被访问。 这些设计原则并不是简单模仿其他语言，而是从解决内存安全和并发编程的基本问题出发，重新构建了语言的核心特性。 2. 系统架构设计 传统思维：\n采用流行架构模式，照搬热门技术栈或成功案例。 第一性原理思维：\n分析业务的本质需求，考虑系统的基本约束（性能、可用性、扩展性、维护成本等）。 从零开始设计最适合的架构，确保架构的灵活性和可维护性。 例如，微服务架构的选择不是因为它流行，而是基于以下分析：业务模块的独立性、团队协作效率、系统扩展需求、维护成本等。 3. 代码重构 传统思维：\n简单修补问题代码，堆积临时解决方案。 第一性原理思维：\n理解代码的核心功能，识别根本的设计问题。 从根本上重新设计代码，遵循设计原则（如单一职责、开闭原则、依赖倒置等）。 4. 问题调试 传统思维：\n基于经验猜测问题，尝试常见解决方案，修复表面症状。 第一性原理思维：\n理解系统的工作原理，收集诊断数据，分析问题根本原因。 设计全面的解决方案，如在 性能优化 中，通过分析性能瓶颈的本质，优化算法和数据结构，而非简单依赖缓存或硬件升级。 5. 技术选型 传统思维：\n选择流行技术，跟随大公司的技术栈或盲目采用新技术。 第一性原理思维：\n基于项目的实际需求、团队能力、维护成本等因素评估技术选型。 评估技术的本质特性，选择最适合的技术，而非仅仅追求“潮流”。 实践建议 培养基础思维：\n深入学习计算机基础理论，掌握核心算法和数据结构。 问题分析：\n在解决问题时，不急于采用现成方案，先深刻理解问题本质，分析基本约束和需求。 方案设计：\n从基本原则出发，设计简洁且可维护的解决方案，注重系统的扩展性。 持续优化：\n定期回顾和重构代码，关注系统的健康度，避免技术债务积累。 总结 运用第一性原理思维，在软件开发中能够帮助我们：\n设计出更加优雅和高效的解决方案。 构建更加可靠、可扩展的系统架构。 编写更易维护的代码，解决更复杂的技术问题。 这种思维方式要求我们投入更多的时间和精力，但它所带来的长期收益是无可比拟的。因此，掌握并运用第一性原理，将是每个优秀开发者必须具备的能力。\n","date":"2025-04-21T17:56:08+08:00","image":"https://blog.yellster.top/p/first-principle/%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86_hu_f3fa35aa3b56663e.webp","permalink":"https://blog.yellster.top/p/first-principle/","title":"第一性原理"},{"content":"在现代操作系统中，进程、线程和虚拟地址是支撑高效执行、内存管理与资源隔离的三大核心概念。它们相互配合，共同保证系统的稳定性、安全性与并发性能。\n进程：资源隔离与调度的基本单位 概念 进程：正在运行的程序实例，拥有独立的地址空间、数据段、堆与栈，以及各类系统资源（文件描述符、信号、IPC 对象等）。 创建与执行 创建：Linux 中通过 fork() 复制父进程，再用 exec() 系列函数加载新程序。\nfork()——复制当前进程\n父进程调用 fork()，内核在后台复制出一个“子进程”，这个子进程和父进程几乎一模一样（地址空间、打开的文件描述符等都拷贝或共享）。\nexecve()（或其它 exec* 系列函数）——在子进程里加载新程序\n子进程中立即调用 execve(\u0026quot;/path/to/newprog\u0026quot;, argv, envp)，内核就会丢弃掉原来的地址空间，把可执行文件 /path/to/newprog 映射进来，初始化全新的代码段、数据段、堆栈，真正运行“一个全新的进程镜像”。\n调度：内核调度器（scheduler）负责分配 CPU 时间片，维护多任务并发运行。\n进程间通信（IPC） 由于进程地址空间独立，IPC 机制尤为重要：\n方式 场景 优势 注意点 管道（Pipe） 父子进程 简单、快速 仅限亲缘进程，单向 命名管道 任意本地进程 双向、可见文件系统 性能略低 消息队列 异步通信 支持优先级、可靠传输 大量小消息时开销增大 共享内存 大块数据交换 零拷贝、高吞吐 需同步机制（锁、信号量） 套接字（Socket） 本地／跨网络进程 灵活、多协议 网络开销相对较大 信号（Signal） 异步通知 轻量级、实时性好 数据传输能力有限 IPC（进程间通信，Inter-Process Communication） 是指在操作系统中，不同进程之间为交换数据或进行同步而提供的一系列机制。\n由于操作系统给每个进程分配了独立的地址空间，直接读写对方内存是不被允许的，IPC 就是为了解决“进程如何安全、高效地互相协作”而产生的。\n线程：轻量级执行流与并行处理 概念 线程：依附于进程的执行单元，共享进程的地址空间和大部分资源，但拥有各自的寄存器上下文和栈。 创建与管理 Linux 实现：基于 clone() 系统调用；POSIX 线程库（pthread）提供了更友好的 API。 切换开销：比进程轻量，适用于高并发场景。 并发挑战 竞态条件：无同步的并发访问可能导致数据不一致。 死锁：多线程间相互等待锁时出现永久阻塞。 活锁与饥饿：线程过度谦让或被长期剥夺执行机会。 示例（Rust 风格伪代码）：\n1 2 3 4 5 6 7 8 9 10 let counter = Arc::new(Mutex::new(0)); let handles: Vec\u0026lt;_\u0026gt; = (0..10).map(|_| { let c = Arc::clone(\u0026amp;counter); thread::spawn(move || { let mut num = c.lock().unwrap(); *num += 1; }) }).collect(); for h in handles { h.join().unwrap(); } println!(\u0026#34;Result: {}\u0026#34;, *counter.lock().unwrap()); 虚拟地址：抽象内存与安全保护 概念 虚拟地址：操作系统为每个进程提供的连续逻辑地址空间，与物理内存无直接一一映射。 管理机制 分页（Paging）\n页大小：通常 4 KB，也有大页（2 MB/1 GB）。 多级页表：如 x86_64 的 4 级页表，减少内存占用。 地址转换\n1 2 虚拟地址 = [页目录索引][页表索引][页内偏移] 物理地址 = 页框号 + 偏移 通过 MMU 与 TLB 快速完成转换。 保护与优化\n访问权限：读/写/执行标志。 用户/内核隔离：防止越权访问。 写时复制（COW）：延迟复制，降低 fork 开销。 能当做 IPC 吗？ 虚拟地址本身不共享，不能直接跨进程使用。 共享内存 或 mmap(MAP_SHARED) 是利用虚拟地址“映射”同一段物理页到不同进程，从而实现高效的 IPC。 你只需要在各自进程里拿到映射后自己的虚拟指针，就能像访问本地内存一样进行读写。 协程：更轻量的用户态并发 概念 协程（Coroutine）：用户态的轻量级执行单元，又称“微线程”或“纤程”。它在单线程内通过显式的调度点（yield）实现多任务切换，无需内核参与。 特点 特性 线程 协程 调度 内核调度（抢占式） 用户态调度（协作式） 上下文切换开销 高（进入内核，保存/恢复寄存器、内核栈） 低（仅保存/恢复少量寄存器和用户栈指针） 通信 共享内存需锁、IPC 函数调用/Channel/队列 等 并发规模 受限于内核线程数 数万乃至数十万轻松支持 调度模型 协作式：运行到显式 yield 或 await 才切换，开发者可精确控制切换点。 预emptive（部分语言支持）：语言运行时定期打断协程，但大多数主流实现（如 Python、Go）采用协作式。 常见实现 Go：goroutine + M:N 调度，M 代表系统线程，N 代表用户协程，由 runtime 自动分配。 Python：async def + await，基于事件循环（asyncio）或第三方库（如 Trio、Curio）。 Rust：async/await + Futures + executor（如 Tokio、async-std），通过状态机驱动。 JavaScript：基于事件循环的 Promise + async/await，单线程协程模型。 应用场景 高并发 I/O：Web 服务器、爬虫、网络代理等，常用事件驱动 + 协程模型实现百万级并发。 异步任务流：管道化处理、大量小任务的并行调度。 可控并发：无需锁或细粒度锁，简化并发控制。 四者对比与协同 模型 调度方式 切换开销 共享资源 适用场景 进程 内核（抢占） 最大 无（需 IPC） 资源隔离、强隔离需求 线程 内核（抢占） 较大 共享进程资源 CPU 并行、I/O 并发 协程 用户（协作） 最小 共享线程资源 海量并发 I/O、异步流程 虚拟地址 —— —— —— 为进程/线程/协程提供统一内存抽象 进程： 是资源分配的基本单位，每个进程都有独立的内存空间（代码段、数据段、堆栈等），提供最强隔离。 线程： 是 CPU 调度的基本单位，属于进程，一个进程可以包含多个线程。共享进程的内存空间和资源（文件句柄、数据段等）在同一地址空间内并行。 协程： 在单线程内更高效地调度。 虚拟地址： 是上述模型的基础，屏蔽物理内存复杂性并提供保护。 应用场景选型 场景 建议方案 资源隔离优先 对安全或稳定性要求极高的组件，首选进程 并行计算 CPU 密集任务可用多进程或多线程 高并发 I/O 首选协程框架，结合事件驱动（如 epoll、kqueue） 混合模式 Web 服务常用 “多进程 + 协程” 的组合：进程隔离，协程高并发 总结 进程、线程 和 协程 是三种层次不同的并发单元，各自有取舍。 虚拟地址 为它们提供了统一、隔离且安全的内存视图。 在实际系统设计中，合理组合使用，才能兼顾隔离性、并发性与性能，打造高性能、高可靠的应用架构。 进程调度算法 非抢占式调度 先来先服务（FCFS）\n原理：按进程到达就绪队列的先后顺序依次调度，类似队列排队。 优点：简单易实现；无饥饿。 缺点：平均等待时间不一定最短，易出现“短作业后面跟长作业”拖慢整体效率。 短作业优先（SJF）／最短剩余时间优先（SRTF）\nSJF（非抢占）：每次选择执行时间最短的作业； SRTF（抢占）：新作业到达时，如果其所需时间比当前剩余时间短，则抢占。 优点：能最小化平均等待时间； 缺点：需要准确估计执行时间；可能导致长作业“饥饿”。 优先级调度（Priority）\n原理：为每个进程分配优先级，优先级高的先执行；可抢占或非抢占。 优点：满足关键任务优先执行； 缺点：低优先级可能长时间得不到调度（饥饿），需用“优先级老化”机制解决。 抢占式调度 时间片轮转（Round Robin，RR）\n原理：给每个进程分配固定长度的时间片，时间片用完即切换到下一个进程，循环往复。 优点：响应时间可控，适合交互式系统；无进程饥饿。 缺点：时间片大小需平衡，过大接近 FCFS，过小切换开销大。 多级队列调度（Multilevel Queue）\n原理：将进程按类型（交互式、批处理、系统进程等）分到多个队列，不同队列使用不同算法和优先级。 优点：可针对性地优化不同类型作业； 缺点：队列间切换策略固定，灵活性较差。 多级反馈队列（Multilevel Feedback Queue）\n原理：允许进程在不同优先级队列间动态升降，根据其执行特性（CPU 密集或 I/O 密集）调整优先级。 优点：兼顾短作业和长作业，能自动提升响应性； 缺点：参数（队列数、时间片长度、反馈规则）较多，需要调优。 现代与实时调度 最早截止时间优先（EDF, Earliest Deadline First）\n应用：实时系统 原理：总是选择截止时间最早的任务执行，可抢占。 优点：理论上能在系统总利用率 ≤100% 时保证所有任务准时完成； 缺点：需要精确的任务截止时间。 率先最小周期优先（RMS, Rate Monotonic Scheduling）\n应用：实时系统，周期性任务 原理：周期短（率高）的任务优先级高； 优点：简单固定优先级； 缺点：在高利用率下不能保证可调度（理论上利用率上限 ≈69%）。 Linux 完全公平调度器（CFS, Completely Fair Scheduler）\n应用：通用 Linux 桌面/服务器 原理：用虚拟运行时间（vruntime）衡量每个任务已经“拿过”的 CPU 时间，优先选择 vruntime 最小者执行。 优点：可以在多任务间实现近似理想的公平； 缺点：算法复杂度高于传统调度，切换开销略大。 选择与权衡 交互式系统（桌面应用、Web 服务器）：优先 RR、Multilevel Feedback Queue、CFS 批处理系统（后台任务、科学计算）：可选 SJF/SRTF、Multilevel Queue 实时系统（控制、嵌入式）：EDF、RMS 混合场景：多级反馈队列 + 结合优先级老化保证低优先级可执行 算法 抢占 优点 缺点 FCFS 否 简单易实现，无饥饿 平均等待时间高 SJF / SRTF 可选 最小化平均等待时间 需估计运行时长；长期作业易饥饿 Priority 可选 可满足关键任务优先 需防止低优先级饥饿 Round Robin 是 响应时间可控，无饥饿 时间片选取需平衡；频繁切换开销大 Multilevel Queue 可选 针对不同类型作业优化 队列间固化策略；灵活性差 Multilevel Feedback 是 自适应调度，兼顾短/长作业 参数调优复杂 EDF / RMS（实时） 是 实时可调度保证 需准确的任务参数 CFS 是 理想公平，适合通用场景 实现复杂，切换开销略大 ","date":"2025-04-11T13:38:57+08:00","image":"https://blog.yellster.top/p/process-thread/process-thread_hu_2f59af0e352540b1.webp","permalink":"https://blog.yellster.top/p/process-thread/","title":"进程与线程"},{"content":"模型名称及其中英文对应 英文名称 中文对应 全称 中文全称翻译 GPT-3/GPT-4 GPT-3/GPT-4 Generative Pre-trained Transformer 3/4 生成式预训练变换器 3/4 BERT BERT Bidirectional Encoder Representations from Transformers 双向编码器表示来自变换器 RoBERTa RoBERTa Robustly Optimized BERT Pre-Training Approach 稳健优化 BERT 预训练方法 XLNet XLNet XLNet XLNet T5 T5 Text-to-Text Transfer Transformer 文本到文本转移变换器 BART BART Bidirectional and Auto-Regressive Transformers 双向和自回归变换器 ELECTRA ELECTRA Efficiently Learning an Encoder that Classifies Token Replacements Accurately 高效学习编码器分类令牌替换准确 DeBERTa DeBERTa Decoding-enhanced BERT with Disentangled Attention 解码增强 BERT 具有解耦注意力 PaLM PaLM Pathways Language Model 路径语言模型 LLaMA LLaMA Large Language Model Meta AI 大型语言模型 Meta AI BLOOM BLOOM BigScience Large Open-science Open-access Multilangual language model BigScience 大型开源多语言语言模型 Chinchilla Chinchilla Chinchilla Chinchilla OPT OPT Open Pre-trained Transformer 开放预训练变换器 ERNIE ERNIE（文心一言） Enhanced Representation through Knowledge Integration 通过知识集成增强表示 CPM CPM Chinese Pre-trained Model 中文预训练模型 GLM GLM General Language Model 通用语言模型 MacBert MacBert MacBert MacBert Chinese BERT Chinese BERT Chinese BERT 中文 BERT 术语及其中英文对应 英文术语 中文翻译 说明 AIGC 人工智能生成内容 通过AI技术自动生成的各类媒体内容（文本、图像、音频等） Large Language Model 大型语言模型 LLM 的核心概念 Pre training 预训练 模型在大量数据上的初始训练 Fine-tuning 微调 在特定任务上调整模型 Transformer 变换器 LLM 常用的架构 Attention mechanism 注意力机制 变换器中的关键技术 Word embedding 词嵌入 单词到向量表示 Contextualized embedding 上下文嵌入 考虑上下文的嵌入 Masked language modeling 掩码语言建模 BERT 使用的预训练任务 Next sentence prediction 下一句预测 BERT 早期使用的任务 Transfer learning 迁移学习 模型在不同任务间的应用 Natural language processing 自然语言处理 LLM 的应用领域 Deep learning 深度学习 LLM 的基础技术 Neural network 神经网络 深度学习的构建块 Gradient descent 梯度下降 优化算法 Backpropagation 反向传播 训练神经网络的核心方法 Prompt 提示 输入给模型的指令 Prompt engineering 提示工程 优化提示以改善输出 Few-shot learning 少样本学习 少量示例下学习 Zero-shot learning 零样本学习 无示例直接推理 In-context learning 上下文学习 基于上下文的推理 Parameter-efficient fine-tuning 参数高效微调 减少参数调整的微调方法 Model scaling 模型扩展 增加模型规模以提升性能 Compute-optimal scaling 计算最优扩展 优化计算资源的使用 Data-optimal scaling 数据最优扩展 优化数据使用的扩展 Encoder-decoder architecture 编码解码器架构 某些 LLM 的架构 Auto-regressive model 自回归模型 生成文本的模型类型 Bidirectional model 双向模型 考虑前后文的模型 Self-supervision 自监督 无需标签的训练方法 Unsupervised learning 无监督学习 无标签数据的学习 Supervised learning 监督学习 有标签数据的学习 ","date":"2025-03-24T22:30:59+08:00","permalink":"https://blog.yellster.top/p/llm-terminology-chinese-translations/","title":"LLM领域的术语及其中文翻译"},{"content":"计算机的存储设备 计算机中包括三种类型的存储设备：\n硬盘（hard disk）, 用于长期存储大量数据 内存（random-access memory, RAM）, 用于临时存储程序运行中正在处理的数据 缓存（cache memory）, 用于存储经常访问的数据和指令 在程序运行时，数据会从硬盘中被读取到内存中，供 CPU 计算使用。缓存可以看作 CPU 的一部分，它通过智能地从内存加载数据，给 CPU 提供高速的数据读取，从而显著提升程序的执行效率，减少对较慢的内存的依赖。\n硬盘 内存 缓存 用途 长期存储数据，包括操作系统、程序、文件等 临时存储当前运行的程序和正在处理的数据 存储经常访问的数据和指令，减少 CPU 访问内存的次数 易失性 断电后数据不会丢失 断电后数据会丢失 断电后数据会丢失 容量 较大，TB 级别 较小，GB 级别 非常小，MB 级别 速度 较慢，几百到几千 MB/s 较快，几十 GB/s 非常快，几十到几百 GB/s 价格 较便宜，几毛到几元 / GB 较贵，几十到几百元 / GB 非常贵，随 CPU 打包计价 硬盘难以被内存取代 首先，内存中的数据在断电后会丢失，因此它不适合长期存储数据； 其次，内存的成本是硬盘的几十倍，这使得它难以在消费者市场普及。 缓存的大容量和高速度难以兼得 随着 L1、L2、L3 缓存的容量逐步增大，其物理尺寸会变大，与 CPU 核心之间的物理距离会变远，从而导致数据传输时间增加，元素访问延迟变高。 在当前技术下，多层级的缓存结构是容量、速度和成本之间的最佳平衡点。 内存效率 内存是有限的，且同一块内存不能被多个程序共享，因此我们希望数据结构能够尽可能高效地利用空间。\n数组的元素紧密排列，不需要额外的空间来存储链表节点间的引用（指针），因此空间效率更高。然而，数组需要一次性分配足够的连续内存空间，这可能导致内存浪费，数组扩容也需要额外的时间和空间成本。相比之下，链表以“节点”为单位进行动态内存分配和回收，提供了更大的灵活性。\n在程序运行时，随着反复申请与释放内存，空闲内存的碎片化程度会越来越高，从而导致内存的利用效率降低。数组由于其连续的存储方式，相对不容易导致内存碎片化。相反，链表的元素是分散存储的，在频繁的插入与删除操作中，更容易导致内存碎片化。\n内存碎片化 在程序运行过程中，反复申请和释放内存会导致内存碎片化，从而降低内存利用效率。\n内存碎片化的本质是内存分配和释放的不连续操作导致空闲内存分散，无法高效利用。\n理解这一机制有助于：\n优化内存分配策略（如减少小对象分配）。 选择合适的工具（如内存池或高效分配器）。 在系统设计阶段规避潜在的内存瓶颈。 内存分配的基本机制 程序运行时，动态内存（堆内存）的分配和释放由内存管理器（如 malloc/free）负责。\n内存管理器需要维护一个空闲内存块列表，记录哪些内存区域是未被占用的。\n内存申请：当程序申请内存时，内存管理器会从空闲列表中找到一个足够大的连续内存块分配给程序。 内存释放：当程序释放内存时，内存管理器将释放的内存块重新标记为空闲，并合并相邻的空闲块（如果可能）。 内存碎片化的类型 内存碎片化分为两种类型：\n外部碎片（External Fragmentation） 空闲内存分散在已分配内存块之间，形成许多小的、不连续的空闲块。\n即使总的空闲内存足够，但缺乏足够大的连续内存块，导致无法满足后续较大的内存申请请求。\n假设堆内存初始为 100KB 连续空间。 程序依次申请了 20KB、30KB、50KB 的内存块，然后释放中间的 30KB。 此时空闲内存为 30KB，但被分割为两部分：20KB（已分配）和 30KB（空闲）之间夹着 50KB（已分配）。 若程序需要申请 40KB，虽然总空闲内存为 30KB + 后续可能的其他空闲块，但无法找到连续的 40KB 空间，导致分配失败。 内部碎片（Internal Fragmentation） 分配给程序的内存块中，未被实际使用的部分。浪费已分配的内存空间。\n内存管理器按固定大小（如 16KB）分配内存块，但程序仅需要 10KB。 剩余的 6KB 未被使用，但无法被其他程序利用。 内存碎片化的形成过程 初始状态 堆内存为连续的空闲块（例如 100KB）。\n多次分配与释放 程序依次申请不同大小的内存块（如 20KB、30KB、40KB）。 随后释放部分内存块（如中间的 30KB）。 释放的内存块被标记为空闲，但可能与相邻的空闲块合并（取决于内存管理器的策略）。 碎片化加剧 反复的分配和释放操作会导致空闲内存块逐渐被分割成更小的、非连续的块。 即使总空闲内存足够，但无法满足较大的连续内存请求。 示例场景 1 2 3 4 5 初始内存 [----------------100KB----------------] 分配后： [A:20KB][B:30KB ][C:50KB ] 释放B后： [A:20KB][---30KB---][C:50KB ] 此时，总空闲内存为 30KB，但被分割为两部分（假设内存管理器未合并相邻空闲块）。 若申请 40KB，会失败，因为没有连续的 40KB 空间。 内存碎片化的影响 内存利用率下降：大量小空闲块无法被有效利用。 分配延迟增加：内存管理器需要更复杂的策略来查找可用内存块。 程序崩溃风险：无法满足关键内存申请时，程序可能崩溃或抛出异常（如 OutOfMemoryError）。 内存管理器的应对策略 为减少碎片化，内存管理器会采用以下策略：\n合并相邻空闲块（Coalescing） 释放内存时，检查相邻块是否空闲，若空闲则合并为一个更大的块。 示例：释放 B（30KB）后，若相邻块 A 或 C 是空闲的，则合并它们。 内存分配算法 首次适应（First Fit）：从空闲列表头部开始查找第一个足够大的块。 最佳适应（Best Fit）：查找最小的足够大的块。 最差适应（Worst Fit）：查找最大的块。 伙伴系统（Buddy System）：将内存按 2 的幂次大小分割，便于合并。 内存池（Memory Pool） 预分配多个固定大小的内存块，减少内部碎片（但可能增加外部碎片）。 实际应用中的解决方案 避免频繁小内存分配：使用对象池或缓存重用对象。 使用高效的内存分配器：如 jemalloc 或 tcmalloc，优化碎片化问题。 垃圾回收（GC）：在托管语言（如 Java、C#）中，GC 会自动合并碎片（但仍有停顿时间成本）。 内存压缩：移动已分配内存块以合并空闲空间（需暂停程序，如某些 GC 策略）。 缓存效率 缓存虽然在空间容量上远小于内存，但它比内存快得多，在程序执行速度上起着至关重要的作用。\n由于缓存的容量有限，只能存储一小部分频繁访问的数据，因此当 CPU 尝试访问的数据不在缓存中时，就会发生缓存未命中（cache miss），此时 CPU 不得不从速度较慢的内存中加载所需数据。\n显然，“缓存未命中”越少，CPU 读写数据的效率就越高，程序性能也就越好。\n我们将 CPU 从缓存中成功获取数据的比例称为缓存命中率（cache hit rate），这个指标通常用来衡量缓存效率。\n为了尽可能达到更高的效率，缓存会采取以下数据加载机制。\n缓存行：缓存不是单个字节地存储与加载数据，而是以缓存行为单位。相比于单个字节的传输，缓存行的传输形式更加高效。 预取机制：处理器会尝试预测数据访问模式（例如顺序访问、固定步长跳跃访问等），并根据特定模式将数据加载至缓存之中，从而提升命中率。 空间局部性：如果一个数据被访问，那么它附近的数据可能近期也会被访问。因此，缓存在加载某一数据时，也会加载其附近的数据，以提高命中率。 时间局部性：如果一个数据被访问，那么它在不久的将来很可能再次被访问。缓存利用这一原理，通过保留最近访问过的数据来提高命中率。 实际上，数组和链表对缓存的利用效率是不同的，主要体现在以下几个方面。\n占用空间：链表元素比数组元素占用空间更多，导致缓存中容纳的有效数据量更少。 缓存行：链表数据分散在内存各处，而缓存是“按行加载”的，因此加载到无效数据的比例更高。 预取机制：数组比链表的数据访问模式更具“可预测性”，即系统更容易猜出即将被加载的数据。 空间局部性：数组被存储在集中的内存空间中，因此被加载数据附近的数据更有可能即将被访问。 总体而言，数组具有更高的缓存命中率，因此它在操作效率上通常优于链表。但需要注意的是，高缓存效率并不意味着数组在所有情况下都优于链表。实际应用中选择哪种数据结构，应根据具体需求来决定。\n","date":"2025-03-19T14:41:19+08:00","permalink":"https://blog.yellster.top/p/ram_and_cache/","title":"计算机内存与缓存"},{"content":"栈和堆都是代码在运行时可供使用的内存，但是它们的结构不同。\n栈，Stack 栈以放入值的顺序存储值并以相反顺序取出值。这也被称作 后进先出（last in, first out）。\n想象一下一叠盘子：当增加更多盘子时，把它们放在盘子堆的顶部，当需要盘子时，也从顶部拿走。\n不能从中间也不能从底部增加或拿走盘子！\n增加数据叫做 进栈（pushing onto the stack），而移出数据叫做 出栈（popping off the stack）。\n栈中的所有数据都必须占用已知且固定的大小。\n在编译时大小未知或大小可能变化的数据，要改为存储在堆上。\n堆，Heap 堆是缺乏组织的：当向堆放入数据时，你要请求一定大小的空间。\n内存分配器（memory allocator）在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的 指针（pointer）。 这个过程称作 在堆上分配内存（allocating on the heap），有时简称为 “分配”（allocating）。（将数据推入栈中并不被认为是分配）。\n因为指向放入堆中数据的指针是已知的并且大小是固定的，你可以将该指针存储在栈上，不过当需要实际数据时，必须访问指针。\n想象一下去餐馆就座吃饭。当进入时，你说明有几个人，餐馆员工会找到一个够大的空桌子并领你们过去。 如果有人来迟了，他们也可以通过询问来找到你们坐在哪。\n比较 入栈比在堆上分配内存要快，因为（入栈时）分配器无需为存储新数据去搜索内存空间；其位置总是在栈顶。 相比之下，在堆上分配内存则需要更多的工作，这是因为分配器必须首先找到一块足够存放数据的内存空间，并接着做一些记录为下一次分配做准备。\n访问堆上的数据比访问栈上的数据慢，因为必须通过指针来访问。现代处理器在内存中跳转越少就越快（缓存）。\n继续类比，假设有一个服务员在餐厅里处理多个桌子的点菜。 在一个桌子报完所有菜后再移动到下一个桌子是最有效率的。 从桌子 A 听一个菜，接着桌子 B 听一个菜，然后再桌子 A，然后再桌子 B 这样的流程会更加缓慢。 出于同样原因，处理器在处理的数据彼此较近的时候（比如在栈上）比较远的时候（比如可能在堆上）能更好的工作。\n当你的代码调用一个函数时，传递给函数的值（包括可能指向堆上数据的指针）和函数的局部变量被压入栈中。当函数结束时，这些值被移出栈。\n","date":"2024-12-09T16:19:57+08:00","permalink":"https://blog.yellster.top/p/heap-and-stack/","title":"堆与栈"},{"content":"所有权，ownership What is Ownership? - The Rust Programming Language (rust-lang.org)\n所有权规则 Rust 中的每一个值都有一个 所有者（owner） 值在任一时刻有且只有一个所有者 当所有者（变量）离开作用域，这个值将被丢弃，（例如，函数执行完） 变量作用域 变量的作用域从声明开始，到最后一次使用的地方结束\n1 2 3 4 5 { // s 在这里无效，它尚未声明 let s = \u0026#34;hello\u0026#34;; // 从此处起，s 是有效的 println!(\u0026#34;{}\u0026#34;, s); // 使用 s } // 此作用域已结束，s 不再有效 [!tip]\n当 s 进入作用域 时，它就是有效的 这一直持续到它 离开作用域 为止 内存与分配 在有 垃圾回收（garbage collector，GC）的语言中，GC 记录并清除不再使用的内存，而我们并不需要关心它。 在大部分没有 GC 的语言中，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。 从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。\n如果忘记回收了会浪费内存 如果过早回收了，将会出现无效变量 如果重复回收，这也是个 bug、 我们需要精确的为一个 allocate 配对一个 free。 Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。\n当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 drop。 在这里 String 的作者可以放置释放内存的代码，Rust 在结尾的 } 处自动调用 drop。\n1 2 3 4 5 6 { let s = String::from(\u0026#34;hello\u0026#34;); // 从此处起，s 是有效的 // 使用 s } // 此作用域已结束， // s 不再有效 [!warning] 在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 资源获取即初始化（Resource Acquisition Is Initialization (RAII)）\n移动: 变量与数据交互的方式 在 Rust 中，多个变量可以采取不同的方式与同一数据进行交互。\n将变量 x 的整数值赋给 y：\n将 5 绑定到 x 将 x 的拷贝并绑定到 y 整数是有已知固定大小的简单值，所以这两个 5 被放入了栈中 1 2 let x = 5; let y = x; 现在看看这个 String 版本： 第二行可能会生成一个 s1 的拷贝并绑定到 s2 上。不过，事实上并不完全是这样\n1 2 let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; String 由三部分组成\n左侧所示： ptr，指向存放字符串内容内存的指针 len，长度，表示当前 String 内容使用了多少字符数 capacity，容量，表示当前 String 内容从分配器总共获取了多少字节的内存 capacity \u0026gt;= len，capacity 包括了为字符串内容预留的内存量，即使在字符串为空时也是如此 这一组数据存储在栈上，右侧则是堆上存放内容的内存部分 ![[1.学习/1.开发语言/Rust/assets/trpl04-01.svg|300]] 当我们将 s1 赋值给 s2，String 的数据被复制了，这意味着我们从栈上拷贝了它的指针、长度和容量。 我们并没有复制指针指向的堆上数据。 ![[1.学习/1.开发语言/Rust/assets/trpl04-02.svg|300]]\n如果 Rust 也拷贝了堆上的数据，那么内存看起来就是这样的。 如果 Rust 这么做了，那么操作 s2 = s1 在堆上数据比较大的时候会对运行时性能造成非常大的影响。 ![[1.学习/1.开发语言/Rust/assets/trpl04-03.svg|300]]\n[!WANING] 当变量离开作用域后，Rust 自动调用 drop 函数并清理变量的堆内存。 复制，两个数据指针指向了同一位置。 这就有了一个问题：当 s2 和 s1 离开作用域，它们都会尝试释放相同的内存。 这是一个叫做 二次释放（double free）的错误，也是之前提到过的内存安全性 bug 之一。 两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。\n为了确保内存安全，在 let s2 = s1; 之后，Rust 认为 s1 不再有效，因此 Rust 不需要在 s1 离开作用域后清理任何东西。 这段代码不能运行：\n1 2 3 let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{s1}, world!\u0026#34;); 你会得到一个类似如下的错误，因为 Rust 禁止你使用无效的引用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 $ cargo run Compiling ownership v0.1.0 (file:///projects/ownership) error[E0382]: borrow of moved value: `s1` --\u0026gt; kafka-producer/src/main.rs:16:15 | 14 | let s1 = String::from(\u0026#34;hello\u0026#34;); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait 15 | let s2 = s1; | -- value moved here 16 | println!(\u0026#34;{s1}, world!\u0026#34;); | ^^^^ value borrowed here after move | = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info) help: consider cloning the value if the performance cost is acceptable | 15 | let s2 = s1.clone(); | ++++++++ For more information about this error, try `rustc --explain E0382`. warning: `kafka-producer` (bin \u0026#34;kafka-producer\u0026#34;) generated 1 warning error: could not compile `kafka-producer` (bin \u0026#34;kafka-producer\u0026#34;) due to 1 previous error [!TIP] 如果你在其他语言中听说过术语 浅拷贝（shallow copy）和 深拷贝（deep copy），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。 不过因为 Rust 同时使第一个变量无效了，这个操作被称为 移动（move），而不是叫做浅拷贝。 上面的例子可以解读为 s1 被 移动 到了 s2 中。 ![[1.学习/1.开发语言/Rust/assets/trpl04-04.svg|300]]\n这样就解决了我们的问题！因为只有 s2 是有效的，当其离开作用域，它就释放自己的内存，完毕。\n另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。 因此，任何 自动 的复制都可以被认为是对运行时性能影响较小的。\n克隆: 变量与数据交互的方式 如果 确实 需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的通用函数。\n这是一个实际使用 clone 方法的例子：\n1 2 3 let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); println!(\u0026#34;s1 = {s1}, s2 = {s2}\u0026#34;); 这段代码能正常运行，这里堆上的数据 确实 被复制了。 ![[1.学习/1.开发语言/Rust/assets/trpl04-03.svg|300]]\n拷贝: 只在栈上的数据 1 2 3 let x = 5; let y = x; println!(\u0026#34;x = {x}, y = {y}\u0026#34;); 但这段代码似乎似乎和上面的内容相矛盾：没有调用 clone，不过 x 依然有效且没有被移动到 y 中。\n原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。这意味着没有理由在创建变量 y 后使 x 无效。 换句话说，这里没有深浅拷贝的区别，所以这里调用 clone 并不会与通常的浅拷贝有什么不同，可以不用管它。\nRust 有一个叫做 Copy trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。 如果一个类型实现了 Copy trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。\nRust 不允许自身或其任何部分实现了 Drop trait 的类型使用 Copy trait。 如果我们对其值离开作用域时需要特殊处理的类型使用 Copy 注解，将会出现一个编译时错误。\n那么哪些类型实现了 Copy trait 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 Copy，任何不需要分配内存或某种形式资源的类型都可以实现 Copy 。如下是一些 Copy 的类型：\n所有整数类型，比如 u32。 布尔类型，bool，它的值是 true 和 false。 所有浮点数类型，比如 f64。 字符类型，char。 元组，当且仅当其包含的类型也都实现 Copy 的时候。比如，(i32, i32) 实现了 Copy，但 (i32, String) 就没有。 所有权与函数 将值传递给函数与给变量赋值的原理相似。向函数传递值可能会移动或者复制，就像赋值语句一样。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 fn main() { let s = String::from(\u0026#34;hello\u0026#34;); // s 进入作用域 takes_ownership(s); // s 的值移动到函数里 ... // ... 所以到这里不再有效 let x = 5; // x 进入作用域 makes_copy(x); // x 应该移动函数里， // 但 i32 是 Copy 的， // 所以在后面可继续使用 x } // 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走， // 没有特殊之处 fn takes_ownership(some_string: String) { // some_string 进入作用域 println!(\u0026#34;{}\u0026#34;, some_string); } // 这里，some_string 移出作用域并调用 `drop` 方法。 // 占用的内存被释放 fn makes_copy(some_integer: i32) { // some_integer 进入作用域 println!(\u0026#34;{}\u0026#34;, some_integer); } // 这里，some_integer 移出作用域。没有特殊之处 当尝试在调用 takes_ownership 后使用 s 时，Rust 会抛出一个编译时错误。这些静态检查使我们免于犯错。\n返回值与作用域 返回值也可以转移所有权。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 fn main() { let s1 = gives_ownership(); // gives_ownership 将返回值 // 转移给 s1 let s2 = String::from(\u0026#34;hello\u0026#34;); // s2 进入作用域 let s3 = takes_and_gives_back(s2); // s2 被移动到 // takes_and_gives_back 中， // 它也将返回值移给 s3 } // 这里，s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走， // 所以什么也不会发生。s1 离开作用域并被丢弃 fn gives_ownership() -\u0026gt; String { // gives_ownership 会将 // 返回值移动给 // 调用它的函数 let some_string = String::from(\u0026#34;yours\u0026#34;); // some_string 进入作用域。 some_string // 返回 some_string // 并移出给调用的函数 // } // takes_and_gives_back 将传入字符串并返回该值 fn takes_and_gives_back(a_string: String) -\u0026gt; String { // a_string 进入作用域 // a_string // 返回 a_string 并移出给调用的函数 } 变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。 当持有堆中数据值的变量离开作用域时，其值将通过 drop 被清理掉，除非数据被移动为另一个变量所有。\n虽然这样是可以的，但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。\n我们可以使用元组来返回多个值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 fn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let (s2, len) = calculate_length(s1); println!(\u0026#34;The length of \u0026#39;{}\u0026#39; is {}.\u0026#34;, s2, len); } fn calculate_length(s: String) -\u0026gt; (String, usize) { let length = s.len(); // len() 返回字符串的长度 (s, length) } 但是这未免有些形式主义，而且这种场景应该很常见。幸运的是，Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 引用（references）。\n","date":"2024-12-09T12:46:41+08:00","permalink":"https://blog.yellster.top/p/ownership/","title":"Rust学习笔记01 - 所有权"},{"content":"在开始 Rust 开发之旅之前，我们需要配置一个高效的开发环境。本文将详细介绍如何搭建一个完整的 Rust 开发环境，包括必要的工具和插件。\n1. 安装 Rust 首先，我们需要安装 Rust 编程语言。使用以下命令安装 Rust：\n1 curl --proto \u0026#39;=https\u0026#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh 这个命令会安装 Rust 编译器（rustc）和包管理器（cargo）。\n2. VSCode 插件配置 VSCode 是推荐的 Rust 开发 IDE，以下是一些必备的插件：\n核心插件 rust-analyzer: Rust 语言支持，提供代码补全、类型检查等功能 crates: Rust 包管理工具 Even Better TOML: TOML 文件支持 Better Comments: 优化注释显示 Error Lens: 错误提示优化 开发效率插件 GitLens: Git 增强功能 Github Copilot: AI 代码提示 indent-rainbow: 缩进显示优化 Prettier: 代码格式化 REST client: REST API 调试工具 测试相关插件 Rust Test lens: Rust 测试支持 Rust Test Explorer: Rust 测试概览 其他实用插件 TODO Highlight: TODO 高亮 vscode-icons: 文件图标优化 YAML: YAML 文件支持 3. 开发工具链配置 Cargo Generate 用于生成项目模板的工具：\n1 cargo install cargo-generate 使用模板创建新项目：\n1 cargo generate tyr-rust-bootcamp/template Pre-commit 代码提交前的检查工具：\n1 2 pipx install pre-commit pre-commit install Cargo Deny 依赖安全检查工具：\n1 cargo install --locked cargo-deny Typos 拼写检查工具：\n1 cargo install typos-cli Git Cliff 生成 changelog 的工具：\n1 cargo install git-cliff Cargo Nextest 增强的测试工具：\n1 cargo install cargo-nextest --locked 总结 配置一个完整的 Rust 开发环境需要安装多个工具和插件。这些工具共同构成了一个高效的开发工作流：\n使用 rust-analyzer 提供智能的代码补全和错误检查 通过 pre-commit 确保代码质量 使用 cargo-deny 保证依赖安全 借助 cargo-nextest 进行高效的测试 这些工具的组合使用可以显著提升 Rust 开发效率和代码质量。建议根据实际需求选择性地安装这些工具，不必一次性全部配置。\n","date":"2024-10-19T10:32:07+08:00","permalink":"https://blog.yellster.top/p/rust-development-environment/","title":"Rust学习笔记00 - 开发工具和环境"},{"content":"​零拷贝（Zero-Copy） 是一种操作系统级别的 I/O 优化技术，旨在减少或避免数据在内存中的多次拷贝，降低 CPU 占用率，提高数据传输效率，尤其适用于高并发、大吞吐量的场景，如网络通信、文件传输等。\n传统 I/O 的调用 传统 I/O 操作中，数据需要从磁盘文件拷贝到内核空间，再从内核空间拷贝到用户空间，然后再拷贝到 Socket Buffer 中，再拷贝到网卡设备。\n传统的 I/O 操作过程中，涉及到 4 次上下文切换（用户态和内核态的上下文切换）和 4 次数据拷贝（2 次 CPU 拷贝、2 次 DMA 拷贝）：\n上下文从用户态切换到内核态：应用程序进程调用 read ，发起 I/O 调用； DMA 拷贝：DMA 控制器 将数据从 磁盘文件（硬件设备） 拷贝到 内核缓冲区（内核空间）； 上下文从内核态切换到用户态：read 调用返回； CPU 拷贝：CPU 将数据从 内核缓冲区（内核空间） 拷贝到 用户缓冲区（用户空间）； 上下文从用户态切换到内核态：应用程序进程调用 write ，发起 I/O 调用； CPU 拷贝：CPU 将数据从 用户缓冲区（用户空间） 拷贝到 Socket Buffer（内核空间）； DMA 拷贝：DMA 控制器 将数据从 Socket Buffer（内核空间） 拷贝到 网卡设备（硬件设备）； 上下文从内核态切换到用户态：wirte 调用返回。 零拷贝 相比 传统 I/O 调用，零拷贝通过直接拷贝数据，避免了多次拷贝操作。\n零拷贝并不是没有拷贝数据，而是减少用户态/内核态的切换次数以及CPU拷贝的次数。\n零拷贝的实现方式 mmap + write 上下文从用户态切换到内核态：应用程序进程发起 mmap 调用； DMA 拷贝：DMA 控制器 将数据从 磁盘文件（硬件设备） 拷贝到 内核缓冲区（内核空间）； 上下文从内核态切换到用户态：内核缓冲区（内核空间） 地址和 用户缓冲区（用户空间）地址映射，内核缓冲区和应用缓冲区共享，mmap 调用返回； 上下文从用户态切换到内核态：应用程序进程调用 write ，发起 I/O 调用； CPU 拷贝：CPU 将数据从 用户缓冲区（用户空间） 拷贝到 Socket Buffer（内核空间）； DMA 拷贝：DMA 控制器 根据 文件描述符信息 直接把数据从 内核缓冲区（内核空间） 拷贝到 网卡设备（硬件设备）； 上下文从内核态切换到用户态：write 调用返回。 mmap + write 调用涉及到 4 次上下文切换 和 3 次数据拷贝（1 次 CPU 拷贝、2 次 DMA 拷贝）。\nmmap 是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，所以节省了一次CPU拷贝，并且用户进程内存是虚拟的，只是映射到内核的读缓冲区，可以节省一半的内存空间。\nsendfile sendfile表示在两个文件描述符之间传输数据，它是在 操作系统内核 中操作的，避免了数据从内核缓冲区和用户缓冲区之间的拷贝操作，因此可以使用它来实现零拷贝。\n上下文从用户态切换到内核态：应用程序进程发起 sendfile 调用； DMA 拷贝：DMA 控制器 将数据从 磁盘文件（硬件设备） 拷贝到 内核缓冲区（内核空间）； CPU 拷贝：CPU 将数据从 内核缓冲区（内核空间） 拷贝到 Socket Buffer（内核空间）； DMA 拷贝：DMA 控制器 将数据从 Socket Buffer（内核空间） 拷贝到 网卡设备（硬件设备）； 上下文从内核态切换到用户态：sendfile 调用返回。 相比传统 I/O 调用，sendfile 调用涉及到 2 次上下文切换 和 3 次数据拷贝（1 次 CPU 拷贝、2 次 DMA 拷贝）。\nsendfile + SG-DMA Linux 2.4+版本提出。\n上下文从用户态切换到内核态：应用程序进程发起 sendfile 调用； DMA 拷贝：DMA 控制器 将数据从 磁盘文件（硬件设备） 拷贝到 内核缓冲区（内核空间）； 只拷贝文件描述符信息：CPU 将 内核缓冲区（内核空间） 中的 文件描述符信息（包括内核缓冲区的内存地址和偏移量） 拷贝到 Socket Buffer（内核空间）； DMA 拷贝：DMA 控制器 根据 文件描述符信息 直接把数据从 内核缓冲区（内核空间） 拷贝到 网卡设备（硬件设备）； 上下文从内核态切换到用户态：sendfile 调用返回。 相比单独的 sendfile，sendfile + SG-DMA 调用涉及到 2 次上下文切换 和 2 次数据拷贝（2 次 DMA 拷贝）。\n真正实现了 零拷贝，全程都没有通过CPU来搬运数据，所有的数据都是通过DMA来进行传输的。\n对比 方法 上下文切换 拷贝次数 CPU参与 适用场景 传统I/O 4次 4次 2次 通用场景（性能较低） mmap + write 4次 3次 1次 需用户态处理数据的场景 sendfile 2次 3次 1次 文件到网络的高性能传输 sendfile + SG-DMA 2次 2次 0次 文件到网络的高性能传输 扩展 内核空间和用户空间 内核空间：操作系统内核运行的内存区域，具有最高权限，可以直接访问硬件、内存管理、文件系统等底层资源。 用户空间：应用程序运行的内存区域，具有较低权限，只能访问受限的资源，如自己的内存、文件等，必须通过 系统调用（System Call） 请求内核资源。 地址空间划分（以 32 位系统、4GB 为例）： 内核空间：0xC0000000 ~ 0xFFFFFFFF，约占 1GB，所有进程共享，用于存放内核代码、内核数据、设备驱动等。 用户空间：0x00000000 ~ 0xBFFFFFFF，约占 3GB，每个进程独享，用于存放用户代码、用户数据、栈、堆等。 隔离性 安全性：防止用户程序误操作（如内存越界）导致系统崩溃。例如，用户态程序无法直接清空内存或配置硬件参数。 稳定性：若用户程序崩溃（如空指针异常），仅影响自身用户空间，内核空间仍可正常运行，保障系统其他进程。 资源管理：内核统一管理硬件资源（CPU、内存、I/O），避免用户程序直接竞争资源。 内核态和用户态 内核态：操作系统内核运行的模式，具有最高权限，可直接访问硬件、内存管理、文件系统等底层资源。 用户态：应用程序运行的模式，具有较低权限，只能访问受限的资源，如自己的内存、文件等，必须通过 系统调用（System Call） 请求内核资源。 如何切换？ 场景 描述 系统调用 用户程序主动请求内核服务（如write()），通过int 0x80指令触发切换。 异常 CPU执行用户程序时发生错误（如缺页异常），强制切换到内核态处理。 硬件中断 外设完成操作后（如磁盘I/O完成），中断信号触发切换。 用户态 → 内核态：\n执行特权指令（如int 0x80），CPU切换到Ring 0。 保存用户态现场（寄存器、用户栈指针）到内核栈。 执行内核代码（如系统调用处理程序）。 内核态 → 用户态：\n内核代码执行完毕（如文件写入完成）。 恢复用户态现场（从内核栈加载寄存器、用户栈指针）。 通过sysret指令切换回Ring 3，继续用户程序。 示例：用户程序调用write()写入文件时：\n用户态程序通过库函数触发系统调用。 CPU切换到内核态，保存用户栈到内核栈。 内核执行文件写入，完成后恢复用户栈。 CPU切换回用户态，程序继续执行。 微内核和宏内核 微内核（Micro Kernel）： 一种精简的内核设计，仅包含操作系统最基本的核心功能，如进程管理、线程管理、IPC和基本的内存管理。 其他操作系统功能，如设备驱动、文件系统和网络协议等，则以用户态进程的形式运行。这种设计使得内核代码量小、结构清晰，便于扩展和维护，同时提高了系统的稳定性和安全性。 宏内核（Monolithic Kernel）： 一种将大部分操作系统功能（如进程管理、内存管理、设备驱动、文件系统等）集成在一个大内核中的设计。 所有这些功能都运行在内核空间，通过函数调用直接交互。这种设计使得系统性能较高，因为减少了上下文切换和IPC的开销，但内核代码庞大且复杂，维护困难，且一个模块的崩溃可能导致整个系统崩溃。 主要区别：\n结构设计： 微内核 将大部分功能分离到用户空间，通过IPC通信； 宏内核 将所有功能集成在内核空间，通过函数调用通信； 性能： 微内核 由于频繁的IPC和上下文切换，性能可能较低； 宏内核 通常性能更高，因为减少了IPC开销； 稳定性和安全性： 微内核 由于内核代码少，攻击面小，且服务隔离，稳定性更高； 宏内核 由于功能集中，一个模块的崩溃可能导致整个系统崩溃； 扩展性和维护： 微内核 的模块化设计便于扩展和维护； 宏内核 由于代码复杂，维护和扩展较为困难。 典型例子：\n微内核：QNX、Minix、华为鸿蒙系统； 宏内核：Linux、传统的Unix系统、Windows。 上下文切换 上下文切换 是操作系统在CPU核心上切换任务执行状态的过程，具体包括：\n保存当前任务状态：用户态虚拟内存、寄存器、程序计数器、内核堆栈等。 加载新任务状态：从内核的进程控制块（PCB）中恢复新任务的资源。 触发条件：进程调度（时间片耗尽、I/O完成）、线程切换、中断响应等。 关键点：\n系统调用会触发两次上下文切换（用户态→内核态→用户态），但不涉及进程切换。 切换耗时：每次约几十纳秒到数微秒，高频切换会显著降低CPU利用率。 类型 触发场景 涉及资源 进程切换 多进程竞争CPU（时间片耗尽、进程终止、资源等待） 用户态虚拟内存、内核堆栈、寄存器、全局变量（需完全切换） 线程切换 多线程共享进程资源（同进程内线程切换更高效） 仅切换线程私有数据（寄存器、栈），共享进程虚拟内存和全局变量 中断切换 硬件中断（如I/O完成、定时器中断）触发内核中断服务程序（ISR） 仅内核态资源（寄存器、内核堆栈），不涉及用户态资源 进程切换耗时更高：需刷新TLB（Translation Lookaside Buffer），导致内存访问延迟。 线程切换更轻量：共享虚拟内存，无需刷新TLB，耗时约为进程切换的1/10。 DMA DMA（Direct Memory Access，直接内存访问） 是一种硬件机制，允许外设直接与计算机内存交换数据，不需要 CPU 介入每一步拷贝。它是现代计算机系统中提升效率、减少CPU占用率的核心技术。\n以从磁盘读取数据到内存为例：\n传统数据传输： CPU发送读取命令； 磁盘将数据读取到设备侧的 内部缓冲区（Buffer） 中； CPU 通过 轮询或中断 方式获取数据，逐字节或逐块 读取设备 Buffer 中的数据，再写入内存； 在数据传输期间，CPU 需持续参与搬运工作，无法执行其他任务，效率较低。 DMA 数据传输： CPU发送读取命令，并配置 DMA 控制器（源地址、目的地址、数据长度）； 磁盘将数据读取到设备缓冲区； DMA控制器 自动将数据从设备 Buffer 直接写入内存，无需 CPU 参与； 传输完成后，DMA 发出 中断通知 CPU，CPU 可在此期间处理其他任务，整体效率显著提升。 ","date":"2024-09-21T16:09:09+08:00","image":"https://blog.yellster.top/p/zero-copy/zero-copy_hu_262fc1a87e0eff49.png","permalink":"https://blog.yellster.top/p/zero-copy/","title":"零拷贝"},{"content":"什么是KISS原则？ KISS原则（Keep It Simple, Stupid - 保持简单，笨蛋）是一种强调简洁性的设计哲学，主张在面对问题时，采用最直接、最简单的解决方案，避免不必要的复杂性。\n这个原则最初由洛克希德公司的首席工程师凯利·约翰逊提出，他要求设计的飞机必须足够简单，普通机械师只需基础工具便能进行维修。这一理念随后被广泛应用到软件开发领域。\n核心思想 1. 追求简单性 选择最直接的解决方案：每个问题都有多种解决方案，选择其中最简洁的一种。 避免过度设计和不必要的功能：避免“过度工程”导致的冗余和复杂性。 保持代码清晰易懂：通过简洁明了的命名和结构，提高代码的可读性。 2. 消除复杂性 减少依赖关系：尽量避免复杂的相互依赖，让系统更易于扩展和维护。 避免深层嵌套：避免过深的层级结构，使代码更加直观。 简化业务逻辑：简化逻辑实现，减少不必要的分支和判断。 3. 关注可维护性 编写自文档化的代码：代码应该本身就能表达它的功能和意图，减少依赖外部文档。 保持代码结构扁平：避免过多的嵌套和深层次的层级结构，保持代码结构简单明了。 提高代码复用性：编写高内聚、低耦合的模块，增加代码的可复用性。 实践指南 代码层面 函数设计\n保持函数短小精悍，专注于单一职责。 每个函数只做一件事，避免函数承担过多任务。 命名要清晰、准确，避免模糊不清。 类设计\n避免过度继承，适当使用组合来减少类之间的耦合。 使用设计模式时，选择最合适的模式，避免过度设计。 限制类的大小，使其职责单一，保持代码可维护性。 架构设计\n采用模块化设计，分解复杂问题为更简单的子问题。 低耦合，高内聚：确保模块之间的依赖最小化，内部功能紧密相关。 简化数据流和控制流，让系统的工作方式一目了然。 最佳实践 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 # 反面示例：过度复杂，逻辑分散 def process_user_data(user): if user and user.get(\u0026#39;name\u0026#39;) and user[\u0026#39;name\u0026#39;] != \u0026#39;\u0026#39; and user.get(\u0026#39;age\u0026#39;) \u0026gt; 0 and user.get(\u0026#39;email\u0026#39;) and \u0026#39;@\u0026#39; in user[\u0026#39;email\u0026#39;]: # 处理逻辑 return \u0026#34;处理成功\u0026#34; return \u0026#34;处理失败\u0026#34; # 好的示例：简洁且易于维护，逻辑清晰 def process_user_data(user): if not is_valid_user(user): return \u0026#34;处理失败\u0026#34; return \u0026#34;处理成功\u0026#34; def is_valid_user(user): return user and is_valid_name(user.get(\u0026#39;name\u0026#39;)) and is_valid_age(user.get(\u0026#39;age\u0026#39;)) and is_valid_email(user.get(\u0026#39;email\u0026#39;)) def is_valid_name(name): return bool(name) def is_valid_age(age): return age \u0026gt; 0 def is_valid_email(email): return \u0026#39;@\u0026#39; in email 常见误区 过度简化\n简单不等于简陋：过度简化可能会让系统功能丧失，需要在简单性和功能性之间找到平衡。 需要有适当的复杂度：一些复杂的问题需要通过合理的设计进行解决，不能一味追求简单。 理解偏差\nKISS原则并不意味着功能简陋或牺牲必要的功能。简洁应该是经过深思熟虑的“简约”设计，而不是忽略某些核心需求。 简单并不等于易于实现：复杂问题有时需要更细致的解决方案，简化不意味着放弃细节。 相关原则 KISS原则与其他设计原则和思想有密切的联系：\n奥卡姆剃刀： \u0026ldquo;如无必要，勿增实体\u0026rdquo; 强调在多个解释中选择最简单的方案，避免不必要的复杂性。\n爱因斯坦： \u0026ldquo;让一切尽可能简单，但不要过于简单\u0026rdquo; 强调简单的同时，需要考虑适度的复杂性，以保证功能的全面性。\n达芬奇： \u0026ldquo;简单是最终的复杂性\u0026rdquo; 通过深入的思考和提炼，最终可以将复杂的事物简化到最本质的层面。\n实际应用价值 提高开发效率\n通过减少复杂性和冗余，减少开发时间。 更容易理解和调试，提升开发团队的工作效率。 能快速定位并解决问题，减少开发周期。 降低维护成本\n简洁的代码更容易修改和扩展，降低后期维护的复杂度。 清晰的结构和良好的命名使得代码更易于理解，减少了开发人员的学习曲线。 提升系统质量\n通过简化设计和减少不必要的功能，减少潜在的bug。 更可靠的系统架构，便于后期扩展和优化。 总结 KISS原则不仅是一个技术原则，更是一种思维方式。它提醒我们，在软件开发中，我们始终应该追求简洁性，但这种简洁并不是功能简陋，而是在保证系统功能的同时，去除冗余和不必要的复杂性。遵循KISS原则可以帮助我们开发出更加可靠、可维护、易扩展的系统。\n","date":"2024-09-17T19:44:43+08:00","image":"https://blog.yellster.top/p/kiss-principle/kiss_hu_2329c9e005ae3b42.webp","permalink":"https://blog.yellster.top/p/kiss-principle/","title":"KISS原则"},{"content":" 脱离场景谈性能，都是耍流氓。 过早的优化是万恶之源。 优化要基于数据，而非猜测。 性能的本质 性能优化的最终目标是提升用户体验，并提高系统的效率。要达成这一目标，我们需要从系统最基本的组成部分和性能指标入手。\n计算机系统的基本组成 CPU：执行计算的核心\n指令执行：处理各种指令，影响程序的执行速度。 数据处理：进行数值计算、数据操作。 任务调度：协调系统中的多个任务并合理分配资源。 内存：临时数据存储\n数据读写：内存的读写速度直接影响系统的响应时间。 缓存管理：缓存优化有助于减少重复计算，提高效率。 内存分配：合理管理内存的分配与回收，避免内存泄漏。 I/O：数据交换\n网络通信：数据在网络中传输的延迟和带宽。 磁盘读写：磁盘操作的延迟和吞吐量。 设备交互：外部设备的访问速度。 性能的关键指标 响应时间 (Response Time)\n定义：从请求发起到响应完成的时间。 衡量方式： 平均响应时间：常用的基准，衡量系统的总体性能。 P95 / P99：95%或99%的请求响应时间，可以更准确地反映系统在高负载下的表现。 影响因素： 计算复杂度：算法和数据结构的设计。 资源等待时间：CPU、内存或I/O的占用情况。 网络延迟：数据传输中的延迟。 吞吐量 (Throughput)\n定义：单位时间内系统处理的请求数量。 衡量方式： TPS（每秒事务数） QPS（每秒查询数） 影响因素： 系统资源容量：硬件性能的上限。 并发处理能力：系统处理多个请求的能力。 请求处理效率：处理每个请求的速度。 资源利用率\nCPU 使用率：CPU资源是否被充分利用。 内存占用：内存是否得到了合理使用，避免内存过度使用或浪费。 I/O 负载：磁盘与网络的负载情况，避免出现I/O瓶颈。 网络带宽：数据传输的速度和效率。 性能优化的方法论 确定优化目标 明确业务需求\n响应时间：设定用户期望的响应时间。 并发量：定义系统能承载的最大并发请求数。 资源成本：优化是否能控制在可接受的资源消耗范围内。 设定具体指标\n性能目标：设置明确、量化的性能目标。 可测量标准：确保所有优化都可以通过实际数据进行验证。 性能分析 收集性能数据\n系统监控：使用监控工具采集实时的系统指标。 性能测试：通过负载测试、压力测试等手段获取数据。 用户反馈：关注用户的使用体验，发现性能瓶颈。 定位性能瓶颈\nCPU 密集型：算法或代码的计算量过大。 内存问题：内存分配不当，可能导致频繁的垃圾回收或内存泄漏。 I/O 瓶颈：磁盘或网络读写延迟过高。 网络延迟：服务器与客户端之间的传输延迟。 优化策略 CPU 优化 算法优化\n降低时间复杂度：选择合适的算法来减少计算量。 减少不必要的计算：优化代码，避免重复的计算操作。 利用缓存：缓存计算结果，避免重复计算。 并发处理\n多线程优化：通过多核 CPU 的并行计算提高效率。 异步处理：避免阻塞操作，提高响应速度。 任务调度优化：合理安排任务执行的顺序，减少等待时间。 内存优化 内存管理\n避免内存泄漏：及时释放不再使用的内存。 优化对象创建与回收：减少内存分配的频率，避免频繁的GC。 合理设置内存参数：根据业务需求调优JVM或其他内存配置。 缓存策略\n多级缓存设计：使用本地缓存、分布式缓存等技术提高读取性能。 缓存预热：提前加载常用数据，减少请求时的延迟。 缓存更新策略：确保缓存中的数据保持最新，避免缓存不一致问题。 I/O 优化 磁盘 I/O\n批量处理：减少频繁的磁盘读写，采用批量处理来提高效率。 异步 I/O：避免阻塞操作，通过异步方式提高吞吐量。 数据压缩：通过压缩数据减少磁盘读写的负载。 网络 I/O\n连接池管理：有效管理网络连接，避免频繁创建和销毁连接。 数据传输优化：优化数据传输协议，减少数据传输的延迟。 协议优化：使用合适的协议提高通信效率，如 HTTP/2 或 gRPC。 优化实施 循序渐进\n从瓶颈开始：先优化影响最大、最容易解决的瓶颈。 一处改动，一次验证：避免一次性改动过多，确保每次优化都有明确的效果验证。 验证效果\n性能测试：每次优化后进行详细的性能测试，确保效果可量化。 A/B 测试：在真实用户环境中验证优化效果。 生产环境验证：持续在生产环境中监控优化后的效果。 常见优化场景 Web 应用优化 前端优化：减少资源加载时间，提升渲染性能。 后端优化：优化接口响应时间，减少数据库查询延迟。 数据库优化：使用索引、查询优化等手段提升数据库性能。 分布式系统优化 负载均衡：均衡地分配请求到多个服务节点，提高系统的并发能力。 服务拆分：将单一服务拆分为多个小服务，减少单一服务的压力。 数据分片：将数据分片存储，减少单节点的数据压力。 大数据处理优化 数据分区：将数据按一定规则分区，减少单个查询的扫描量。 并行计算：利用分布式计算框架（如 Spark）进行并行计算，提高处理速度。 资源调度：合理分配资源，避免资源浪费和过载。 优化的注意事项 避免过早优化\n优化应基于真实的性能数据，而不是主观臆断。 先保证功能正确，再根据数据进行优化。 优化时要考虑成本和收益，不要在不必要的地方过度优化。 保持简单性\n可维护性优先，避免过度设计和复杂化。 优化应该以简洁、可扩展的方式进行，避免对系统产生负担。 持续监控\n建立监控体系：对系统性能进行实时监控。 及时发现问题：通过监控数据及时发现潜在的性能瓶颈。 评估优化效果：通过监控工具评估每次优化的实际效果。 总结 性能优化是一个持续不断的过程，需要：\n深入理解系统架构，准确定位瓶颈。 建立科学的优化方法，避免过早优化和盲目优化。 持续进行监控和改进，以确保系统始终处于最佳状态。 最重要的是，性能优化永远要基于实际需求和数据，而不是单纯的经验或猜测。始终保持对性能的敏感度，并根据业务变化进行动态调整。\n","date":"2024-09-11T18:19:26+08:00","image":"https://blog.yellster.top/p/performance-optimization/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96_hu_dd5169e10aa8a6c5.webp","permalink":"https://blog.yellster.top/p/performance-optimization/","title":"性能优化：从数据出发，基于实际需求"},{"content":" ODBC, Open Database Connectivity 是由 Microsoft 开发的数据库连接标准。 它允许应用程序使用标准化的接口访问不同的数据库系统。 特点 跨语言支持： ODBC 不是绑定于某种编程语言的，因此可以用于多种编程语言，包括 C、C++、Python 等。 平台依赖性： ODBC 原本是为 Windows 平台设计的，但也有跨平台版本，如 unixODBC 用于 Linux 系统。 使用方式： ODBC 通过 ODBC 驱动与数据库通信。驱动程序通常由数据库供应商提供，或者可以使用第三方驱动。 ODBC 需要在系统中配置数据源名称（DSN），通过 DSN 来标识和连接数据库。 使用 参考地址\n安装驱动 Ubuntu/Debian sudo apt-get install unixodbc unixodbc-dev odbcinst CentOS/RHEL sudo yum install unixODBC unixODBC-devel Windows 在 Windows 上，你可以通过安装 ODBC 数据源管理器和相应的数据库驱动来支持 ODBC。 配置数据源 Linux下，odbc依赖两个配置文件（以达梦8为例）\n配置驱动, /etc/odbcinst.ini 1 2 3 [DM8] Description = ODBC DRIVER FOR Dameng8 Driver = /data0/dm_db/dmdbms/drivers/odbc/libdodbc.so 两个属性，\nDescription，驱动说明 Driver，驱动文件 配置数据源, /etc/odbc.ini 1 2 3 4 5 6 7 8 [DM8] Description = DM ODBC DSN Driver = DM8 SERVER = localhost UID = SYSDBA PWD = SYSDBA TCP_PORT = 5236 LANGUAGE = CHINESE Description，数据源说明 Driver，驱动，要和 odbcinst.ini 中的 selection 保持一致 SERVER，连接的ip UID，账户名称 PWD，账户密码 TCP_PORT，连接端口 LANGUAGE，环境语言 测试 isql \u0026lt;DSN数据源名称\u0026gt; [UID [PWD]]\n","date":"2024-08-12T12:57:17+08:00","permalink":"https://blog.yellster.top/p/odbc/","title":"ODBC"},{"content":"什么是I/O I/O，Input/Output，即输入/输出，是计算机系统中用于数据传输的机制，指的是在计算机和外部设备（键盘、显示器、磁盘等）之间，或在计算机内部组件（内存和 CPU）之间的数据传输过程。\n输入（input）：指将数据从外部设备或内存传入到计算机系统的过程。 输出（output）：指将数据从计算机系统传送到外部设备或内存的过程。 I/O 设备类型：\n块设备：磁盘、光盘、USB设备等，以块为单位读写数据，适合随机访问。 字符设备：键盘、鼠标、串口、打印机等，以字符流为单位读写数据，适合顺序访问。 计算机角度的I/O 我们常说的输入输出，比较直观的意思就是计算机的输入输出，计算机就是主体。\n冯.诺依曼结构，它将计算机分成分为5个部分：运算器、控制器、存储器、输入设备、输出设备。\n输入设备是向计算机输入数据和信息的设备，键盘，鼠标都属于输入设备； 输出设备是计算机硬件系统的终端设备，用于接收计算机数据的输出显示，一般显示器、打印机属于输出设备。 鼠标、显示器这只是直观表面的输入输出，回到计算机架构来说，涉及计算机核心与其他设备间数据迁移的过程，就是I/O。\n如磁盘I/O，就是从磁盘读取数据到内存，这算一次输入，对应的，将内存中的数据写入磁盘，就算输出。这就是I/O的本质。\n操作系统的I/O 我们要将内存中的数据写入到磁盘的话，主体会是什么呢？主体可能是一个应用程序，比如一个Java进程（假设网络传来二进制流，一个Java进程可以把它写入到磁盘）。\n操作系统负责计算机的资源管理和进程的调度。我们电脑上跑着的应用程序，其实是需要经过操作系统，才能做一些特殊操作，如磁盘文件读写、内存的读写等等。因为这些都是比较危险的操作，不可以由应用程序乱来，只能交给底层操作系统来。也就是说，你的应用程序要把数据写入磁盘，只能通过调用操作系统开放出来的API来操作。\n我们应用程序是跑在用户空间的，它不存在实质的I/O过程，真正的I/O是在操作系统执行的。即应用程序的I/O操作分为两种动作：I/O调用和I/O执行。\nI/O调用是由进程（应用程序的运行态）发起，而I/O执行是操作系统内核的工作。此时所说的I/O是应用程序对操作系统I/O功能的一次触发，即I/O调用。\n什么是用户空间？什么是内核空间?\n以32位操作系统为例，它为每一个进程都分配了4G(2的32次方)的内存空间。这4G可访问的内存空间分为二部分，一部分是用户空间，一部分是内核空间。内核空间是操作系统内核访问的区域，是受保护的内存空间，而用户空间是用户应用程序访问的内存区域。\n操作系统的一次I/O过程 应用程序发起的一次I/O操作包含两个阶段：\nI/O调用：应用程序进程向操作系统内核发起调用。 I/O执行：操作系统内核完成I/O操作。 操作系统内核完成I/O操作还包括两个过程：\n准备数据：内核等待I/O设备准备好数据。 拷贝数据：将数据从内核缓冲区拷贝到用户进程缓冲区。 其实I/O就是把进程的内部数据转移到外部设备，或者把外部设备的数据迁移到进程内部。外部设备一般指硬盘、socket通讯的网卡。一个完整的I/O过程包括以下几个步骤：\n应用程序进程向操作系统发起I/O调用请求 操作系统准备数据，把I/O外部设备的数据，加载到内核缓冲区 操作系统拷贝数据，即将内核缓冲区的数据，拷贝到用户进程缓冲区 I/O模型 阻塞 vs 非阻塞 vs 异步 阻塞：调用 read()/write() 时，进程被挂起直至操作完成，简单易用但会导致资源空转。 非阻塞：通过在文件描述符上设置 O_NONBLOCK 标志，使得 read()/write() 调用不会阻塞，而是立即返回，需配合 select/poll 等多路复用手段实现效率提升。 异步：调用类似 aio_read()/aio_write()，进程发起调用后立即返回，内核完成I/O操作后通过回调或事件通知告知进程，无需轮询，允许并行处理其他任务。 五种经典 I/O 模型 阻塞I/O模型 (BIO, Blocking I/O) 假设应用程序的进程发起I/O调用（read() 或 write()），但是如果内核的数据还没准备好的话，那应用程序进程就一直在阻塞等待，一直等到内核数据准备好了，从内核拷贝到用户空间，才返回成功提示，此次I/O操作，称之为阻塞I/O。\n阻塞I/O比较经典的应用就是阻塞socket、Java BIO。 阻塞I/O的缺点就是：如果内核数据一直没准备好，那用户进程将一直阻塞，浪费性能，可以使用非阻塞I/O优化。 非阻塞I/O模型 (NIO, Non-Blocking I/O) 在文件描述符上设置 O_NONBLOCK，使 read()/write() 调用立即返回，若无法立刻完成则返回 EAGAIN（对于套接字也可能是 EWOULDBLOCK），要求开发者主动轮询或结合多路复用进行事件驱动处理。\n成功完成：返回实际读写的字节数（0 表示 EOF） 无法立即完成（会阻塞）：返回 -1，errno == EAGAIN；若是套接字，也可能 errno == EWOULDBLOCK 其他错误：如 EBADF、EFAULT、EINTR 等，根据具体场景返回对应错误码 非阻塞I/O模型，简称NIO，Non-Blocking I/O。它相对于阻塞I/O，虽然大幅提升了性能，但是它依然存在性能问题，即频繁的轮询，导致频繁的系统调用，同样会消耗大量的CPU资源。可以考虑I/O复用模型，去解决这个问题。\n多路复用I/O模型 (MIO, Multiplexing I/O) 既然NIO无效的轮询会导致CPU资源消耗，我们等到内核数据准备好了，主动通知应用进程再去进行系统调用，那不就好了嘛？\nI/O复用模型核心思路：系统给我们提供一类函数（select、poll、epoll函数），在单个线程中监控大量文件描述符的可读写状态，实现阻塞或边缘触发的事件分发机制，从而避免因阻塞 I/O 导致的线程资源浪费。\n在 UNIX/Linux 中，文件描述符（FD，File Descriptor） 是内核为每个已打开资源（常见有普通文件、管道、套接字、字符设备等）分配的一个非负整数，它充当用户空间进程与内核 I/O 子系统之间的句柄。例如：\nFD = 0：标准输入（stdin） FD = 1：标准输出（stdout） FD ≥ 3：其他打开的文件或套接字 所有 I/O 系统调用（如 read(fd, buf, n)、write(fd, buf, n)）均通过这个整数索引来标识目标资源。\nselect 应用进程通过调用select函数，可以同时监控多个 fd，在 select函数监控的 fd 中，只要有任何一个数据状态准备就绪了，select 函数就会返回可读状态，这时应用进程再发起 recvfrom 请求去读取数据。\n非阻塞I/O模型（NIO）中，需要 N（N\u0026gt;=1）次轮询系统调用，然而借助 select 的I/O多路复用模型，只需要发起一次询问就够了，大大优化了性能。\n但是呢，select有几个缺点：\n监听的I/O最大连接数有限，在Linux系统上一般为1024。 select函数返回后，是通过遍历 fdset，找到就绪的描述符 fd。（仅知道有I/O事件发生，却不知是哪几个流，所以遍历所有流） 因为存在连接数限制，所以后来又提出了poll。与select相比，poll解决了连接数限制问题。但是呢，select和poll一样，还是需要通过遍历文件描述符来获取已经就绪的 socket。如果同时连接的大量客户端，在一时刻可能只有极少处于就绪状态，伴随着监视的描述符数量的增长，效率也会线性下降。\n因此经典的多路复用模型 epoll诞生。\nepoll 为了解决 select/poll存在的问题，多路复用模型 epoll诞生，它采用事件驱动来实现，流程图如下：\nepoll先通过 epoll_ctl() 来注册一个 fd，一旦基于某个 fd 就绪时，内核会采用回调机制，迅速激活这个 fd，当进程调用 epoll_wait()时便得到通知。这里去掉了遍历文件描述符的操作，而是采用监听事件回调的机制。这就是epoll的亮点。\nselect、poll、epoll的区别 select poll epoll 底层数据结构 数组 链表 红黑树和双链表 获取就绪的fd 遍历 遍历 事件回调 事件复杂度 O(n) O(n) O(1) 最大连接数 1024 无限制 无限制 fd数据拷贝 每次调用select，需要将fd数据从用户空间拷贝到内核空间 每次调用poll，需要将fd数据从用户空间拷贝到内核空间 使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间 epoll明显优化了I/O的执行效率，但在进程调用 epoll_wait()时，仍然可能被阻塞。\n信号驱动I/O模型 (SDIO, Signal-driven I/O) 信号驱动I/O不再用主动询问的方式去确认数据是否就绪，而是向内核发送一个信号（调用 sigaction 的时候建立一个 SIGIO 的信号），然后应用用户进程可以去做别的事，不用阻塞。当内核数据准备好后，再通过 SIGIO 信号通知应用进程，数据准备好后的可读状态。应用用户进程收到信号之后，立即调用 recvfrom，去读取数据。\n信号驱动I/O模型，在应用进程发出信号后，是立即返回的，不会阻塞进程。它已经有异步操作的感觉了。但是你细看上面的流程图，发现数据复制到应用缓冲的时候，应用进程还是阻塞的。回过头来看下，不管是BIO，还是NIO，还是信号驱动，在数据从内核复制到应用缓冲的时候，都是阻塞的。\n异步I/O模型 (AIO, Asynchronous I/O) 前面讲的 BIO，NIO和SDIO，在数据从内核复制到应用缓冲的时候，都是阻塞的，因此都不算是真正的异步。AIO实现了I/O全流程的非阻塞，就是应用进程发出系统调用后，是立即返回的，但是立即返回的不是处理结果，而是表示提交成功类似的意思。等内核数据准备好，将数据拷贝到用户进程缓冲区，发送信号通知用户进程I/O操作执行完毕。\n异步I/O的优化思路很简单，只需要向内核发送一次请求，就可以完成数据状态询问和数据拷贝的所有操作，并且不用阻塞等待结果。日常开发中，有类似思想的业务场景：\n比如发起一笔批量转账，但是批量转账处理比较耗时，这时候后端可以先告知前端转账提交成功，等到结果处理完，再通知前端结果即可。\nI/O 模型对比 模型 调用时阻塞？ 数据就绪时阻塞？ 特点 常见应用 阻塞 I/O（Blocking I/O） 是 — 最简单，单线程也能完成 Java BIO 非阻塞 I/O（Non-Blocking） 否 是 需轮询 EAGAIN C++ low-level 多路复用 I/O 否 否 单线程管理上万 FD，不轮询所有 FD Nginx、Node.js 信号驱动 I/O（SIGIO） 否 是 用信号通知，信号处理函数中读写 较少使用 异步 I/O（POSIX AIO） 否 否 真异步，全流程不阻塞 高性能文件服务 何时选哪种模型 简单脚本／小工具：阻塞 I/O 足矣。 多连接高并发：首选多路复用（epoll/kqueue）＋非阻塞。 极致性能：结合零拷贝（sendfile、splice）或 Linux io_uring。 跨平台服务：可借助 Java Netty、Rust Tokio、Go runtime 等，它们底层封装了最佳模型。 拓展 零拷贝技术：sendfile()、splice()、mmap() io_uring：Linux 5.1+ 提供的真正零系统调用异步接口 Windows IOCP：高性能 proactor 模型 虚拟化 I/O：Virtio、SR-IOV、DDIO 加速 ","date":"2024-05-31T11:20:31+08:00","image":"https://blog.yellster.top/p/io/io_hu_1dbf22adee97af80.png","permalink":"https://blog.yellster.top/p/io/","title":"I/O"},{"content":"SQL 注入是什么？ SQL 注入（SQL Injection）是一种攻击方式，攻击者通过“拼接用户输入”和数据库语句，让服务器执行恶意 SQL 命令，进而读取、修改、删除数据，甚至控制数据库主机。\nSQL 注入是怎么产生的？ 本质：用户输入参与了 SQL 拼接，且没有做安全处理。\n比如你写了这样的代码：\n1 SELECT * FROM users WHERE username = \u0026#39;admin\u0026#39; AND password = \u0026#39;123456\u0026#39;; 用户在登录框输入：\n用户名：admin' -- 密码：（随便填） 结果 SQL 变成了：\n1 SELECT * FROM users WHERE username = \u0026#39;admin\u0026#39; --\u0026#39; AND password = \u0026#39;xxx\u0026#39;; -- 是 SQL 中的注释符，后面的部分被忽略，攻击者绕过了密码验证，成功登录后台！\nSQL 注入能造成什么危害？ 危害类别 具体描述 登录绕过 修改 SQL 语句逻辑，无需密码直接登录账号 数据泄露 UNION SELECT 等方式读取敏感数据（账号、密码、银行卡） 数据篡改 执行 UPDATE、DELETE 操作，删库跑路 写入后门 某些情况下配合文件写入，写入 Webshell，反弹命令行 拓展攻击 通过数据库获取服务器权限，进一步横向移动攻击其他系统 如何防御 SQL 注入？（核心方法） 使用 预编译语句（Prepared Statement） 千万别直接拼接字符串！\n千万别直接拼接字符串！\n千万别直接拼接字符串！\n错误写法（易被注入）：\n1 sql = \u0026#34;SELECT * FROM users WHERE username = \u0026#39;\u0026#34; + user + \u0026#34;\u0026#39;\u0026#34; 正确写法（参数绑定，防注入）：\n1 cursor.execute(\u0026#34;SELECT * FROM users WHERE username = %s\u0026#34;, (user,)) 各种语言通用写法推荐使用：\n语言 推荐库 PHP PDO + bindParam Python cursor.execute(sql, param) Java PreparedStatement Node.js mysql.format()、ORM 输入校验 + 白名单限制 只允许合法字符（如用户名只能是字母、数字） 限制字段长度、格式（如手机号必须 11 位） 最小权限原则 数据库账号只给必要权限 不要用 root 账户连接数据库！ 错误信息不暴露 SQL 报错不能直接显示给用户（容易泄露表名、字段名） 使用统一的错误提示页面 使用 ORM 框架（但要小心） ORM（如 Django ORM、Hibernate）默认防注入，但：\n仍可能因原生 SQL 被误用而注入 ORM 的 extra() / raw() / execute() 等接口使用时要小心 WAF/IPS 网络层防御 使用 Web 应用防火墙拦截注入关键词 配合日志报警、验证码限制等方式增强防御深度 总结一句话 SQL 注入之所以可怕，是因为开发者信了用户的“输入”，数据库却把它当“命令”。\n","date":"2024-04-07T14:48:30+08:00","permalink":"https://blog.yellster.top/p/web-attack-sql-injection/","title":"Web攻击之 SQL注入"},{"content":"XSS 是什么？ XSS (Cross-Site Scripting) 是一种网站安全漏洞，其原理是放入恶意脚本，让用户的浏览器执行网站未筛查的 JS 脚本，导致数据被窃取、表单被作弊、页面被篡改等。\nXSS 不只是技术漏洞，更是信任的破坏者!\nXSS 看起来是弹个窗，实际上是把钥匙偷了、钱抽了、后面还跟你说是你自愿的。\nXSS 类型 反射型 XSS（Reflected XSS） 过程：攻击者构造一个恶意链接，把 \u0026lt;script\u0026gt; 放在 URL 里 → 受害者点击链接 → 服务端把参数原样“反射”回网页 → 浏览器执行脚本。 关键点：攻击代码不在服务端持久保存，靠“钓鱼链接”触发。 常见场景：搜索框、跳转链接、错误提示信息。 🧠 类比记忆：像“回音墙”，你说什么它就回什么。\n存储型 XSS（Stored XSS） 过程：攻击者提交脚本（比如发评论）→ 服务端保存到数据库 → 其他用户访问这条评论 → 浏览器执行脚本。 关键点：脚本 被存储下来，访问页面时自动触发，不需要特意点击链接。 常见场景：评论区、论坛帖子、个人资料页、客服聊天记录等。 🧠 类比记忆：像病毒藏在快递里，每个人收件就会感染。\nDOM 型 XSS（DOM-based XSS） 过程：浏览器 JS 读取 URL 参数、Hash、Cookie 等 → 动态写入页面（innerHTML、document.write） → 没有做转义 → 执行脚本。 关键点：完全不经过服务端，漏洞存在于前端 JS 的处理逻辑中。 常见场景：单页应用（SPA）、前端框架中常见。 🧠 类比记忆：像是浏览器自己给自己挖坑，自己跳进去。\n一个例子，三种写法对比 以攻击者想弹窗 alert(1) 为例：\n反射型：\n1 http://site.com/search?q=\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; 存储型：\n1 \u0026lt;input name=\u0026#34;comment\u0026#34; value=\u0026#34;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026#34;\u0026gt; 然后这个评论被存进数据库，别人一打开就触发。\nDOM 型（JS 代码）：\n1 2 3 // JS 代码直接取 URL 参数插到页面 document.getElementById(\u0026#39;output\u0026#39;).innerHTML = location.hash; // 访问： http://site.com/#\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; 核心区别 类型 恶意脚本位置 触发方式 是否存储 示例 反射型 XSS URL 参数中 点击恶意链接 ❌ 否 搜索“\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;” 存储型 XSS 数据库 / 日志 打开启用页面 ✅ 是 评论区中的 script DOM 型 XSS 前端 DOM 操作 JS 代码动态触发 ❌ 否 JS 把 location.hash 写入 HTML XSS 的害处 【对个人】 窃取 Cookie/会话凭证：偷取登录状态，偷取账号 伪造页面：伪认证/伪支付码 强制操作：切换场景合成 CSRF 推光性弹窗/跳转：骗屏/色情/转账 【对系统】 数据大量被偷取 网站内容被乱篡改 添加 iframe 或动态下载构成木马 【对业务】 用户信任层层坏坏 规范风险（如 GDPR、网安法） 被搜索引擎/安全网站拦截 防御 输出编码（最核心！） 原则：“信用户输入，死得很惨；编码输出，活得很稳。”\n根据输出位置做对应编码（不只是替换 \u0026lt; \u0026gt; 这么简单）：\n输出位置 编码方式 示例 HTML 元素内容 htmlEncode() \u0026lt;div\u0026gt;${userInput}\u0026lt;/div\u0026gt; HTML 属性值 attributeEncode() \u0026lt;a href=\u0026quot;${userInput}\u0026quot;\u0026gt; JS 中的变量 jsEncode() var msg = '${input}'; URL 中的参数 encodeURIComponent() location.href = ... ✍️ 记住一句话：不要原样输出用户输入，必须根据上下文编码！\n输入过滤（辅助防线） 虽然不能完全防止 XSS，但能大幅降低攻击难度。\n去除标签：如 \u0026lt;script\u0026gt;, \u0026lt;iframe\u0026gt; 等。 黑名单法有限，推荐使用白名单法：只允许部分 HTML 标签。 推荐库：DOMPurify（前端） / OWASP Java HTML Sanitizer（后端） HTTP 安全头部设置 Content-Security-Policy (CSP):\n定义允许加载的资源类型、域名，阻止恶意脚本执行。\n1 Content-Security-Policy: default-src \u0026#39;self\u0026#39;; script-src \u0026#39;self\u0026#39; 作用：\n禁止内联 \u0026lt;script\u0026gt; 执行 阻止第三方 JS 加载 检测异常行为 HttpOnly + Secure Cookie 设置 Cookie 为 HttpOnly:\n防止 JS 读取 Cookie（攻击者窃取失败）。\n1 Set-Cookie: session=xxx; HttpOnly; Secure 前端框架防护机制（但别完全依赖） Vue、React 等默认会对数据做 HTML 转义 但要注意： v-html（Vue）/ dangerouslySetInnerHTML（React） 这些接口绕过了防护！ 千万不要对用户数据使用这些 API！ 其他补充措施 表单提交加验证码：减缓自动化脚本攻击 日志记录 + 异常监控：配合 WAF 实时监控异常行为 使用 Web 安全网关 / 云 WAF：防护基础设施级别的 XSS 尝试 一句话总结 XSS 防不住的根本原因，不是框架不行，是开发者在瞎传字符串。\n所以防御的关键在于：凡是用户输入的，都不要相信；凡是输出前的，都要处理。\n","date":"2024-04-01T14:48:30+08:00","permalink":"https://blog.yellster.top/p/web-attack-xss/","title":"Web攻击之 XSS"},{"content":"代理模式 代理模式（Proxy Pattern） 是一种结构型设计模式，通过为其他对象提供一种代理以控制对这个对象的访问。\n​它通常用于在不修改原始对象的情况下，增加对对象的控制和扩展功能，例如访问控制、延迟加载、日志记录等。​\n静态代理 定义: 在编译时，代理类已经存在，代理对象和被代理对象之间是一对一的关系。 实现方式: 手动创建代理类，实现与被代理类相同的接口，在代理类中持有被代理类的实例，通过调用被代理类的方法来实现代理功能。 优点: 代码简单，易于理解。 缺点: 每增加一个被代理类，都需要创建一个对应的代理类，代码重复度高，维护困难。 动态代理 定义: 在运行时动态生成代理类，无需在编译时预先定义代理类。 实现方式: JDK 动态代理: 利用 Java 的反射机制，在运行时生成实现了指定接口的代理对象。要求被代理类必须实现接口。 CGLIB 动态代理: 通过继承目标类，生成目标类的子类来实现代理。适用于没有实现接口的类，但无法代理 final 类和方法。 优点: 提高了代码的灵活性和复用性，减少了代理类的数量。 缺点: 相对于静态代理，性能开销略大，因为涉及到反射和动态生成类。 很多场景都是利用类似机制做到的，比如用来包装 RPC 调用、面向切面的编程（AOP）。\n通过代理可以让调用者与实现者之间解耦。比如进行 RPC 调用，框架内部的寻址、序列化、反序列化等，对于调用者往往是没有太大意义的。\nJDK 动态代理 JDK 动态代理基于 Java 的反射机制，代理对象需要 实现至少一个接口，代理类在运行时动态生成要求。\n代理对象由 Proxy.newProxyInstance() 动态生成，其实现了 HelloService 接口。 在 InvocationHandler 中对方法调用进行了拦截，可在调用前后加入额外处理逻辑。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 // HelloService.java public interface HelloService { void sayHello(String name); } // HelloServiceImpl.java public class HelloServiceImpl implements HelloService { @Override public void sayHello(String name) { System.out.println(\u0026#34;Hello, \u0026#34; + name); } } // DynamicProxyDemo.java import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class DynamicProxyDemo { public static void main(String[] args) { // 创建原始对象 HelloService original = new HelloServiceImpl(); // 利用 Proxy.newProxyInstance 创建代理对象 HelloService proxyInstance = (HelloService) Proxy.newProxyInstance( original.getClass().getClassLoader(), new Class[]{HelloService.class}, new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(\u0026#34;Before method: \u0026#34; + method.getName()); Object result = method.invoke(original, args); System.out.println(\u0026#34;After method: \u0026#34; + method.getName()); return result; } } ); // 调用代理对象的方法 proxyInstance.sayHello(\u0026#34;World\u0026#34;); } } CGLIB 动态代理 当目标类没有实现接口时，可以使用 CGLIB 动态代理，基于 ASM 字节码操作框架，通过继承目标类生成代理类。 需要添加 CGLIB 的依赖。\n因为是子类化，我们可以达到近似使用被调用者本身的效果。在 Spring 编程中，框架通常会处理这种情况。\nEnhancer 用于生成目标类（这里是 Person 类）的子类。 在 MethodInterceptor 的 intercept 方法中可以对方法调用进行拦截，添加前置或后置逻辑。 1 2 3 4 5 6 \u0026lt;!-- pom.xml --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;cglib\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;cglib\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // CGLIBProxyDemo.java import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class CGLIBProxyDemo { public static class Person { public void sayHello(String name) { System.out.println(\u0026#34;Hello, \u0026#34; + name); } } public static void main(String[] args) { Enhancer enhancer = new Enhancer(); // 指定需要代理的目标类 enhancer.setSuperclass(Person.class); // 设置方法拦截器 enhancer.setCallback(new MethodInterceptor() { @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { System.out.println(\u0026#34;Before method: \u0026#34; + method.getName()); Object result = proxy.invokeSuper(obj, args); System.out.println(\u0026#34;After method: \u0026#34; + method.getName()); return result; } }); // 创建代理对象 Person proxy = (Person) enhancer.create(); proxy.sayHello(\u0026#34;World\u0026#34;); } } CGLIB 注意事项 自 JDK 9 引入 模块化系统（JPMS） 以来，对 CGLIB 的使用受到了一定限制。\n​CGLIB 通过生成目标类的子类来实现代理，这需要在运行时访问目标类的构造方法和方法。\n​然而，JDK 9 的模块系统对反射访问进行了严格控制，默认情况下，模块之间的访问是受限的。因此，CGLIB 在尝试通过反射访问 ClassLoader.defineClass 时会抛出 InaccessibleObjectException。\n解决办法: 可以在启动应用时添加 JVM 参数，显式打开需要的模块包，以允许 CGLIB 进行反射访问。\n1 --add-opens java.base/java.lang=ALL-UNNAMED 该参数的作用是将 java.base 模块中的 java.lang 包对所有未命名模块（即没有显式声明模块的代码）开放，从而允许反射访问。\nJDK 动态代理 VS CGLIB 动态代理 JDK 动态代理\n优点 简洁易用：利用 Java 内置的反射机制，无需引入第三方依赖 接口驱动：代理类必须实现接口，符合面向接口编程的设计原则 缺点 只能代理接口：无法对没有实现接口的类进行代理 性能开销：通过反射实现，性能较低 CGLIB 动态代理\n优点 无需接口：可以代理没有实现接口的类 性能较高：生成的代理类方法调用性能优于 JDK动态代理 缺点 类限制：无法代理被 final 修饰的类和方法，因为 CGLIB 通过继承实现代理 引入依赖：需要引入 CGLIB 的依赖 在实际应用中，框架如 Spring 会根据目标对象的情况，选择使用 JDK 动态代理或 CGLIB 动态代理，以实现 AOP 功能。​\n与装饰器模式的区别？ 代理模式和装饰器模式在结构上可能相似，但它们在目的、关注点和使用方式上有显著区别。\n1. 目的:\n代理模式（Proxy Pattern）: 主要目的是控制对目标对象的访问。代理对象通常用于在客户端和真实对象之间提供一个中介，控制对真实对象的访问权限或添加额外的操作，例如延迟加载、安全检查或远程调用等。 装饰器模式（Decorator Pattern）: 主要目的是动态地增强对象的功能。通过将原始对象包装在装饰器中，可以在不修改原始类的情况下，添加新的行为或功能。 2. 关注点:\n代理模式: 关注于对对象访问的控制和管理，强调如何代理和控制对真实对象的操作。 装饰器模式: 关注于对对象功能的扩展和增强，强调如何在运行时添加新的功能或行为。 3. 使用方式:\n代理模式: 代理类通常在编译时就确定，与真实对象实现相同的接口，并持有对真实对象的引用。在客户端通过代理对象访问真实对象，代理对象可以在调用真实对象的方法前后添加额外的操作。 装饰器模式: 装饰器类也实现与被装饰对象相同的接口，但通常在运行时动态创建，并将被装饰对象作为构造参数传入。装饰器对象通过组合的方式，将增强功能添加到被装饰对象上。 示例:\n代理模式: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public interface Subject { void request(); } public class RealSubject implements Subject { public void request() { System.out.println(\u0026#34;RealSubject request\u0026#34;); } } public class ProxySubject implements Subject { private RealSubject realSubject; public ProxySubject() { this.realSubject = new RealSubject(); } public void request() { // 代理操作，例如访问控制 System.out.println(\u0026#34;ProxySubject request\u0026#34;); realSubject.request(); } } 装饰器模式: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public interface Subject { void request(); } public class RealSubject implements Subject { public void request() { System.out.println(\u0026#34;RealSubject request\u0026#34;); } } public class DecoratorSubject implements Subject { private Subject subject; public DecoratorSubject(Subject subject) { this.subject = subject; } public void request() { // 装饰操作，例如功能增强 System.out.println(\u0026#34;DecoratorSubject request\u0026#34;); subject.request(); } } 总结而言，代理模式侧重于控制对对象的访问，而装饰器模式侧重于增强对象的功能。代理对象通常用于控制对真实对象的访问权限，而装饰器对象用于在运行时动态地添加新的功能或行为。\n","date":"2024-03-27T17:24:03+08:00","permalink":"https://blog.yellster.top/p/java-dynamic-proxy/","title":"动态代理？"},{"content":"反射（Reflection） 是Java语言的一个特性，它允许程序在 运行时(runtime) 动态分析、检查和修改类、对象、方法、字段等的能力。它突破了传统代码的静态限制，允许程序在运行期间 自省（introspect） 和 动态操作。\n核心思想: 将类的结构（方法、字段、构造函数等）映射为Java对象，通过API直接操作。\n类对象是何时产生的？: 在类加载时产生的。在Java程序启动时，JVM会加载所需的类，并为每个类创建一个Class对象，这个对象包含了该类的所有结构信息，可以通过反射机制获取。\n反射机制 是Java被视为动态语言的关键特性之一。\n自省（Introspection） 指的是程序在运行时检查自身类型信息的能力\n核心原理 Java反射的核心原理基于JVM的类加载机制和Java的类型系统:\n类加载机制: 当Java程序运行时，JVM会加载所需的类，并为每个类创建一个Class对象，这个对象包含了该类的所有结构信息。 Class对象: 每个类在JVM中都有且只有一个对应的Class对象，这个对象是反射的入口点。 运行时类型信息(RTTI): Java在运行时保留了对象的类型信息，这使得反射成为可能。 核心API Java反射的核心类位于 java.lang.reflect 包中，关键API包括:\n类/接口 作用 java.lang.Class 表示一个类或接口的特性，如名称、字段、方法等 java.lang.reflect.Field 提供了类或接口的单个字段的信息和动态访问 java.lang.reflect.Method 提供了类或接口上单个方法的信息和访问权限 java.lang.reflect.Constructor 提供了类的单个构造函数的信息和访问权限 java.lang.reflect.Array 提供了动态创建和访问 Java 数组的静态方法 java.lang.reflect.Modifier 提供了静态方法和常量，用于解码类和成员访问修改器 典型场景 框架开发 Spring的依赖注入（IoC）、MyBatis的ORM映射。 动态代理 结合InvocationHandler实现AOP（如日志、事务）。 序列化与反序列化 如Jackson/GSON通过反射读取字段生成JSON。 IDE和调试工具 代码自动提示、对象属性查看。 测试框架 JUnit通过反射调用测试方法。 核心操作步骤 获取类的Class对象 1 2 3 4 5 6 7 8 9 10 11 12 13 // 方式1: 通过类名.class Class\u0026lt;?\u0026gt; clazz = String.class; // 方式2: 通过对象.getClass() String str = \u0026#34;Hello\u0026#34;; Class\u0026lt;?\u0026gt; clazz = str.getClass(); // 方式3: 通过Class.forName()（最常用） Class\u0026lt;?\u0026gt; clazz = Class.forName(\u0026#34;java.lang.String\u0026#34;); // 方式4: 调用类的加载器 ClassLoader cl = this.getClass().getClassLoader(); Class\u0026lt;?\u0026gt; clazz = cl.loadClass(\u0026#34;java.lang.String\u0026#34;); 操作构造函数: 动态创建对象 1 2 3 4 5 6 7 // 获取无参构造器并创建对象 Constructor\u0026lt;?\u0026gt; constructor = clazz.getConstructor(); Object instance = constructor.newInstance(); // 获取有参构造器（例如: String的byte[]构造器） Constructor\u0026lt;?\u0026gt; constructor = clazz.getConstructor(byte[].class); Object instance = constructor.newInstance(new byte[]{65, 66}); getXXX() 和 getDeclaredXXX() 的区别 方法 访问范围 是否包含私有成员 是否包含继承成员 getXXX() 仅返回 public 成员 ❌ 不包含 ✅ 包含父类的 public 成员 getDeclaredXXX() 返回 所有权限 的成员（public/protected/private/default） ✅ 包含 ❌ 仅限当前类 getXXX() 和 getDeclaredXXX() 的使用场景对比 场景 推荐方法 获取公共 API（如框架调用） getXXX() 访问私有成员（如测试、破解单例） getDeclaredXXX() + setAccessible(true) 需要继承的成员 getXXX() 仅操作当前类成员 getDeclaredXXX() 注意事项 继承关系：\ngetXXX() 会查找父类的 public 成员。 getDeclaredXXX() 仅限当前类，不检查父类。 访问私有成员：\n通过 getDeclaredXXX() 获取私有成员后，需调用 setAccessible(true) 解除访问限制。 性能影响：\n反射操作比直接调用慢，必要时可缓存 Method/Field 对象。 模块化系统（Java 9+）：\n如果类在模块中，需在 module-info.java 中开放权限（opens）才能反射访问非 public 成员。 操作方法: 动态调用 1 2 3 4 5 // 获取方法（例如: String的substring方法） Method method = clazz.getMethod(\u0026#34;substring\u0026#34;, int.class, int.class); // 调用方法（对某个实例执行） Object result = method.invoke(\u0026#34;Reflection\u0026#34;, 2, 5); // 输出 \u0026#34;fle\u0026#34; Method.invoke() 的返回值规则 result 的可能情况：\n被调用方法的返回类型 invoke() 返回的 result 类型 示例 有返回值的方法 返回 Object（实际为方法返回值） String.substring() → String 返回 void 的方法 返回 null List.clear() → null 基本类型（如 int） 自动装箱为包装类（如 Integer） String.length() → Integer 静态方法 正常返回（obj 参数传 null） Math.max() → Integer 方法抛出异常 封装成 InvocationTargetException - 为什么返回 Object 而不是具体类型？ 反射的通用性：Method.invoke() 需要适配任意方法签名，Object 是所有类型的超类。 类型安全：由开发者自行处理强制转型（编译器无法检查反射调用的返回类型）。 操作字段: 动态读写属性 1 2 3 4 5 6 7 8 9 // 获取字段（例如: Integer的MAX_VALUE） Field field = Integer.class.getDeclaredField(\u0026#34;MAX_VALUE\u0026#34;); // 读取字段值（静态字段可传null） int max = (int) field.get(null); // 输出2147483647 // 修改字段值（需注意final字段可能抛出异常） field.setAccessible(true); // 突破private限制（慎用！） field.set(null, 100); // 危险操作！可能破坏程序逻辑。 优缺点 优点 动态性: 允许在运行时动态地获取和操作类的信息，而不需要在编译时知道类的具体细节 灵活性: 可以通过类名字符串来创建对象实例，可以在运行时动态调用方法和字段，以及访问和修改私有成员 扩展性: 可以用于实现一些高级功能，如动态代理、注解处理、依赖注入等 缺点 性能开销: 反射操作通常比直接调用慢，因为它需要在运行时获取和操作类的信息，需要额外的处理开销 安全问题: 反射可以访问和修改私有成员，这可能导致安全隐患和程序逻辑错误 复杂性: 使用反射可能会使代码变得复杂和难以理解，增加了维护成本 为什么会慢？ 动态类型解析: 反射需要在运行时解析类和方法的信息，这使得编译器无法对这些代码进行优化。相比之下，直接调用方法或构造函数可以在编译时进行静态绑定和优化。 方法查找和验证: 通过反射调用方法时，Java 需要查找方法并进行可见性检查，这增加了额外的开销。 安全性检查: 反射允许访问和修改私有字段和方法，JVM 为了保证安全性，需要在反射操作时进行额外的检查，增加了性能开销。 JIT 编译优化限制: 由于反射操作的动态性，JIT 编译器无法对其进行内联等优化，导致性能低于直接调用。 ","date":"2024-03-26T17:24:03+08:00","permalink":"https://blog.yellster.top/p/java-reflection/","title":"反射？"},{"content":"对比 特性 String StringBuffer StringBuilder 可变性 不可变 可变 可变 线程安全 是（天然不可变） 是（synchronized方法） 否 性能 低（频繁创建对象） 中 高 内存分配 每次修改产生新对象 动态数组 动态数组 初始化容量 不可设置 默认16，可自定义 默认16，可自定义 JDK版本 1.0 1.0 1.5 使用场景 常量字符串、配置信息 多线程环境字符串操作 单线程环境字符串操作 实现分析 Java字符串体系结构\n1 2 3 4 5 6 7 8 9 10 11 12 13 ┌───────────┐ ┌───────────────────────┐ │ String │ │ AbstractStringBuilder │ │-----------│ │-----------------------│ │ - value[] │\u0026lt;──────\u0026gt;│ + value[] │ │ - hash │ │ + count │ └────┬──────┘ └──────┬────────────────┘ │ │ ▼ ▼ ┌───────────────┐ ┌─────────────────┐ │ StringBuffer │ │ StringBuilder │ │---------------│ │-----------------│ │ + sync methods│ │ - non-sync │ └───────────────┘ └─────────────────┘ String 1 2 3 4 5 6 7 8 9 10 11 public final class String implements java.io.Serializable, Comparable\u0026lt;String\u0026gt;, CharSequence { /** 实际存储数据的不可变数组 */ // jdk9 之前 private final char value[]; // jdk9 之后 private final byte[] value; /** 字符串的哈希码缓存 */ private int hash; // Default to 0 } 不可变性：value数组被声明为final，任何修改都会创建新对象 内存优化：从JDK9开始改用byte[]存储，支持LATIN1/UTF-16编码 常量池：字符串字面量自动加入常量池，减少重复创建 StringBuffer \u0026amp; StringBuilder 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 abstract class AbstractStringBuilder { /** 动态数组存储字符数据 */ byte[] value; /** 当前已使用的字符数 */ int count; } public final class StringBuffer extends AbstractStringBuilder implements Serializable, CharSequence { // 所有方法添加synchronized关键字 @Override public synchronized StringBuffer append(String str) { super.append(str); return this; } } public final class StringBuilder extends AbstractStringBuilder implements Serializable, CharSequence { // 非线程安全实现 @Override public StringBuilder append(String str) { super.append(str); return this; } } 动态扩容：初始容量16（字符数） 线程安全：StringBuffer通过方法级同步保证线程安全（synchronized 关键字修饰） 继承抽象类：StringBuffer和StringBuilder都继承了AbstractStringBuilder 扩容分析，基于jdk17 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // 公开的容量确认方法 public void ensureCapacity(int minimumCapacity) { if (minimumCapacity \u0026gt; 0) { // 过滤无效参数 ensureCapacityInternal(minimumCapacity); // 调用内部扩容逻辑 } } // 内部扩容实现 private void ensureCapacityInternal(int minimumCapacity) { // 计算当前字符容量（字节长度 \u0026gt;\u0026gt; 编码位数） int oldCapacity = value.length \u0026gt;\u0026gt; coder; // 需要扩容的条件判断 if (minimumCapacity - oldCapacity \u0026gt; 0) { // 创建新数组并复制数据 value = Arrays.copyOf(value, newCapacity(minimumCapacity) \u0026lt;\u0026lt; coder); } } // 新容量计算逻辑 private int newCapacity(int minCapacity) { // 当前数组的字节长度 int oldLength = value.length; // 计算所需的最小字节长度（字符数 \u0026lt;\u0026lt; 编码位数） int newLength = minCapacity \u0026lt;\u0026lt; coder; // 需要扩展的字节数 int growth = newLength - oldLength; // 动态计算新容量（核心扩容算法） int length = ArraysSupport.newLength(oldLength, growth, oldLength + (2 \u0026lt;\u0026lt; coder)); // 默认扩展量 // 处理最大容量限制 if (length == Integer.MAX_VALUE) { throw new OutOfMemoryError(...); } // 返回字符容量（字节长度 \u0026gt;\u0026gt; 编码位数） return length \u0026gt;\u0026gt; coder; } 编码处理（coder字段）：\ncoder取值0（LATIN1）或1（UTF16BE）\n位移操作实现字节与字符转换：\n1 2 3 4 5 // 字节长度 → 字符容量 int characters = bytesLength \u0026gt;\u0026gt; coder; // 字符容量 → 字节长度 int bytes = characters \u0026lt;\u0026lt; coder; 扩容策略：\n1 2 3 4 5 6 7 ArraysSupport.newLength( int oldLength, // 当前数组长度（字节） int minGrowth, // 至少需要增长的量 int prefGrowth // 推荐增长量 ) int length = ArraysSupport.newLength(oldLength, growth, oldLength + (2 \u0026lt;\u0026lt; coder)); 实际扩容公式：新长度 = oldLength + max(minGrowth, prefGrowth) 默认扩展量计算：prefGrowth = oldLength + (2 \u0026lt;\u0026lt; coder) LATIN1编码时：+2字节（即扩容2字符） UTF16编码时：+4字节（即扩容2字符） 动态扩容流程：\n1 2 3 4 5 原始数组 → 计算最小需求 → ┌─满足需求 → 直接返回 └─需要扩容 → 计算新容量 → ├─超过限制 → 抛出OOM └─创建新数组 → 数据复制 性能优化点：\n延迟计算：只在需要扩容时进行计算 按需扩容：根据实际增长需求动态调整 位运算优化：使用位移代替乘除运算 扩容示例 假设原始状态：\n编码方式：UTF16（coder=1） 当前内容：\u0026ldquo;Hello\u0026rdquo;（5字符） 当前数组：char[16]（初始容量16字符） 执行append(\u0026ldquo;World!\u0026quot;)后：\n需要总字符数：5 + 6 = 11 当前容量16足够，无需扩容 继续追加数据直到需要17字符：\n计算最小字节需求：17 \u0026lt;\u0026lt; 1 = 34字节 当前数组长度：16 \u0026lt;\u0026lt; 1 = 32字节 计算growth = 34 - 32 = 2字节 计算prefGrowth：32 + (2 \u0026lt;\u0026lt; 1) = 36 新长度 = 32 + max(2, 36-32) = 32 + 4 = 36字节 新字符容量：36 \u0026gt;\u0026gt; 1 = 18字符 最终完成从16到18字符的扩容，实际扩容量是原始容量的1.125倍，而非传统的双倍扩容。\n性能测试 测试场景 10万次字符串追加操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 public class PerformanceTest { static final int LOOP_COUNT = 100_000; public static void main(String[] args) { // String测试 long start1 = System.nanoTime(); String s = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; LOOP_COUNT; i++) { s += \u0026#34;a\u0026#34;; } long duration1 = (System.nanoTime() - start1) / 1_000_000; // StringBuffer测试 long start2 = System.nanoTime(); StringBuffer sbuf = new StringBuffer(); for (int i = 0; i \u0026lt; LOOP_COUNT; i++) { sbuf.append(\u0026#34;a\u0026#34;); } long duration2 = (System.nanoTime() - start2) / 1_000_000; // StringBuilder测试 long start3 = System.nanoTime(); StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; LOOP_COUNT; i++) { sb.append(\u0026#34;a\u0026#34;); } long duration3 = (System.nanoTime() - start3) / 1_000_000; System.out.printf(\u0026#34;String: %dms%n\u0026#34;, duration1); System.out.printf(\u0026#34;StringBuffer: %dms%n\u0026#34;, duration2); System.out.printf(\u0026#34;StringBuilder: %dms%n\u0026#34;, duration3); } } 测试结果 JDK17，Mac M1\n实现方式 耗时（ms） 内存分配（MB） String 4236 218 StringBuffer 12 0.5 StringBuilder 8 0.3 最佳实践 选择策略 优先使用String：\n存储常量配置信息 作为方法参数传递 需要作为Map的Key使用时 使用StringBuilder：\n单线程环境下字符串拼接 SQL语句动态构建 日志消息组装 使用StringBuffer：\n多线程共享的字符串操作 全局日志缓冲区 需要同步修改的共享资源 性能优化技巧 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // 预分配容量（减少扩容次数） StringBuilder sb = new StringBuilder(1024); // 链式调用优化 String result = new StringBuilder() .append(\u0026#34;Name: \u0026#34;).append(user.getName()) .append(\u0026#34;, Age: \u0026#34;).append(user.getAge()) .toString(); // 避免在循环中使用字符串拼接 // 错误示例： String output = \u0026#34;\u0026#34;; for (Data data : list) { output += data.getValue(); // 产生大量临时对象 } // 正确示例： StringBuilder output = new StringBuilder(); for (Data data : list) { output.append(data.getValue()); } 特殊场景处理 多线程安全操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 使用StringBuffer的同步控制 class SharedResource { private StringBuffer buffer = new StringBuffer(); public void safeAppend(String str) { synchronized(buffer) { buffer.append(str); } } } // 或使用ThreadLocal private ThreadLocal\u0026lt;StringBuilder\u0026gt; localBuilder = ThreadLocal.withInitial(() -\u0026gt; new StringBuilder(256)); 常见误区 误区1：StringBuilder一定比StringBuffer快 真相：在单线程环境下确实如此，但差异通常在微秒级。实际开发中更应关注代码可读性 误区2：StringBuffer可以完全替代StringBuilder 线程开销：StringBuffer的同步锁在竞争激烈时会导致性能骤降 对象复用：StringBuffer实例作为类成员时可能被错误共享 进阶 JDK8优化改进 在 Java 8 之后，编译器对 String 常量拼接进行了优化，主要是通过 字符串常量池 和 StringBuilder 进行优化。\n常量折叠（Constant Folding）：\n编译器会在编译时将 String 的常量拼接计算出结果。这意味着在代码编译时，所有的常量字符串拼接都会被直接合并为一个常量字符串。 这种优化可以减少运行时的计算，因为常量拼接的结果已经在编译时得到了处理。 1 2 3 4 5 6 public class StringConcatenation { public static void main(String[] args) { String result = \u0026#34;Hello\u0026#34; + \u0026#34; \u0026#34; + \u0026#34;World\u0026#34;; // 这是常量拼接 System.out.println(result); } } 编译器会直接把 \u0026quot;Hello\u0026quot; + \u0026quot; \u0026quot; + \u0026quot;World\u0026quot; 计算为 \u0026quot;Hello World\u0026quot;，因此代码最终会变成：\n1 2 3 4 5 6 public class StringConcatenation { public static void main(String[] args) { String result = \u0026#34;Hello World\u0026#34;; System.out.println(result); } } 字符串拼接使用 StringBuilder：\n对于运行时的拼接，编译器会自动使用 StringBuilder 来优化多个字符串的拼接操作，避免了重复创建临时 String 对象。 1 2 3 4 5 6 7 8 public class StringConcatenation { public static void main(String[] args) { String a = \u0026#34;Hello\u0026#34;; String b = \u0026#34;World\u0026#34;; String result = a + \u0026#34; \u0026#34; + b; // 运行时拼接 System.out.println(result); } } 编译器会优化为使用 StringBuilder，最终生成的字节码类似于：\n1 2 3 4 5 6 7 8 public class StringConcatenation { public static void main(String[] args) { String a = \u0026#34;Hello\u0026#34;; String b = \u0026#34;World\u0026#34;; String result = new StringBuilder().append(a).append(\u0026#34; \u0026#34;).append(b).toString(); System.out.println(result); } } JDK9优化改进 紧凑字符串：根据内容自动选择Latin-1或UTF-16编码 字符串去重：G1垃圾收集器的字符串去重功能（-XX:+UseStringDeduplication） 内存泄漏防范 1 2 3 4 5 6 7 8 9 10 // 大字符串处理示例 void processHugeData() { String hugeString = readHugeFile(); // 1MB字符串 // 错误用法：截取小部分但保留大数组 String subStr = hugeString.substring(0,10); // 正确做法：显式创建新字符串 subStr = new String(hugeString.substring(0,10)); } 字符串池机制 1 2 3 4 5 6 String s1 = \u0026#34;java\u0026#34;; String s2 = \u0026#34;java\u0026#34;; String s3 = new String(\u0026#34;java\u0026#34;); System.out.println(s1 == s2); // true（常量池引用） System.out.println(s1 == s3); // false（堆中新对象） 总结 基础原则：\n优先考虑不可变性 → String 单线程可变需求 → StringBuilder 多线程可变需求 → StringBuffer 性能关键点：\n避免不必要的字符串对象创建 预估容量减少扩容次数 警惕大字符串的内存驻留 发展趋势：\nValhalla项目的值类型（inline class）可能带来新的字符串实现 GraalVM的字符串优化策略 Project Loom对字符串操作的影响 通过合理选择字符串处理类，开发者可以在保证代码质量的同时，显著提升应用程序的性能表现。建议在关键路径代码中结合性能分析工具（如Async Profiler）进行针对性优化。\n","date":"2024-03-25T14:36:56+08:00","permalink":"https://blog.yellster.top/p/string-stringbuffer-stringbuilder/","title":"String \u0026 StringBuffer \u0026 StringBuilder"},{"content":"在 Java 中，final 关键字是一个修饰符，用于定义变量、方法或类的不可变性或不可继承性。\n它的核心作用是限制修改或继承，从而增强代码的安全性、可读性和设计约束。\n作用范围 修饰变量 局部变量：必须在声明时或使用前赋值一次，之后不可修改。\n1 2 final int x = 10; // x = 20; // 编译错误：无法修改 final 变量 成员变量：必须在声明时、构造方法或初始化块中赋值一次。\n1 2 3 4 5 6 7 8 class MyClass { final int MAX_VALUE; // 非静态 final 变量 final static int MIN_VALUE = 0; // 静态 final 常量 public MyClass() { MAX_VALUE = 100; // 在构造方法中赋值 } } 引用类型变量\nfinal 修饰的是引用，而非对象本身。引用不可变，但对象内部状态可能可变。\n1 2 3 final List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Java\u0026#34;); // 允许修改对象内容 // list = new ArrayList\u0026lt;\u0026gt;(); // 编译错误：引用不可变 修饰方法 方法不可被重写：子类无法覆盖父类的 final 方法。\n1 2 3 4 5 6 7 8 9 10 class Parent { public final void print() { System.out.println(\u0026#34;Parent\u0026#34;); } } class Child extends Parent { // @Override // 编译错误：无法重写 final 方法 // public void print() { ... } } 设计意图：\n防止关键方法（如算法逻辑、安全校验）被子类意外修改。 修饰类 类不可被继承：\n1 2 3 4 final class StringUtils { // 工具类通常设计为 final // 工具方法... } // class ExtendedUtils extends StringUtils { } // 编译错误 设计意图：\n防止继承破坏类的内部逻辑（如 String、Integer 等不可变类）。 强制使用组合而非继承（如工具类）。 设计意义 安全性 常量定义：通过 final 变量定义全局常量（如配置参数），防止意外修改。 不可变对象：结合私有字段和 final 修饰符，实现线程安全的不可变对象。 1 2 3 4 5 6 7 8 9 10 public final class ImmutablePoint { private final int x; private final int y; public ImmutablePoint(int x, int y) { this.x = x; this.y = y; } // 只有 getter，没有 setter } 性能优化 编译优化：final 常量在编译时可能被直接替换为字面量（类似宏）。 JVM 优化：final 方法可能被内联（Inline）以提高执行效率。 设计约束 强制规范：通过 final 限制扩展或修改，明确类的职责（如工具类）。 防止破坏性继承：避免子类覆盖方法导致父类逻辑失效。 注意事项 引用类型变量 final 只能保证引用不变，但对象内部状态可能被修改（除非对象本身不可变）。\n1 2 final int[] arr = {1, 2, 3}; arr[0] = 100; // 允许修改数组内容 final 与不可变对象 final 是实现不可变对象的必要条件，但非充分条件。需结合以下条件：\n所有字段用 final 修饰。 字段为基本类型或不可变对象。 不对外暴露修改内部状态的方法（如 setter）。 final 参数 方法参数可以声明为 final，防止在方法内被意外修改（增强可读性）。\n1 2 3 public void process(final String input) { // input = \u0026#34;new value\u0026#34;; // 编译错误 } 强制约束机制 对变量的强制约束 编译阶段检查: 编译器会严格检查 final 变量的赋值次数。以下代码会直接编译失败：\n1 2 3 final int x; x = 10; x = 20; // 编译错误：Variable \u0026#39;x\u0026#39; might already have been assigned 运行时不可修改: 即使通过字节码操作（如直接修改 .class 文件），试图改变 final 变量的值也会导致 IllegalAccessError。\n（注：常规开发中无法绕过此限制。）\n对方法的强制约束 子类重写直接报错： 如果子类尝试重写父类的 final 方法，编译器会直接拒绝：\n1 2 3 4 5 6 7 8 class Parent { public final void doSomething() {} } class Child extends Parent { @Override // 编译错误：Cannot override the final method public void doSomething() {} } 对类的强制约束 禁止继承的编译检查： 任何尝试继承 final 类的行为都会导致编译错误\n1 2 final class UtilityClass {} class SubClass extends UtilityClass {} // 编译错误：Cannot inherit from final class 边界场景 反射修改 final 字段 理论上的可能性： 通过反射 API（如 Field.setAccessible(true)），可以修改 final 字段的值。\n1 2 3 4 5 6 7 8 9 10 11 class MyClass { final int value = 10; } public static void main(String[] args) throws Exception { MyClass obj = new MyClass(); Field field = MyClass.class.getDeclaredField(\u0026#34;value\u0026#34;); field.setAccessible(true); field.setInt(obj, 20); // 修改 final 字段的值 System.out.println(obj.value); // 输出 20（旧版本 Java 可能允许，新版默认禁止） } 实际限制：\n从 Java 12 开始，默认禁止通过反射修改 final 字段，会抛出 IllegalAccessException。 可通过 JVM 参数 \u0026ndash;add-opens java.base/java.lang=ALL-UNNAMED 绕过，但这属于破坏性操作，违背语言设计原则。 引用类型变量的内部可变性 final 仅约束引用，不约束对象内容：\n1 2 3 final List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); list.add(\u0026#34;Java\u0026#34;); // 合法操作：修改对象内部状态 // list = new ArrayList\u0026lt;\u0026gt;(); // 非法操作：修改引用 此时 final 强制的是引用不可变，但对象本身可能仍可变（除非对象自身设计为不可变，如 String）。\nfinal 是强制的？ 语言规范定义 Java 语言规范明确要求 final 的约束必须被遵守，否则代码无法通过编译（JLS §4.12.4）。\n编译器和运行时的双重保障 编译器：静态检查语法合法性。 JVM：运行时内存模型保证 final 字段的初始化安全（如 final 字段的写入对其他线程可见）。 设计哲学 final 的强制性是为了保障代码的可靠性和一致性。例如：\n不可变对象（String）依赖 final 的强制约束。 工具类（如 Math）通过 final 类禁止继承，确保方法逻辑不被篡改。 ","date":"2024-03-21T16:58:52+08:00","permalink":"https://blog.yellster.top/p/java-final/","title":"如何理解 Final 关键字？"},{"content":"什么是 Spring IoC? Spring IoC（Inversion of Control，控制反转）是 Spring 框架的核心机制，其核心思想是将对象的创建、依赖管理和生命周期交给容器统一控制，而非由开发者手动通过 new 创建对象。\n通过 IoC，代码的耦合度降低，程序的灵活性和可维护性显著提高。\n例如，如果一个用户服务需要数据库连接，容器会确保数据库连接被正确注入，而无需手动创建。\n负责管理对象的生命周期和依赖关系。 它通过依赖注入（Dependency Injection, DI）来实例化、配置和组装被称为“bean”的对象。 配置元数据可以是 XML、Java 注解或 Java 代码，增强了系统的模块化和灵活性. 依赖查找 价值 灵活应对运行时需求：有些依赖需要根据实时条件获取，比如按不同场景或配置，动态选择不同实现，这时直接注入一个固定 bean 可能不够灵活，需要主动查找。 工具或框架类的特殊需求：一些工具类或公共组件并不便于被注入到特定对象中，反而使用依赖查找更符合设计。比如在某些自定义 Starter 或底层框架中，可能会在初始化流程中需要访问容器本身。 在特定场景临时获取 bean：有时你需要延迟获取某些依赖，或想在调用时才加载/初始化（如懒加载），这时依赖查找也比提前注入更合适。 实现 通过 BeanFactory 基础接口 1 2 3 4 5 6 7 8 9 10 11 // 1. 创建容器 BeanFactory factory = new XmlBeanFactory(new ClassPathResource(\u0026#34;applicationContext.xml\u0026#34;)); // 2. 查找 Bean（按名称） UserService userService = (UserService) factory.getBean(\u0026#34;userService\u0026#34;); // 3. 按类型查找（Spring 5+） UserService userService = factory.getBean(UserService.class); // 4. 按注解查找 UserService userService = factory.getBeansWithAnnotation(UserService.class); 特点：\n最原始的 IoC 容器接口 需要手动处理类型转换 适用于简单场景（现代项目更常用 ApplicationContext） 通过 ApplicationContext 接口 1 2 3 4 5 6 7 8 9 10 11 // 1. 初始化容器（XML 配置） ApplicationContext context = new ClassPathXmlApplicationContext(\u0026#34;applicationContext.xml\u0026#34;); // 2. 按名称查找 UserService userService = (UserService) context.getBean(\u0026#34;userService\u0026#34;); // 3. 按类型查找（推荐） UserService userService = context.getBean(UserService.class); // 4. 按名称+类型查找（无需强制转换） UserService userService = context.getBean(\u0026#34;userService\u0026#34;, UserService.class); 特点：\n企业级容器接口，支持事件、国际化等扩展功能 推荐使用 getBean(Class\u0026lt;T\u0026gt;) 避免类型转换错误 通过 ObjectProvider（延迟/可选依赖查找） 1 2 3 4 5 6 7 8 9 10 11 12 // 注入 ObjectProvider（Spring 4.3+） @Autowired private ObjectProvider\u0026lt;UserService\u0026gt; userServiceProvider; // 延迟获取 Bean UserService userService = userServiceProvider.getIfAvailable(); // 处理多个候选 Bean UserService userService = userServiceProvider.getIfUnique(); // 显式指定条件（如通过 @Qualifier 的变体） UserService userService = userServiceProvider.getObject(); 特点：\n支持延迟加载和可选依赖 解决 NoUniqueBeanDefinitionException 问题 结合 @Lazy 注解可实现懒加载 通过 @Autowired + ApplicationContextAware 1 2 3 4 5 6 7 8 9 10 11 12 13 @Component public class MyBean implements ApplicationContextAware { private ApplicationContext context; @Override public void setApplicationContext(ApplicationContext context) { this.context = context; } public void doSomething() { UserService userService = context.getBean(UserService.class); } } 特点：\n将容器上下文注入到 Bean 中 适用于需要动态查找的场景 通过注解扫描（基于 @ComponentScan） 1 2 3 4 5 6 7 8 9 @Configuration @ComponentScan(\u0026#34;com.example\u0026#34;) public class AppConfig {} // 初始化容器 ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class); // 查找带有 @Component 的 Bean UserRepository repo = context.getBean(UserRepository.class); 特点：\n结合组件扫描自动注册 Bean 隐式依赖查找的基础 通过 JNDI 查找（传统方式） 1 2 3 4 5 // 在 Spring XML 配置中声明 JNDI 资源 \u0026lt;jee:jndi-lookup id=\u0026#34;dataSource\u0026#34; jndi-name=\u0026#34;java:comp/env/jdbc/mydb\u0026#34;/\u0026gt; // 通过容器查找 DataSource dataSource = (DataSource) context.getBean(\u0026#34;dataSource\u0026#34;); 特点：\n适用于 Java EE 环境整合 现代项目更多使用 @Bean 配置数据源 通过静态方法（Web 环境专用） 1 2 3 4 5 6 // 获取 WebApplicationContext（如 Servlet 环境） WebApplicationContext context = WebApplicationContextUtils.getWebApplicationContext(servletContext); // 查找 Bean UserService userService = context.getBean(UserService.class); 对比 方式 适用场景 优点 缺点 BeanFactory 简单容器操作 轻量级 功能有限 ApplicationContext 企业级应用（主流选择） 功能全面 稍重 ObjectProvider 处理延迟/可选依赖 解决多候选 Bean 问题 需要 Spring 4.3+ @Autowired + 上下文 动态查找场景 灵活 侵入性强 注解扫描 自动装配的基础 简化配置 需配合组件扫描 推荐实践：\n优先使用依赖注入（被动获取） 仅在需要动态获取时使用依赖查找（如工厂模式、插件化架构） 现代项目首选 ApplicationContext.getBean() 或 ObjectProvider 依赖注入 依赖注入（Dependency Inject, DI）是 Spring 框架的核心功能，体现了控制反转（IoC）的设计原则。通过 DI，Spring IoC 容器负责创建和管理 bean 的依赖，并将这些依赖注入到目标 bean 中。注入方式包括：\n构造函数注入：通过构造函数传递依赖。 优点 使用 final 关键字，不可变，对象创建后，依赖不可变 依赖关系明确，显著降低了组件之间的耦合性，使代码更易于测试和维护。 易于测试，可以直接传递模拟依赖 Spring 会在启动时确保所有依赖都已注入，避免运行时空指针异常 缺点 如果依赖多，构造函数可能过长 缺乏灵活性，创建后无法更改依赖 setter 注入：通过 setter 方法设置依赖。 优点 灵活，可在对象创建后设置或更改依赖 适合可选依赖，可能不总是需要的 易于扩展，如果后期需要添加新依赖，只需添加新的 setter 方法 缺点 对象可变，可能导致状态不一致 未设置依赖，导致空指针异常 字段注入：通过注解（如 @Autowired）直接在字段上注入依赖，Spring 会使用反射机制在对象创建后自动设置字段的值。 优点 代码简洁，无需编写 setter 或构造函数 使用简单，易于实现 Spring 会在启动时确保依赖注入，减少手动配置 缺点 与 Spring 框架紧密耦合，增加依赖 依赖关系不显眼，测试可能更复杂 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class MyService { private final MyDependency dependency; // 构造函数注入 @Autowired public MyService(MyDependency dependency) { this.dependency = dependency; } public void doSomething() { dependency.execute(); } } public class MyService { private MyDependency dependency; // Setter 注入 @Autowired public void setDependency(MyDependency dependency) { this.dependency = dependency; } } public class MyService { // 字段注入 @Autowired private MyDependency dependency; } 依赖来源 依赖对象的来源主要就是 Spring IoC 容器（BeanFactory 或 ApplicationContext）本身。容器根据 XML、注解、Java Config 等方式加载 bean 定义并实例化这些对象，管理它们的生命周期，然后通过依赖注入或依赖查找将它们提供给应用使用。\n自定义 Bean 自己编写并交给 Spring 管理的类，比如带有 @Component、@Service、@Repository、@Controller 等注解的类，或者在 XML/JavaConfig 中显式声明的 Bean。 容器内建的 Bean Spring 容器在启动或运行过程中，会自动创建并维护一些基础设施类或辅助功能类，供框架内部或用户使用 比如 ApplicationContext 自身、Environment、ResourceLoader、ConversionService、MessageSource、BeanFactoryPostProcessor、BeanPostProcessor 以及各种内部用来处理注解、AOP、事务等功能的 Bean Environment environment = applicationContext.getBean(Environment.class); 容器内建的依赖，（依赖注入） 指的是那些不一定以 Bean 形式出现，但由容器提供、可被注入或查找的依赖。例如： BeanFactory / ApplicationContext：在使用 @Autowired 时可以直接注入 ApplicationContext； 环境变量、配置属性：通过 @Value(\u0026quot;${property}\u0026quot;) 或 Environment 对象获取； 事件发布器（ApplicationEventPublisher）、任务调度器（TaskScheduler）等容器级别的基础依赖。 这些依赖在某些情况下也会以 Bean 的形式出现，但总体上它们属于 Spring 内部或与运行环境强相关的内容，是容器层面“提供”的依赖。 元信息 Bean 的标识 包括 Bean 名称（id 或 name）、Bean 所对应的类名、别名等。 Bean 的作用域（Scope） 常见的有 singleton、prototype、request、session 等。 用于决定容器如何缓存或创建 Bean 实例。 依赖注入信息 包括构造器参数、Setter 方法注入、字段注入等。 哪些依赖是必须的？哪些是可选的？ 生命周期回调（Lifecycle callbacks）： 初始化方法（init-method 或 @PostConstruct）、 销毁方法（destroy-method 或 @PreDestroy）等 条件或环境： 比如 @Conditional 注解可以决定是否加载某个 Bean； 或者 @Profile 控制在特定环境（dev, test, prod）下是否启用某些 Bean。 其他配置： 是否使用 AOP、事务等功能； 是否启用延迟加载（lazy-init）； 是否是自动装配（autowire），等等。 配置元信息 Bean 定义配置 基于 XML 文件 基于 Properties 文件 基于 Java 注解 基于 Java API IoC 容器配置 基于 XML 文件 基于 Java 注解 基于 Java API 外部化属性配置 基于 Java 注解，@Value @Autowired 和 @Resource 的区别 注入机制 @Autowired 是基于类型的注入。 它会查找与字段或参数类型匹配的 bean。例如，如果一个字段是 MyDependency 类型，Spring 会注入所有实现 MyDependency 接口的 bean。 @Resource 是基于名称的注入。 它会根据字段名称或显式指定的名称查找 bean。例如，如果字段名为 dependency，它会查找名为 \u0026ldquo;dependency\u0026rdquo; 的 bean。 @Resource 还可以用于注入资源（如 DataSource），而不仅仅是 bean，这在某些复杂场景下可能更灵活。 是否必需 @Autowired 默认是必需的。如果找不到匹配的 bean，Spring 会抛出异常。但你可以通过 required = false使它可选。 @Resource 默认是可选的。如果找不到匹配的 bean，字段会保持为 null，无需额外配置。 标准与框架 @Autowired 是 Spring 框架专有的注解，适合深度集成 Spring 的项目。 @Resource 是 Java 标准的一部分（JSR-250），在 Java EE 环境中也常用，适合希望减少框架依赖的项目。 使用场景 如果你需要基于类型的注入，且依赖是必需的，推荐使用 @Autowired。例如： 1 2 3 4 public class MyService { @Autowired private MyDependency dependency; // 注入类型为 MyDependency 的 bean } 如果你需要基于名称的注入，或依赖是可选的，推荐使用 @Resource。例如： 1 2 3 4 public class MyService { @Resource(name = \u0026#34;specificDependency\u0026#34;) private MyDependency dependency; // 注入名为 \u0026#34;specificDependency\u0026#34; 的 bean } ","date":"2024-03-17T14:44:31+08:00","permalink":"https://blog.yellster.top/p/spring-learning-02/","title":"Spring学习笔记02 - Spring IoC"},{"content":" Spring Framework 为基于 Java 的现代企业应用程序提供了一个全面的编程和配置模型，适用于任何类型的部署平台。\nSpring 的一个关键要素是应用层面的基础架构支持：Spring 专注于企业应用程序的 “管道”，因此团队可以专注于应用程序级的业务逻辑，而无需与特定部署环境进行不必要的绑定。\n― Spring Framework, spring.io Spring Framework 有哪些核心模块? spring-core Spring 基础的API模块，如资源管理、泛型处理 提供框架的基本工具类和核心工具，如依赖注入（DI）的实现、IoC 容器的基本功能等。 spring-beans 用于管理和配置应用程序中的 bean，Bean对象的创建、生命周期管理，依赖查找、依赖注入 sprign-context 事件驱动、注解驱动、模块驱动等 建立在 Core 和 Beans 之上，提供类似于 JNDI 的功能，以及国际化、事件传播、资源加载等功能。它类似于一个轻量级的容器，便于集成不同的框架。 spring-expression Spring 表达式 语言模块 提供强大的表达式语言支持，可以在 XML 或注解中动态计算值，增强了配置和动态功能的灵活性。 spring-aop Spring AOP 处理，如动态代理、AOP字节码提升 实现面向切面编程的支持，通过切面（Aspect）来定义横切关注点，如日志、安全、事务等，从而实现与业务逻辑的分离。这一模块使得应用程序能够在不修改核心业务代码的情况下添加额外的行为。 spring-jdbc 封装了 JDBC 操作，提供了模板化方法来简化数据库访问和异常处理，减少了样板代码。 spring-orm 为主流 ORM 框架（如 Hibernate、JPA、MyBatis 等）提供支持，简化数据持久化操作的配置和集成。 spring-tx 提供声明式事务管理，帮助开发者在不同的数据访问技术之间保持一致的事务管理策略。 spring-web 为开发 web 应用提供基本的支持，包括 WebSocket、Multipart 文件上传、以及 HTTP 请求和响应处理。 spring-webmvc 实现了 Model-View-Controller (MVC) 设计模式，提供了一整套用于构建基于请求-响应模型的 Web 应用程序的组件。通过该模块，可以轻松构建松耦合、可测试的 Web 应用。 spring-test 提供对 Spring 应用的单元测试和集成测试的支持，包括对 JUnit 和 TestNG 的集成，帮助开发者在不依赖外部服务器的情况下模拟和测试应用的行为，确保代码质量和稳定性。 优势 模块化和灵活性：Spring 允许开发者选择需要的组件，支持 XML 和基于注解的配置，适合各种项目需求。 轻量级和便携性：无需繁重的应用服务器，可以在像 Tomcat 这样的 servlet 容器上运行，降低资源占用。 依赖注入和控制反转（IoC）：促进组件松耦合，易于测试和扩展。 面向切面编程（AOP）：模块化横切关注点，如日志、安全和事务管理，提升代码复用性。 丰富的生态系统：提供数据访问、Web 服务、安全等多个模块，满足企业级应用需求。 易于测试：依赖注入功能简化测试数据注入，确保应用可靠性。 一致的 API：为异常处理、事务管理等提供统一接口，简化开发。 长期维护和可靠性：Spring 历史悠久，持续更新，适合长期项目。 不足 学习曲线陡峭：对于新手或不熟悉 DI 和 AOP 的开发者，学习成本较高。 复杂性：功能丰富可能导致项目复杂，尤其对小型项目不必要。 配置冗长：尽管注解减少了 XML 配置，但某些设置仍可能繁琐。 安全问题：Spring 提供安全特性，但配置不当可能导致如跨站脚本攻击（XSS）等漏洞，需额外注意。 性能开销：抽象层可能引入轻微性能开销，但通常对大多数用例影响不大。 ","date":"2024-03-10T19:49:27+08:00","permalink":"https://blog.yellster.top/p/spring-learning-01/","title":"Spring学习笔记01 - Spring Framework"},{"content":"在 Java 中，字符串（String）被设计成不可变对象，这是语言设计中的一个重要决策。这种设计的核心原因是为了安全性、性能优化和简化程序逻辑。以下是具体原因和解释：\n不可变性的定义 不可变对象（Immutable Object）是指对象的状态在创建后不能被修改。对于 String 来说：\n任何对字符串内容的修改（如拼接、替换）都会生成新的字符串对象，原对象保持不变。\n例如：\n1 2 String s1 = \u0026#34;hello\u0026#34;; String s2 = s1.concat(\u0026#34; world\u0026#34;); // 生成新对象 \u0026#34;hello world\u0026#34;，s1 仍是 \u0026#34;hello\u0026#34; 为什么 String 要设计成不可变？ 线程安全性 不可变对象天然线程安全。多个线程可以共享同一个字符串对象，无需担心数据被意外修改，从而避免同步开销。 如果 String 可变，在多线程环境中必须通过同步机制（如 synchronized）保证一致性，性能会显著下降。 哈希码缓存（Hash Caching） String 是 HashMap、HashSet 等集合的常用键（Key）。\n不可变性保证字符串的哈希码（hashCode()）在创建时即可计算并缓存，后续使用直接复用，无需重复计算。\n1 2 String key = \u0026#34;user_id\u0026#34;; int hash = key.hashCode(); // 计算一次后缓存，后续直接使用 如果 String 可变，修改内容会导致哈希码变化，破坏哈希表的正确性（例如键的哈希码改变后无法找到原值）。\n字符串常量池优化 JVM 通过字符串常量池（String Pool） 复用字符串，减少内存开销。\n如果 String 可变，常量池中的字符串可能被意外修改，导致其他引用该字符串的代码出错。\n1 2 3 String s1 = \u0026#34;hello\u0026#34;; // 放入常量池 String s2 = \u0026#34;hello\u0026#34;; // 复用常量池中的 \u0026#34;hello\u0026#34; // 若 s1 被修改为 \u0026#34;hi\u0026#34;，s2 也会被影响（但实际不可变，所以安全） 安全性 字符串常用于敏感操作（如文件路径、数据库连接、网络请求、类加载等）。\n不可变性防止恶意代码篡改字符串内容。例如：\n1 2 3 // 假设 String 可变，攻击者可能修改路径指向恶意文件 String filePath = \u0026#34;/safe/path/config.txt\u0026#34;; // 如果 filePath 被修改为 \u0026#34;/hack/path\u0026#34;，程序会读取错误文件 类加载机制 JVM 使用字符串表示类名、方法名、包名等元数据。 如果类名（字符串）被修改，可能导致加载错误的类，破坏程序逻辑。 设计哲学与性能权衡 不可变设计简化了字符串的实现和优化。例如： 子字符串（substring()） 可以安全地共享原始字符数组（仅调整偏移量），无需复制数据。 编译器和 JVM 的优化（如常量折叠、内联优化）依赖不可变性。 尽管字符串不可变会在频繁修改时产生性能问题（如大量拼接操作），但 Java 提供了 StringBuilder 和 StringBuffer 作为补充，平衡灵活性与效率。 如何实现不可变性？ Java 通过以下机制保证 String 不可变：\n类声明为 final：禁止通过继承覆盖方法。 内部字符数组 private final char[] value：外部无法直接访问或修改，且没有实现 setter 方法。 所有修改操作返回新对象：如 concat()、replace() 等。 不可变性的核心优势 优势 说明 线程安全 无需同步，天然支持多线程共享。 哈希码缓存 提升哈希表性能，避免重复计算。 字符串常量池 减少内存占用，复用相同字符串。 安全性 防止敏感数据被篡改。 简化优化 编译器、JVM 可基于不可变性进行深度优化（如常量折叠、子字符串共享）。 示例：不可变性的实际影响 1 2 3 4 5 6 7 String s1 = \u0026#34;hello\u0026#34;; String s2 = s1; s1 = s1 + \u0026#34; world\u0026#34;; // 生成新对象 \u0026#34;hello world\u0026#34;，s1 指向新对象，s2 仍指向 \u0026#34;hello\u0026#34; // 如果 String 可变，s2 的内容会被修改，但实际不可变，s2 保持原值 System.out.println(s1); // \u0026#34;hello world\u0026#34; System.out.println(s2); // \u0026#34;hello\u0026#34; 常见疑问 不可变是否导致性能问题？ 是，但 Java 提供了 StringBuilder（非线程安全）和 StringBuffer（线程安全）来优化频繁修改字符串的场景。\n例如：循环拼接字符串时，优先使用 StringBuilder：\n1 2 3 4 5 StringBuilder sb = new StringBuilder(); for (int i = 0; i \u0026lt; 1000; i++) { sb.append(i); // 避免生成大量中间对象 } String result = sb.toString(); 为什么其他语言（如 Python）的字符串也是不可变的？ 出于类似的理由：安全性、性能优化（如驻留机制）和简化语言设计。 结论 Java 将 String 设计为不可变，是为了在安全性、性能、并发性之间取得平衡。\n这种设计虽然牺牲了部分灵活性，但通过配套工具类（如 StringBuilder）弥补了这一缺陷，成为 Java 生态稳定高效的重要基石。\n","date":"2024-01-21T16:15:09+08:00","permalink":"https://blog.yellster.top/p/java-string-immutable/","title":"为什么 String 会设计成不可变？"},{"content":"Write once, run anywhere “一次编写，到处运行”说的是Java语言跨平台的特性，Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编写，到处运行这样的效果。\n严格的讲，跨平台的语言不止Java一种，但Java是较为成熟的一种。“一次编写，到处运行”这种效果跟编译器有关。编程语言的处理需要编译器和解释器。Java虚拟机和DOS类似，相当于一个供程序运行的平台。\n程序从源代码到运行的三个阶段：编码——编译——运行——调试。Java在编译阶段则体现了跨平台的特点。编译过程大概是这样的：首先是将Java源代码转化成.CLASS文件字节码，这是第一次编译。 .class 文件就是可以到处运行的文件。然后Java字节码会被转化为目标机器代码，这是是由JVM来执行的，即Java的第二次编译。\n“到处运行”的关键和前提就是JVM。因为在第二次编译中JVM起着关键作用。在可以运行Java虚拟机的地方都内含着一个JVM操作系统。从而使JAVA提供了各种不同平台上的虚拟机制，因此实现了“到处运行”的效果。需要强调的一点是，java并不是编译机制，而是解释机制。Java字节码的设计充分考虑了JIT这一即时编译方式，可以将字节码直接转化成高性能的本地机器码，这同样是虚拟机的一个构成部分。\nJava 是解释运行吗？ 答案是 不是\nJava 是如何编译的？ 编译阶段： Java源代码（.java）通过javac编译器 提前编译 为平台无关的字节码（.class） 这一步是传统的AOT（Ahead-Of-Time, 预先编译，编译在程序运行前完成）编译，生成中间代码而非机器码 运行时阶段： 解释执行： JVM（如HotSpot）首先逐行解释执行字节码（.class）。 JIT编译： （Just in time，即时编译）对于频繁执行的代码（热点代码，方法级代码），JVM触发JIT编译器（如C1/C2）将其编译为本地机器码，大幅提升性能，属于运行时动态优化。 ","date":"2024-01-20T15:35:28+08:00","permalink":"https://blog.yellster.top/p/write-once-run-anywhere/","title":"如何理解Java的 “一次编写，到处运行”"},{"content":"iptables 是什么 iptables 是运行在用户空间的应用软件，通过控制Linux内核netfilter模块，来管理网络数据包的处理和转发。iptables只支持处理ipv4数据包，对于ipv6数据包，则需要ip6tables。\niptables命令介绍 1 2 3 4 5 6 7 8 9 10 11 12 13 # iptables --help iptables v1.4.21 Usage: iptables -[ACD] chain rule-specification [options] iptables -I chain [rulenum] rule-specification [options] iptables -R chain rulenum rule-specification [options] iptables -D chain rulenum [options] iptables -[LS] [chain [rulenum]] [options] iptables -[FZ] [chain] [options] iptables -[NX] chain iptables -E old-chain-name new-chain-name iptables -P chain target [options] iptables -h (print this help information) iptables基本命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 --append -A chain 添加一个规则到链的末尾 --check -C chain 检查某一条链是否存在 --delete -D chain 删除匹配的链 --delete -D chain rulenum 删除指定链的某一条规则 --insert -I chain [rulenum] 根据给出的规则序号向所选链中插入一条或更多规则。所以，如果规则序号为1， 规则会被插入链的头部。这也是不指定规则序号时的默认方式。 --replace -R chain rulenum 修改指定链中的某一条规则 --list -L [chain [rulenum]] 列出指定链中的规则 --list-rules -S [chain [rulenum]] 打印出指定链中的规则 --flush -F [chain] 删除指定链中的规则 --zero -Z [chain [rulenum]] 把指定链，或者表中的所有链上的所有计数器清零 --new -N chain 创建一条用户自定义链 --delete-chain -X [chain] 删除一条用户自定义链 --policy -P chain target 该表某条链的策略 --rename-chain -E old-chain new-chain 修改链的名称(只有用户自定义链的名称可以被修改） iptables选项参数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 [!] --protocol -p proto 规则或者包检查的协议。指定协议可以是tcp、udp、icmp中的一个或全部，也可以是数值，代表这些协议中的某一个。 当然也可以使用在/etc/protocols中定义的协议名。在协议名前加\u0026#39;!\u0026#39;表示相反的规则。数字0相当于all。Protocol all会匹配所有协议，而且这是缺省的选项。在和check命令结合时，all可以不被使用 [!] --source -s address[/mask][...] 指定源地址，可以是主机名、网络名或IP地址。mask说明可以是网络掩码或清楚的数字。标志--src是这个选项的简写。 [!] --destination -d address[/mask][...] 指定目标地址。标志--dst是这个选项的简写 --jump -j target 执行指定的动作 --goto -g chain 跳转到指定的链 --match -m match 扩展匹配 --numeric -n 以数字的形式显示IP地址和端口 [!] --in-interface -i input name[+] 匹配由指定网络接口进入的数据包 [!] --out-interface -o output name[+] 由指定接口发出的数据包 [!] --fragment -f 这意味着在分片的包中，规则只询问第二及以后的片 --exact -x 扩展数字。显示包和字节计数器的精确值，代替用K、M、G表示的约数。这个选项仅能用于-L选项 --line-numbers 当列表显示规则时，在每个规则前面加上行号，与该规则在链中的位置相对应。 1. 针对 tcp 的扩展 当 --protocol tcp被指定，且其他匹配的扩展未被指定时，这些扩展被装载。它提供以下选项：\n1 2 3 4 5 6 7 8 9 10 11 12 13 --source-port [!] [port[:port]] 源端口或端口范围指定，也可以使用服务名或端口号。如果使用端口范围，若首端口号忽略则默认为0，若尾端口号忽略则 默认为65535。这个选项可以简写为--sport --destionation-port [!] [port:[port]] 目标端口或端口范围指定。这个选项可以使用--dport别名来代替 --tcp-flags [!] mask comp 匹配指定的TCP标记。第一个参数是我们要检查的标记，一个用逗号分开的列表，第二个参数是用逗号分开的标记表,是必须 被设置的。标记如下：SYN ACK FIN RST URG PSH ALL NONE。例如我们有如下这条命令： iptables -A FORWARD -p tcp --tcp-flags SYN,ACK,FIN,RST SYN 上面这条命令只匹配那些SYN标志被设置而ACK、FIN和RST标记没有被设置的包 [!] --syn 只匹配那些设置了SYN位而清除了ACK和FIN位的TCP包。这些包用于TCP连接初始化时发出请求。例如，大量的这种包进入一个 接口发生堵塞时会阻止进入的TCP连接，而出去的TCP连接不会受到影响。这等于：--tcp-flags SYN,RST,ACK SYN --tcp-option [!] number 匹配设置了TCP选项的数据包 2. 针对 udp 的扩展 当 --protocol udp被指定，且其他匹配的扩展未被指定时，这些扩展被装载。它提供以下选项：\n1 2 --source-port [!] [port:[port]] 源端口或端口范围指定 --destionation-port [!] [port:[port]] 目标端口或端口范围指定 3. 针对 ICMP 的扩展 当 --protocol icmp被指定，且其他匹配的扩展未被指定时，这些扩展被装载。它提供以下选项：\n1 --icmp-type [!] typename 这个选项允许指定ICMP类型，可以是一个数值型的ICMP类型，或者是某个由命令iptables -p icmp -h所显示的ICMP类型名 4. 针对 mac 的扩展 1 --mac-source [!] address 匹配物理地址。注意它只对来自以太设备并进入PREROUTING、FORWORD和INPUT链的包有效。 5. 针对 limit 的扩展 1 2 --limit rate 最大平均匹配速率：可赋的值有\u0026#39;/second\u0026#39;, \u0026#39;/minute\u0026#39;, \u0026#39;/hour\u0026#39;, or \u0026#39;/day\u0026#39;这样的单位，默认是3/hour --limit-burst number 待匹配包初始个数的最大值:若前面指定的极限还没达到这个数值,则概数字加1.默认值为5 iptables targets 介绍 iptables的 -j选项后面对应的是要执行的target。其中有些target具有一些扩展选项，下面我们会一并介绍：\n1. ACCEPT 表示接收匹配的数据包\n2. DROP 表示丢弃匹配的数据包\n3. REJECT 作为对匹配的包的响应，返回一个错误的包：其他情况下与DROP 相同\n此目标只适用于INPUT、FORWORD和OUTPUT，和调用这些的用户自定义链。\n1 2 3 4 5 6 --reject-with type type可以是icmp-net-unreachable、icmp-host-unreachable、icmp-port-nreachable、icmp-proto-unreachable、 icmp-net-prohibited或者icmp-host-prohibited，该类型会返回相应的ICMP错误信息（默认是port-unreachable） --echo-reply 它只能用于指定ICMP ping包的规则中，生成ping的回应 --tcp-reset 可以用于在INPUT链中,或自INPUT链调用的规则，只匹配TCP协议：将回应一个TCP RST包。 4. REDIRECT 表示重定向匹配的数据包，只适用于nat表的PREROUTING和OUTPUT，和只调用它们的用户自定义链。它修改包的目标IP地址来发送包到机器自身（本地生成的包被安置为地址127.0.0.1）\n1 --to-ports [port-port] 指定使用的目的端口或端口范围：不指定的话，目标端口不会被修改。只能用于指定了-p tcp 或 -p udp的规则。 iptables常用命令 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 新增规则# 指定 ip 访问指定端口 iptables -I INPUT -s \u0026lt;ip\u0026gt; -p tcp -m tcp --dport \u0026lt;port\u0026gt; -j ACCEPT # 允许所有ip访问指定端口 iptables -I INPUT -p tcp -m tcp --dport \u0026lt;port\u0026gt; -j ACCEPT # 查看所有规则 iptables -n -L # 查看所有规则，带 序号 iptables -n -L --line-number # 删除规则# 删除 INPUT 的 序号为 1 的规则 iptables -D INPUT 1 ","date":"2023-12-28T21:15:49+08:00","image":"https://blog.yellster.top/p/iptables/iptables_hu_4bed75a4a773a193.webp","permalink":"https://blog.yellster.top/p/iptables/","title":"Iptables"},{"content":"certbot简介 本质上来说，certbot 就是一个 ACME client，这也是 Let’s Encrypt 官网推荐的签发证书的方式，适用于对自己的 domain 具有 shell 访问能力的情况，使用所谓的 ACME 协议来自动化的签发证书，很大程度上简化了证书签发的步骤。\n安装步骤 以 Ubuntu为例，安装certbot\n1 2 sudo apt-get update sudo apt-get install certbot python3-certbot-nginx 为nginx生成证书 1 sudo certbot --nginx -d www.yourdomain.com 将 www.yourdomain.com替换为您的实际域名。Certbot将自动配置Nginx以使用生成的证书。\n证书将在90天后过期，因此我们需要设置自动续期。Certbot包含一个名为certbot renew的命令，用于检查证书是否需要更新，如果需要，则自动更新它们。\n自动续期 为了设置自动续期，我们将创建一个定时任务（cron job）。\n1 2 3 4 crontab -e # 每月1号执行一次 0 0 1 */1 * /usr/bin/certbot renew --quiet ","date":"2023-12-19T20:15:06+08:00","image":"https://blog.yellster.top/p/certbot-ssl/certbot_hu_273039a4fe2d7a20.png","permalink":"https://blog.yellster.top/p/certbot-ssl/","title":"Certbot免费申请SSL证书"},{"content":"现状 某些网站打开，因为当前网络等其他原因，无法正常访问页面，只能显示网站的基本文字，而没有图片，样式等\n产生原因 当前网站的样式地址、静态文件地址，无法访问，或者不安全被浏览器拦截\n解决办法 打开无法正常访问的网站 F12，打开审查，切换到 Network tab页，刷新页面，会发现很多地址都是显示红色 选择任意一个红色的无法访问的地址，双击打开，会发现浏览器出现隐私错误提示 高级，仍然访问，(或者直接在当前页面上键盘输入 thisisunsafe) 当前页面会刷新重新访问，并正常访问 这时，继续切换到 该网站 的标签页，刷新，会发现当前页面可以正常访问了 猜测 猜测该类网站无法访问，是因为Chrome不信任这些静态资源地址 自签名ssl证书，为了安全起见，直接禁止访问了\n","date":"2023-10-23T15:14:25+08:00","image":"https://blog.yellster.top/p/missing-styles/unsafe_link_hu_afcbaf47f009ee2.png","permalink":"https://blog.yellster.top/p/missing-styles/","title":"访问网站缺少样式"},{"content":"在GitHub或者GitLab提交超过50M的大文件的时候，无法上传 什么是Git LFS Git 是分布式版本控制系统，这意味着在克隆过程中会将仓库的整个历史记录传输到客户端。 对于包涵大文件（尤其是经常被修改的大文件）的项目，初始克隆需要大量时间，因为客户端会下载每个文件的每个版本。 Git LFS（Large File Storage）是由 Atlassian, GitHub 以及其他开源贡献者开发的 Git 扩展，它通过延迟地（lazily）下载大文件的相关版本来减少大文件在仓库中的影响，具体来说，大文件是在 checkout 的过程中下载的，而不是 clone 或 fetch 过程中下载的（这意味着你在后台定时 fetch 远端仓库内容到本地时，并不会下载大文件内容，而是在你 checkout 到工作区的时候才会真正去下载大文件的内容）。\n参考文献 Atlassian官方LFS文章 ","date":"2023-09-12T15:41:12+08:00","permalink":"https://blog.yellster.top/p/gitlfs/","title":"Git Lfs"},{"content":" “Yeah It\u0026rsquo;s on. ”\n","date":"2023-02-12T19:31:57+08:00","image":"https://blog.yellster.top/p/hello-world/hello-world_hu_aa0de37877cc16eb.png","permalink":"https://blog.yellster.top/p/hello-world/","title":"Hello World"}]