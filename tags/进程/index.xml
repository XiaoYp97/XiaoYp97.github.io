<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>进程 on Yellster - Blog</title><link>https://blog.yellster.top/tags/%E8%BF%9B%E7%A8%8B/</link><description>Recent content in 进程 on Yellster - Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>xyp_selune@163.com (Yellster)</managingEditor><webMaster>xyp_selune@163.com (Yellster)</webMaster><lastBuildDate>Fri, 11 Apr 2025 13:38:57 +0800</lastBuildDate><atom:link href="https://blog.yellster.top/tags/%E8%BF%9B%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>进程与线程</title><link>https://blog.yellster.top/p/process-thread/</link><pubDate>Fri, 11 Apr 2025 13:38:57 +0800</pubDate><author>xyp_selune@163.com (Yellster)</author><guid>https://blog.yellster.top/p/process-thread/</guid><description>&lt;img src="https://blog.yellster.top/p/process-thread/process-thread.webp" alt="Featured image of post 进程与线程" />&lt;p>在现代操作系统中，&lt;strong>进程&lt;/strong>、&lt;strong>线程&lt;/strong>和&lt;strong>虚拟地址&lt;/strong>是支撑高效执行、内存管理与资源隔离的三大核心概念。它们相互配合，共同保证系统的稳定性、安全性与并发性能。&lt;/p>
&lt;h2 id="进程资源隔离与调度的基本单位">进程：资源隔离与调度的基本单位
&lt;/h2>&lt;h3 id="概念">概念
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>进程&lt;/strong>：正在运行的程序实例，拥有独立的地址空间、数据段、堆与栈，以及各类系统资源（文件描述符、信号、IPC 对象等）。&lt;/li>
&lt;/ul>
&lt;h3 id="创建与执行">创建与执行
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>&lt;strong>创建&lt;/strong>：Linux 中通过 &lt;code>fork()&lt;/code> 复制父进程，再用 &lt;code>exec()&lt;/code> 系列函数加载新程序。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>fork()——复制当前进程&lt;/strong>&lt;/p>
&lt;p>父进程调用 &lt;code>fork()&lt;/code>，内核在后台复制出一个“子进程”，这个子进程和父进程几乎一模一样（地址空间、打开的文件描述符等都拷贝或共享）。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>execve()（或其它 exec* 系列函数）——在子进程里加载新程序&lt;/strong>&lt;/p>
&lt;p>子进程中立即调用 &lt;code>execve(&amp;quot;/path/to/newprog&amp;quot;, argv, envp)&lt;/code>，内核就会丢弃掉原来的地址空间，把可执行文件 &lt;code>/path/to/newprog&lt;/code> 映射进来，初始化全新的代码段、数据段、堆栈，真正运行“一个全新的进程镜像”。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>调度&lt;/strong>：内核调度器（scheduler）负责分配 CPU 时间片，维护多任务并发运行。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="进程间通信ipc">进程间通信（IPC）
&lt;/h3>&lt;p>由于进程地址空间独立，IPC 机制尤为重要：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>方式&lt;/th>
&lt;th>场景&lt;/th>
&lt;th>优势&lt;/th>
&lt;th>注意点&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>管道（Pipe）&lt;/td>
&lt;td>父子进程&lt;/td>
&lt;td>简单、快速&lt;/td>
&lt;td>仅限亲缘进程，单向&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>命名管道&lt;/td>
&lt;td>任意本地进程&lt;/td>
&lt;td>双向、可见文件系统&lt;/td>
&lt;td>性能略低&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>消息队列&lt;/td>
&lt;td>异步通信&lt;/td>
&lt;td>支持优先级、可靠传输&lt;/td>
&lt;td>大量小消息时开销增大&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>共享内存&lt;/td>
&lt;td>大块数据交换&lt;/td>
&lt;td>&lt;a class="link" href="https://blog.yellster.top/p/zero-copy/" >零拷贝&lt;/a>、高吞吐&lt;/td>
&lt;td>需同步机制（锁、信号量）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>套接字（Socket）&lt;/td>
&lt;td>本地／跨网络进程&lt;/td>
&lt;td>灵活、多协议&lt;/td>
&lt;td>网络开销相对较大&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>信号（Signal）&lt;/td>
&lt;td>异步通知&lt;/td>
&lt;td>轻量级、实时性好&lt;/td>
&lt;td>数据传输能力有限&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>&lt;strong>IPC（进程间通信，Inter-Process Communication）&lt;/strong> 是指在操作系统中，不同进程之间为交换数据或进行同步而提供的一系列机制。&lt;/p>
&lt;p>由于操作系统给每个进程分配了独立的地址空间，直接读写对方内存是不被允许的，IPC 就是为了解决“&lt;strong>进程如何安全、高效地互相协作&lt;/strong>”而产生的。&lt;/p>&lt;/blockquote>
&lt;h2 id="线程轻量级执行流与并行处理">线程：轻量级执行流与并行处理
&lt;/h2>&lt;h3 id="概念-1">概念
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>线程&lt;/strong>：依附于进程的执行单元，共享进程的地址空间和大部分资源，但拥有各自的寄存器上下文和栈。&lt;/li>
&lt;/ul>
&lt;h3 id="创建与管理">创建与管理
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Linux 实现&lt;/strong>：基于 &lt;code>clone()&lt;/code> 系统调用；POSIX 线程库（pthread）提供了更友好的 API。&lt;/li>
&lt;li>&lt;strong>切换开销&lt;/strong>：比进程轻量，适用于高并发场景。&lt;/li>
&lt;/ul>
&lt;h3 id="并发挑战">并发挑战
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>竞态条件&lt;/strong>：无同步的并发访问可能导致数据不一致。&lt;/li>
&lt;li>&lt;strong>死锁&lt;/strong>：多线程间相互等待锁时出现永久阻塞。&lt;/li>
&lt;li>&lt;strong>活锁与饥饿&lt;/strong>：线程过度谦让或被长期剥夺执行机会。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>示例&lt;/strong>（Rust 风格伪代码）：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">counter&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Arc&lt;/span>::&lt;span class="n">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Mutex&lt;/span>::&lt;span class="n">new&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">));&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">handles&lt;/span>: &lt;span class="nb">Vec&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="o">..&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">).&lt;/span>&lt;span class="n">map&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="n">_&lt;/span>&lt;span class="o">|&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">Arc&lt;/span>::&lt;span class="n">clone&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;amp;&lt;/span>&lt;span class="n">counter&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">thread&lt;/span>::&lt;span class="n">spawn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="k">move&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">||&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">mut&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">c&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">unwrap&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">num&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">+=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">})&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}).&lt;/span>&lt;span class="n">collect&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">for&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="k">in&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">handles&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">h&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">join&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">unwrap&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="fm">println!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Result: &lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">counter&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">lock&lt;/span>&lt;span class="p">().&lt;/span>&lt;span class="n">unwrap&lt;/span>&lt;span class="p">());&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/blockquote>
&lt;h2 id="虚拟地址抽象内存与安全保护">虚拟地址：抽象内存与安全保护
&lt;/h2>&lt;h3 id="概念-2">概念
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>虚拟地址&lt;/strong>：操作系统为每个进程提供的连续逻辑地址空间，与物理内存无直接一一映射。&lt;/li>
&lt;/ul>
&lt;h3 id="管理机制">管理机制
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>分页（Paging）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>页大小&lt;/strong>：通常 4 KB，也有大页（2 MB/1 GB）。&lt;/li>
&lt;li>&lt;strong>多级页表&lt;/strong>：如 x86_64 的 4 级页表，减少内存占用。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>地址转换&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-text" data-lang="text">&lt;span class="line">&lt;span class="cl">虚拟地址 = [页目录索引][页表索引][页内偏移]
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">物理地址 = 页框号 + 偏移
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>通过 MMU 与 TLB 快速完成转换。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>保护与优化&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>访问权限&lt;/strong>：读/写/执行标志。&lt;/li>
&lt;li>&lt;strong>用户/内核隔离&lt;/strong>：防止越权访问。&lt;/li>
&lt;li>&lt;strong>写时复制（COW）&lt;/strong>：延迟复制，降低 fork 开销。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="能当做-ipc-吗">能当做 IPC 吗？
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>虚拟地址本身不共享&lt;/strong>，不能直接跨进程使用。&lt;/li>
&lt;li>&lt;strong>共享内存&lt;/strong> 或 &lt;strong>mmap(MAP_SHARED)&lt;/strong> 是利用虚拟地址“映射”同一段物理页到不同进程，从而实现高效的 IPC。&lt;/li>
&lt;li>你只需要在各自进程里拿到映射后自己的虚拟指针，就能像访问本地内存一样进行读写。&lt;/li>
&lt;/ul>
&lt;h2 id="协程更轻量的用户态并发">协程：更轻量的用户态并发
&lt;/h2>&lt;h3 id="概念-3">概念
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>协程（Coroutine）&lt;/strong>：用户态的轻量级执行单元，又称“微线程”或“纤程”。它在单线程内通过显式的调度点（yield）实现多任务切换，无需内核参与。&lt;/li>
&lt;/ul>
&lt;h3 id="特点">特点
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>特性&lt;/th>
&lt;th>线程&lt;/th>
&lt;th>协程&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>调度&lt;/td>
&lt;td>内核调度（抢占式）&lt;/td>
&lt;td>用户态调度（协作式）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>上下文切换开销&lt;/td>
&lt;td>高（进入内核，保存/恢复寄存器、内核栈）&lt;/td>
&lt;td>低（仅保存/恢复少量寄存器和用户栈指针）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>通信&lt;/td>
&lt;td>共享内存需锁、IPC&lt;/td>
&lt;td>函数调用/Channel/队列 等&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>并发规模&lt;/td>
&lt;td>受限于内核线程数&lt;/td>
&lt;td>数万乃至数十万轻松支持&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="调度模型">调度模型
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>协作式&lt;/strong>：运行到显式 &lt;code>yield&lt;/code> 或 &lt;code>await&lt;/code> 才切换，开发者可精确控制切换点。&lt;/li>
&lt;li>&lt;strong>预emptive（部分语言支持）&lt;/strong>：语言运行时定期打断协程，但大多数主流实现（如 Python、Go）采用协作式。&lt;/li>
&lt;/ul>
&lt;h3 id="常见实现">常见实现
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Go&lt;/strong>：goroutine + M:N 调度，M 代表系统线程，N 代表用户协程，由 runtime 自动分配。&lt;/li>
&lt;li>&lt;strong>Python&lt;/strong>：&lt;code>async def&lt;/code> + &lt;code>await&lt;/code>，基于事件循环（&lt;code>asyncio&lt;/code>）或第三方库（如 Trio、Curio）。&lt;/li>
&lt;li>&lt;strong>Rust&lt;/strong>：&lt;code>async/await&lt;/code> + Futures + executor（如 Tokio、async-std），通过状态机驱动。&lt;/li>
&lt;li>&lt;strong>JavaScript&lt;/strong>：基于事件循环的 Promise + &lt;code>async/await&lt;/code>，单线程协程模型。&lt;/li>
&lt;/ul>
&lt;h3 id="应用场景">应用场景
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>高并发 I/O&lt;/strong>：Web 服务器、爬虫、网络代理等，常用事件驱动 + 协程模型实现百万级并发。&lt;/li>
&lt;li>&lt;strong>异步任务流&lt;/strong>：管道化处理、大量小任务的并行调度。&lt;/li>
&lt;li>&lt;strong>可控并发&lt;/strong>：无需锁或细粒度锁，简化并发控制。&lt;/li>
&lt;/ul>
&lt;h2 id="四者对比与协同">四者对比与协同
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>模型&lt;/th>
&lt;th>调度方式&lt;/th>
&lt;th>切换开销&lt;/th>
&lt;th>共享资源&lt;/th>
&lt;th>适用场景&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>进程&lt;/td>
&lt;td>内核（抢占）&lt;/td>
&lt;td>最大&lt;/td>
&lt;td>无（需 IPC）&lt;/td>
&lt;td>资源隔离、强隔离需求&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>线程&lt;/td>
&lt;td>内核（抢占）&lt;/td>
&lt;td>较大&lt;/td>
&lt;td>共享进程资源&lt;/td>
&lt;td>CPU 并行、I/O 并发&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>协程&lt;/td>
&lt;td>用户（协作）&lt;/td>
&lt;td>最小&lt;/td>
&lt;td>共享线程资源&lt;/td>
&lt;td>海量并发 I/O、异步流程&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>虚拟地址&lt;/td>
&lt;td>——&lt;/td>
&lt;td>——&lt;/td>
&lt;td>——&lt;/td>
&lt;td>为进程/线程/协程提供统一内存抽象&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>&lt;strong>进程&lt;/strong>： &lt;strong>是资源分配的基本单位&lt;/strong>，每个进程都有独立的内存空间（代码段、数据段、堆栈等），提供最强隔离。&lt;/li>
&lt;li>&lt;strong>线程&lt;/strong>： &lt;strong>是 CPU 调度的基本单位&lt;/strong>，属于进程，一个进程可以包含多个线程。共享进程的内存空间和资源（文件句柄、数据段等）在同一地址空间内并行。&lt;/li>
&lt;li>&lt;strong>协程&lt;/strong>： 在单线程内更高效地调度。&lt;/li>
&lt;li>&lt;strong>虚拟地址&lt;/strong>： 是上述模型的基础，屏蔽物理内存复杂性并提供保护。&lt;/li>
&lt;/ul>
&lt;h3 id="应用场景选型">应用场景选型
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>场景&lt;/th>
&lt;th>建议方案&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>资源隔离优先&lt;/td>
&lt;td>对安全或稳定性要求极高的组件，首选进程&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>并行计算&lt;/td>
&lt;td>CPU 密集任务可用多进程或多线程&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>高并发 I/O&lt;/td>
&lt;td>首选协程框架，结合事件驱动（如 epoll、kqueue）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>混合模式&lt;/td>
&lt;td>Web 服务常用 “多进程 + 协程” 的组合：进程隔离，协程高并发&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="总结">总结
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>进程&lt;/strong>、&lt;strong>线程&lt;/strong> 和 &lt;strong>协程&lt;/strong> 是三种层次不同的并发单元，各自有取舍。&lt;/li>
&lt;li>&lt;strong>虚拟地址&lt;/strong> 为它们提供了统一、隔离且安全的内存视图。&lt;/li>
&lt;li>在实际系统设计中，合理组合使用，才能兼顾隔离性、并发性与性能，打造高性能、高可靠的应用架构。&lt;/li>
&lt;/ul>
&lt;h2 id="进程调度算法">进程调度算法
&lt;/h2>&lt;h3 id="非抢占式调度">非抢占式调度
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>先来先服务（FCFS）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>原理&lt;/strong>：按进程到达就绪队列的先后顺序依次调度，类似队列排队。&lt;/li>
&lt;li>&lt;strong>优点&lt;/strong>：简单易实现；无饥饿。&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：平均等待时间不一定最短，易出现“短作业后面跟长作业”拖慢整体效率。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>短作业优先（SJF）／最短剩余时间优先（SRTF）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>SJF（非抢占）&lt;/strong>：每次选择执行时间最短的作业；&lt;/li>
&lt;li>&lt;strong>SRTF（抢占）&lt;/strong>：新作业到达时，如果其所需时间比当前剩余时间短，则抢占。&lt;/li>
&lt;li>&lt;strong>优点&lt;/strong>：能最小化平均等待时间；&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：需要准确估计执行时间；可能导致长作业“饥饿”。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>优先级调度（Priority）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>原理&lt;/strong>：为每个进程分配优先级，优先级高的先执行；可抢占或非抢占。&lt;/li>
&lt;li>&lt;strong>优点&lt;/strong>：满足关键任务优先执行；&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：低优先级可能长时间得不到调度（饥饿），需用“优先级老化”机制解决。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="抢占式调度">抢占式调度
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>时间片轮转（Round Robin，RR）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>原理&lt;/strong>：给每个进程分配固定长度的时间片，时间片用完即切换到下一个进程，循环往复。&lt;/li>
&lt;li>&lt;strong>优点&lt;/strong>：响应时间可控，适合交互式系统；无进程饥饿。&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：时间片大小需平衡，过大接近 FCFS，过小切换开销大。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>多级队列调度（Multilevel Queue）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>原理&lt;/strong>：将进程按类型（交互式、批处理、系统进程等）分到多个队列，不同队列使用不同算法和优先级。&lt;/li>
&lt;li>&lt;strong>优点&lt;/strong>：可针对性地优化不同类型作业；&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：队列间切换策略固定，灵活性较差。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>多级反馈队列（Multilevel Feedback Queue）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>原理&lt;/strong>：允许进程在不同优先级队列间动态升降，根据其执行特性（CPU 密集或 I/O 密集）调整优先级。&lt;/li>
&lt;li>&lt;strong>优点&lt;/strong>：兼顾短作业和长作业，能自动提升响应性；&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：参数（队列数、时间片长度、反馈规则）较多，需要调优。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="现代与实时调度">现代与实时调度
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>最早截止时间优先（EDF, Earliest Deadline First）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>应用&lt;/strong>：实时系统&lt;/li>
&lt;li>&lt;strong>原理&lt;/strong>：总是选择截止时间最早的任务执行，可抢占。&lt;/li>
&lt;li>&lt;strong>优点&lt;/strong>：理论上能在系统总利用率 ≤100% 时保证所有任务准时完成；&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：需要精确的任务截止时间。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>率先最小周期优先（RMS, Rate Monotonic Scheduling）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>应用&lt;/strong>：实时系统，周期性任务&lt;/li>
&lt;li>&lt;strong>原理&lt;/strong>：周期短（率高）的任务优先级高；&lt;/li>
&lt;li>&lt;strong>优点&lt;/strong>：简单固定优先级；&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：在高利用率下不能保证可调度（理论上利用率上限 ≈69%）。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Linux 完全公平调度器（CFS, Completely Fair Scheduler）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>应用&lt;/strong>：通用 Linux 桌面/服务器&lt;/li>
&lt;li>&lt;strong>原理&lt;/strong>：用虚拟运行时间（vruntime）衡量每个任务已经“拿过”的 CPU 时间，优先选择 vruntime 最小者执行。&lt;/li>
&lt;li>&lt;strong>优点&lt;/strong>：可以在多任务间实现近似理想的公平；&lt;/li>
&lt;li>&lt;strong>缺点&lt;/strong>：算法复杂度高于传统调度，切换开销略大。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="选择与权衡">选择与权衡
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>交互式系统&lt;/strong>（桌面应用、Web 服务器）：优先 RR、Multilevel Feedback Queue、CFS&lt;/li>
&lt;li>&lt;strong>批处理系统&lt;/strong>（后台任务、科学计算）：可选 SJF/SRTF、Multilevel Queue&lt;/li>
&lt;li>&lt;strong>实时系统&lt;/strong>（控制、嵌入式）：EDF、RMS&lt;/li>
&lt;li>&lt;strong>混合场景&lt;/strong>：多级反馈队列 + 结合优先级老化保证低优先级可执行&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>算法&lt;/th>
&lt;th>抢占&lt;/th>
&lt;th>优点&lt;/th>
&lt;th>缺点&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>FCFS&lt;/td>
&lt;td>否&lt;/td>
&lt;td>简单易实现，无饥饿&lt;/td>
&lt;td>平均等待时间高&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SJF / SRTF&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>最小化平均等待时间&lt;/td>
&lt;td>需估计运行时长；长期作业易饥饿&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Priority&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>可满足关键任务优先&lt;/td>
&lt;td>需防止低优先级饥饿&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Round Robin&lt;/td>
&lt;td>是&lt;/td>
&lt;td>响应时间可控，无饥饿&lt;/td>
&lt;td>时间片选取需平衡；频繁切换开销大&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Multilevel Queue&lt;/td>
&lt;td>可选&lt;/td>
&lt;td>针对不同类型作业优化&lt;/td>
&lt;td>队列间固化策略；灵活性差&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Multilevel Feedback&lt;/td>
&lt;td>是&lt;/td>
&lt;td>自适应调度，兼顾短/长作业&lt;/td>
&lt;td>参数调优复杂&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>EDF / RMS（实时）&lt;/td>
&lt;td>是&lt;/td>
&lt;td>实时可调度保证&lt;/td>
&lt;td>需准确的任务参数&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>CFS&lt;/td>
&lt;td>是&lt;/td>
&lt;td>理想公平，适合通用场景&lt;/td>
&lt;td>实现复杂，切换开销略大&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item></channel></rss>