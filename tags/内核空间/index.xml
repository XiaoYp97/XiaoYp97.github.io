<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>内核空间 on Yellster - Blog</title><link>https://blog.yellster.top/tags/%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/</link><description>Recent content in 内核空间 on Yellster - Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>xyp_selune@163.com (Yellster)</managingEditor><webMaster>xyp_selune@163.com (Yellster)</webMaster><lastBuildDate>Sat, 21 Sep 2024 16:09:09 +0800</lastBuildDate><atom:link href="https://blog.yellster.top/tags/%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4/index.xml" rel="self" type="application/rss+xml"/><item><title>零拷贝</title><link>https://blog.yellster.top/p/zero-copy/</link><pubDate>Sat, 21 Sep 2024 16:09:09 +0800</pubDate><author>xyp_selune@163.com (Yellster)</author><guid>https://blog.yellster.top/p/zero-copy/</guid><description>&lt;img src="https://blog.yellster.top/p/zero-copy/zero-copy.png" alt="Featured image of post 零拷贝" />&lt;p>&lt;strong>​零拷贝（Zero-Copy）&lt;/strong> 是一种操作系统级别的 I/O 优化技术，旨在减少或避免数据在内存中的多次拷贝，降低 CPU 占用率，提高数据传输效率，尤其适用于高并发、大吞吐量的场景，如网络通信、文件传输等。&lt;/p>
&lt;h2 id="传统-io-的调用">传统 I/O 的调用
&lt;/h2>&lt;p>传统 I/O 操作中，数据需要从磁盘文件拷贝到内核空间，再从内核空间拷贝到用户空间，然后再拷贝到 &lt;code>Socket Buffer&lt;/code> 中，再拷贝到网卡设备。&lt;/p>
&lt;p>&lt;img src="https://blog.yellster.top/p/zero-copy/%E4%BC%A0%E7%BB%9F%E6%8B%B7%E8%B4%9D.png"
width="1080"
height="607"
srcset="https://blog.yellster.top/p/zero-copy/%E4%BC%A0%E7%BB%9F%E6%8B%B7%E8%B4%9D_hu_f7b29adf1e79d7de.png 480w, https://blog.yellster.top/p/zero-copy/%E4%BC%A0%E7%BB%9F%E6%8B%B7%E8%B4%9D_hu_d56501e2b550c485.png 1024w"
loading="lazy"
alt="传统拷贝"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="427px"
>&lt;/p>
&lt;p>传统的 I/O 操作过程中，涉及到 &lt;strong>4 次上下文切换&lt;/strong>（用户态和内核态的上下文切换）和 &lt;strong>4 次数据拷贝&lt;/strong>（2 次 CPU 拷贝、2 次 DMA 拷贝）：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>上下文从用户态切换到内核态&lt;/strong>：应用程序进程调用 &lt;code>read&lt;/code> ，发起 &lt;code>I/O 调用&lt;/code>；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 将数据从 &lt;code>磁盘文件（硬件设备）&lt;/code> 拷贝到 &lt;code>内核缓冲区（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>上下文从内核态切换到用户态&lt;/strong>：&lt;code>read&lt;/code> 调用返回；&lt;/li>
&lt;li>&lt;strong>CPU 拷贝&lt;/strong>：&lt;code>CPU&lt;/code> 将数据从 &lt;code>内核缓冲区（内核空间）&lt;/code> 拷贝到 &lt;code>用户缓冲区（用户空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>上下文从用户态切换到内核态&lt;/strong>：应用程序进程调用 &lt;code>write&lt;/code> ，发起 &lt;code>I/O 调用&lt;/code>；&lt;/li>
&lt;li>&lt;strong>CPU 拷贝&lt;/strong>：&lt;code>CPU&lt;/code> 将数据从 &lt;code>用户缓冲区（用户空间）&lt;/code> 拷贝到 &lt;code>Socket Buffer（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 将数据从 &lt;code>Socket Buffer（内核空间）&lt;/code> 拷贝到 &lt;code>网卡设备（硬件设备）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>上下文从内核态切换到用户态&lt;/strong>：&lt;code>wirte&lt;/code> 调用返回。&lt;/li>
&lt;/ol>
&lt;h2 id="零拷贝">零拷贝
&lt;/h2>&lt;p>相比 传统 I/O 调用，零拷贝通过直接拷贝数据，避免了多次拷贝操作。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>零拷贝并不是没有拷贝数据，而是减少用户态/内核态的切换次数以及CPU拷贝的次数&lt;/strong>。&lt;/p>&lt;/blockquote>
&lt;h2 id="零拷贝的实现方式">零拷贝的实现方式
&lt;/h2>&lt;h3 id="mmap--write">mmap + write
&lt;/h3>&lt;ol>
&lt;li>&lt;strong>上下文从用户态切换到内核态&lt;/strong>：应用程序进程发起 &lt;code>mmap&lt;/code> 调用；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 将数据从 &lt;code>磁盘文件（硬件设备）&lt;/code> 拷贝到 &lt;code>内核缓冲区（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>上下文从内核态切换到用户态&lt;/strong>：&lt;code>内核缓冲区（内核空间）&lt;/code> 地址和 &lt;code>用户缓冲区（用户空间）&lt;/code>地址映射，内核缓冲区和应用缓冲区共享，&lt;code>mmap&lt;/code> 调用返回；&lt;/li>
&lt;li>&lt;strong>上下文从用户态切换到内核态&lt;/strong>：应用程序进程调用 &lt;code>write&lt;/code> ，发起 &lt;code>I/O 调用&lt;/code>；&lt;/li>
&lt;li>&lt;strong>CPU 拷贝&lt;/strong>：&lt;code>CPU&lt;/code> 将数据从 &lt;code>用户缓冲区（用户空间）&lt;/code> 拷贝到 &lt;code>Socket Buffer（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 根据 &lt;strong>文件描述符信息&lt;/strong> 直接把数据从 &lt;code>内核缓冲区（内核空间）&lt;/code> 拷贝到 &lt;code>网卡设备（硬件设备）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>上下文从内核态切换到用户态&lt;/strong>：&lt;code>write&lt;/code> 调用返回。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://blog.yellster.top/p/zero-copy/mmap.png"
width="2140"
height="1274"
srcset="https://blog.yellster.top/p/zero-copy/mmap_hu_5a941f8777696c89.png 480w, https://blog.yellster.top/p/zero-copy/mmap_hu_34d26fd28530ab6.png 1024w"
loading="lazy"
alt="mmap &amp;#43; write"
class="gallery-image"
data-flex-grow="167"
data-flex-basis="403px"
>&lt;/p>
&lt;p>mmap + write 调用涉及到 &lt;strong>4 次上下文切换&lt;/strong> 和 &lt;strong>3 次数据拷贝&lt;/strong>（1 次 CPU 拷贝、2 次 DMA 拷贝）。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>mmap&lt;/code> 是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，所以节省了一次CPU拷贝，并且用户进程内存是&lt;strong>虚拟的&lt;/strong>，只是&lt;strong>映射到内核的读缓冲区&lt;/strong>，可以节省一半的内存空间。&lt;/p>&lt;/blockquote>
&lt;h3 id="sendfile">sendfile
&lt;/h3>&lt;p>sendfile表示在两个文件描述符之间传输数据，它是在 &lt;strong>操作系统内核&lt;/strong> 中操作的，&lt;strong>避免了数据从内核缓冲区和用户缓冲区之间的拷贝操作&lt;/strong>，因此可以使用它来实现零拷贝。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>上下文从用户态切换到内核态&lt;/strong>：应用程序进程发起 &lt;code>sendfile&lt;/code> 调用；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 将数据从 &lt;code>磁盘文件（硬件设备）&lt;/code> 拷贝到 &lt;code>内核缓冲区（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>CPU 拷贝&lt;/strong>：&lt;code>CPU&lt;/code> 将数据从 &lt;code>内核缓冲区（内核空间）&lt;/code> 拷贝到 &lt;code>Socket Buffer（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 将数据从 &lt;code>Socket Buffer（内核空间）&lt;/code> 拷贝到 &lt;code>网卡设备（硬件设备）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>上下文从内核态切换到用户态&lt;/strong>：&lt;code>sendfile&lt;/code> 调用返回。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://blog.yellster.top/p/zero-copy/sendfile.png"
width="1080"
height="602"
srcset="https://blog.yellster.top/p/zero-copy/sendfile_hu_e7b239b45142fd65.png 480w, https://blog.yellster.top/p/zero-copy/sendfile_hu_9c62413f8190d489.png 1024w"
loading="lazy"
alt="sendfile"
class="gallery-image"
data-flex-grow="179"
data-flex-basis="430px"
>&lt;/p>
&lt;p>相比传统 I/O 调用，&lt;code>sendfile&lt;/code> 调用涉及到 &lt;strong>2 次上下文切换&lt;/strong> 和 &lt;strong>3 次数据拷贝&lt;/strong>（1 次 CPU 拷贝、2 次 DMA 拷贝）。&lt;/p>
&lt;h3 id="sendfile--sg-dma">sendfile + SG-DMA
&lt;/h3>&lt;blockquote>
&lt;p>Linux 2.4+版本提出。&lt;/p>&lt;/blockquote>
&lt;ol>
&lt;li>&lt;strong>上下文从用户态切换到内核态&lt;/strong>：应用程序进程发起 &lt;code>sendfile&lt;/code> 调用；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 将数据从 &lt;code>磁盘文件（硬件设备）&lt;/code> 拷贝到 &lt;code>内核缓冲区（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>只拷贝文件描述符信息&lt;/strong>：&lt;code>CPU&lt;/code> 将 &lt;code>内核缓冲区（内核空间）&lt;/code> 中的 &lt;strong>文件描述符信息&lt;/strong>（包括内核缓冲区的内存地址和偏移量） 拷贝到 &lt;code>Socket Buffer（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 根据 &lt;strong>文件描述符信息&lt;/strong> 直接把数据从 &lt;code>内核缓冲区（内核空间）&lt;/code> 拷贝到 &lt;code>网卡设备（硬件设备）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>上下文从内核态切换到用户态&lt;/strong>：&lt;code>sendfile&lt;/code> 调用返回。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://blog.yellster.top/p/zero-copy/sendfile&amp;#43;SG-DMA.png"
width="1080"
height="606"
srcset="https://blog.yellster.top/p/zero-copy/sendfile&amp;#43;SG-DMA_hu_7557d5dfc97a5e05.png 480w, https://blog.yellster.top/p/zero-copy/sendfile&amp;#43;SG-DMA_hu_3efc44873afcaced.png 1024w"
loading="lazy"
alt="sendfile &amp;#43; SG-DMA"
class="gallery-image"
data-flex-grow="178"
data-flex-basis="427px"
>&lt;/p>
&lt;p>相比单独的 sendfile，&lt;code>sendfile + SG-DMA&lt;/code> 调用涉及到 &lt;strong>2 次上下文切换&lt;/strong> 和 &lt;strong>2 次数据拷贝&lt;/strong>（2 次 DMA 拷贝）。&lt;/p>
&lt;blockquote>
&lt;p>真正实现了 零拷贝，全程都没有通过CPU来搬运数据，所有的数据都是通过DMA来进行传输的。&lt;/p>&lt;/blockquote>
&lt;h3 id="对比">对比
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>方法&lt;/th>
&lt;th>上下文切换&lt;/th>
&lt;th>拷贝次数&lt;/th>
&lt;th>CPU参与&lt;/th>
&lt;th>适用场景&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>传统I/O&lt;/td>
&lt;td>4次&lt;/td>
&lt;td>4次&lt;/td>
&lt;td>2次&lt;/td>
&lt;td>通用场景（性能较低）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mmap + write&lt;/td>
&lt;td>4次&lt;/td>
&lt;td>3次&lt;/td>
&lt;td>1次&lt;/td>
&lt;td>需用户态处理数据的场景&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sendfile&lt;/td>
&lt;td>2次&lt;/td>
&lt;td>3次&lt;/td>
&lt;td>1次&lt;/td>
&lt;td>文件到网络的高性能传输&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sendfile + SG-DMA&lt;/td>
&lt;td>2次&lt;/td>
&lt;td>2次&lt;/td>
&lt;td>0次&lt;/td>
&lt;td>文件到网络的高性能传输&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="扩展">扩展
&lt;/h2>&lt;h3 id="内核空间和用户空间">内核空间和用户空间
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>内核空间&lt;/strong>：操作系统内核运行的内存区域，具有最高权限，可以直接访问硬件、内存管理、文件系统等底层资源。&lt;/li>
&lt;li>&lt;strong>用户空间&lt;/strong>：应用程序运行的内存区域，具有较低权限，只能访问受限的资源，如自己的内存、文件等，必须通过 &lt;strong>系统调用（System Call）&lt;/strong> 请求内核资源。&lt;/li>
&lt;/ul>
&lt;h4 id="地址空间划分以-32-位系统4gb-为例">&lt;strong>地址空间划分（以 32 位系统、4GB 为例）：&lt;/strong>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>内核空间&lt;/strong>：0xC0000000 ~ 0xFFFFFFFF，约占 1GB，所有进程共享，用于存放内核代码、内核数据、设备驱动等。&lt;/li>
&lt;li>&lt;strong>用户空间&lt;/strong>：0x00000000 ~ 0xBFFFFFFF，约占 3GB，每个进程独享，用于存放用户代码、用户数据、栈、堆等。&lt;/li>
&lt;/ul>
&lt;h4 id="隔离性">&lt;strong>隔离性&lt;/strong>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>安全性&lt;/strong>：防止用户程序误操作（如内存越界）导致系统崩溃。例如，用户态程序无法直接清空内存或配置硬件参数。&lt;/li>
&lt;li>&lt;strong>稳定性&lt;/strong>：若用户程序崩溃（如空指针异常），仅影响自身用户空间，内核空间仍可正常运行，保障系统其他进程。&lt;/li>
&lt;li>&lt;strong>资源管理&lt;/strong>：内核统一管理硬件资源（CPU、内存、I/O），避免用户程序直接竞争资源。&lt;/li>
&lt;/ul>
&lt;h3 id="内核态和用户态">内核态和用户态
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>内核态&lt;/strong>：操作系统内核运行的模式，具有最高权限，可直接访问硬件、内存管理、文件系统等底层资源。&lt;/li>
&lt;li>&lt;strong>用户态&lt;/strong>：应用程序运行的模式，具有较低权限，只能访问受限的资源，如自己的内存、文件等，必须通过 &lt;strong>系统调用（System Call）&lt;/strong> 请求内核资源。&lt;/li>
&lt;/ul>
&lt;h4 id="如何切换">&lt;strong>如何切换？&lt;/strong>
&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>场景&lt;/strong>&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>系统调用&lt;/strong>&lt;/td>
&lt;td>用户程序主动请求内核服务（如&lt;code>write()&lt;/code>），通过&lt;code>int 0x80&lt;/code>指令触发切换。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>异常&lt;/strong>&lt;/td>
&lt;td>CPU执行用户程序时发生错误（如缺页异常），强制切换到内核态处理。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>硬件中断&lt;/strong>&lt;/td>
&lt;td>外设完成操作后（如磁盘I/O完成），中断信号触发切换。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>用户态 → 内核态&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>执行特权指令（如&lt;code>int 0x80&lt;/code>），CPU切换到Ring 0。&lt;/li>
&lt;li>保存用户态现场（寄存器、用户栈指针）到内核栈。&lt;/li>
&lt;li>执行内核代码（如系统调用处理程序）。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>内核态 → 用户态&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>内核代码执行完毕（如文件写入完成）。&lt;/li>
&lt;li>恢复用户态现场（从内核栈加载寄存器、用户栈指针）。&lt;/li>
&lt;li>通过&lt;code>sysret&lt;/code>指令切换回Ring 3，继续用户程序。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>示例&lt;/strong>：用户程序调用&lt;code>write()&lt;/code>写入文件时：&lt;/p>
&lt;ol>
&lt;li>用户态程序通过库函数触发系统调用。&lt;/li>
&lt;li>CPU切换到内核态，保存用户栈到内核栈。&lt;/li>
&lt;li>内核执行文件写入，完成后恢复用户栈。&lt;/li>
&lt;li>CPU切换回用户态，程序继续执行。&lt;/li>
&lt;/ol>&lt;/blockquote>
&lt;h3 id="微内核和宏内核">微内核和宏内核
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>微内核（Micro Kernel）&lt;/strong>：
&lt;ul>
&lt;li>一种精简的内核设计，仅包含操作系统最基本的核心功能，如进程管理、线程管理、IPC和基本的内存管理。&lt;/li>
&lt;li>其他操作系统功能，如设备驱动、文件系统和网络协议等，则以用户态进程的形式运行。这种设计使得内核代码量小、结构清晰，便于扩展和维护，同时提高了系统的稳定性和安全性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>宏内核（Monolithic Kernel）&lt;/strong>：
&lt;ul>
&lt;li>一种将大部分操作系统功能（如进程管理、内存管理、设备驱动、文件系统等）集成在一个大内核中的设计。&lt;/li>
&lt;li>所有这些功能都运行在内核空间，通过函数调用直接交互。这种设计使得系统性能较高，因为减少了上下文切换和IPC的开销，但内核代码庞大且复杂，维护困难，且一个模块的崩溃可能导致整个系统崩溃。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>主要区别&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>结构设计&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>微内核&lt;/strong> 将大部分功能分离到用户空间，通过IPC通信；&lt;/li>
&lt;li>&lt;strong>宏内核&lt;/strong> 将所有功能集成在内核空间，通过函数调用通信；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>性能&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>微内核&lt;/strong> 由于频繁的IPC和上下文切换，性能可能较低；&lt;/li>
&lt;li>&lt;strong>宏内核&lt;/strong> 通常性能更高，因为减少了IPC开销；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>稳定性和安全性&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>微内核&lt;/strong> 由于内核代码少，攻击面小，且服务隔离，稳定性更高；&lt;/li>
&lt;li>&lt;strong>宏内核&lt;/strong> 由于功能集中，一个模块的崩溃可能导致整个系统崩溃；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>扩展性和维护&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>微内核&lt;/strong> 的模块化设计便于扩展和维护；&lt;/li>
&lt;li>&lt;strong>宏内核&lt;/strong> 由于代码复杂，维护和扩展较为困难。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>典型例子&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>微内核&lt;/strong>：QNX、Minix、华为鸿蒙系统；&lt;/li>
&lt;li>&lt;strong>宏内核&lt;/strong>：Linux、传统的Unix系统、Windows。&lt;/li>
&lt;/ul>
&lt;h3 id="上下文切换">上下文切换
&lt;/h3>&lt;p>&lt;strong>上下文切换&lt;/strong> 是操作系统在CPU核心上切换任务执行状态的过程，具体包括：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>保存当前任务状态&lt;/strong>：用户态虚拟内存、寄存器、程序计数器、内核堆栈等。&lt;/li>
&lt;li>&lt;strong>加载新任务状态&lt;/strong>：从内核的进程控制块（PCB）中恢复新任务的资源。&lt;/li>
&lt;li>&lt;strong>触发条件&lt;/strong>：进程调度（时间片耗尽、I/O完成）、线程切换、中断响应等。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>关键点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>系统调用会触发两次上下文切换（用户态→内核态→用户态），但&lt;strong>不涉及进程切换&lt;/strong>。&lt;/li>
&lt;li>切换耗时：每次约几十纳秒到数微秒，高频切换会显著降低CPU利用率。&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>类型&lt;/strong>&lt;/th>
&lt;th>&lt;strong>触发场景&lt;/strong>&lt;/th>
&lt;th>&lt;strong>涉及资源&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>进程切换&lt;/strong>&lt;/td>
&lt;td>多进程竞争CPU（时间片耗尽、进程终止、资源等待）&lt;/td>
&lt;td>用户态虚拟内存、内核堆栈、寄存器、全局变量（需完全切换）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>线程切换&lt;/strong>&lt;/td>
&lt;td>多线程共享进程资源（同进程内线程切换更高效）&lt;/td>
&lt;td>仅切换线程私有数据（寄存器、栈），共享进程虚拟内存和全局变量&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>中断切换&lt;/strong>&lt;/td>
&lt;td>硬件中断（如I/O完成、定时器中断）触发内核中断服务程序（ISR）&lt;/td>
&lt;td>仅内核态资源（寄存器、内核堆栈），不涉及用户态资源&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>&lt;strong>进程切换耗时更高&lt;/strong>：需刷新TLB（Translation Lookaside Buffer），导致内存访问延迟。&lt;/li>
&lt;li>&lt;strong>线程切换更轻量&lt;/strong>：共享虚拟内存，无需刷新TLB，耗时约为进程切换的1/10。&lt;/li>
&lt;/ul>
&lt;h3 id="dma">DMA
&lt;/h3>&lt;p>&lt;strong>DMA（Direct Memory Access，直接内存访问）&lt;/strong> 是一种硬件机制，允许外设直接与计算机内存交换数据，&lt;strong>不需要 CPU 介入每一步拷贝&lt;/strong>。它是现代计算机系统中提升效率、减少CPU占用率的核心技术。&lt;/p>
&lt;p>&lt;strong>以从磁盘读取数据到内存为例&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>传统数据传输&lt;/strong>：
&lt;ol>
&lt;li>CPU发送读取命令；&lt;/li>
&lt;li>磁盘将数据读取到设备侧的 &lt;strong>内部缓冲区（Buffer）&lt;/strong> 中；&lt;/li>
&lt;li>CPU 通过 &lt;strong>轮询或中断&lt;/strong> 方式获取数据，&lt;strong>逐字节或逐块&lt;/strong> 读取设备 Buffer 中的数据，再写入内存；&lt;/li>
&lt;li>在数据传输期间，&lt;strong>CPU 需持续参与搬运工作，无法执行其他任务&lt;/strong>，效率较低。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>DMA 数据传输&lt;/strong>：
&lt;ol>
&lt;li>CPU发送读取命令，并配置 DMA 控制器（源地址、目的地址、数据长度）；&lt;/li>
&lt;li>磁盘将数据读取到设备缓冲区；&lt;/li>
&lt;li>DMA控制器 &lt;strong>自动将数据从设备 Buffer 直接写入内存&lt;/strong>，无需 CPU 参与；&lt;/li>
&lt;li>传输完成后，DMA 发出 &lt;strong>中断通知&lt;/strong> CPU，&lt;strong>CPU 可在此期间处理其他任务&lt;/strong>，整体效率显著提升。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://blog.yellster.top/p/zero-copy/DMA.png"
width="1080"
height="525"
srcset="https://blog.yellster.top/p/zero-copy/DMA_hu_9dc8951193a0bfda.png 480w, https://blog.yellster.top/p/zero-copy/DMA_hu_be4799bd5e34cdde.png 1024w"
loading="lazy"
alt="DMA"
class="gallery-image"
data-flex-grow="205"
data-flex-basis="493px"
>&lt;/p></description></item></channel></rss>