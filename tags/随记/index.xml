<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>随记 on Yellster - Blog</title><link>https://blog.yellster.top/tags/%E9%9A%8F%E8%AE%B0/</link><description>Recent content in 随记 on Yellster - Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>xyp_selune@163.com (Yellster)</managingEditor><webMaster>xyp_selune@163.com (Yellster)</webMaster><lastBuildDate>Mon, 21 Apr 2025 17:56:08 +0800</lastBuildDate><atom:link href="https://blog.yellster.top/tags/%E9%9A%8F%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>第一性原理</title><link>https://blog.yellster.top/p/first-principle/</link><pubDate>Mon, 21 Apr 2025 17:56:08 +0800</pubDate><author>xyp_selune@163.com (Yellster)</author><guid>https://blog.yellster.top/p/first-principle/</guid><description>&lt;img src="https://blog.yellster.top/p/first-principle/%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86.webp" alt="Featured image of post 第一性原理" />&lt;h2 id="什么是第一性原理">什么是第一性原理？
&lt;/h2>&lt;p>&lt;strong>第一性原理（First Principles）&lt;/strong> 是一种从最基本、最本质的层面思考问题的方法，要求我们抛开所有假设和成见，从最基础的真理出发重新构建认知。这种思维方式强调从根本问题出发，剖析和理解事物本质，而不是依赖传统认知或经验。&lt;/p>
&lt;h3 id="起源">起源
&lt;/h3>&lt;ul>
&lt;li>第一性原理的概念最早可以追溯到&lt;strong>亚里士多德&lt;/strong>的哲学思想。&lt;/li>
&lt;li>他认为，在任何系统中，都存在一些最基本的命题或假设，这些命题不能进一步简化或从其他命题推导出来。&lt;/li>
&lt;li>这些基本命题构成了所有知识的基础，是我们认知的出发点。&lt;/li>
&lt;/ul>
&lt;h3 id="与传统思维的区别">与传统思维的区别
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>类比思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>基于已知经验，寻找相似性，容易受限于现有认知，创新性有限。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第一性原理思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>回归本质，剖析问题的基本组成要素，突破认知局限，有可能产生突破性的创新。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="实际应用案例">实际应用案例
&lt;/h2>&lt;h3 id="特斯拉的电池革新">特斯拉的电池革新
&lt;/h3>&lt;p>马斯克运用第一性原理思维降低电池成本：&lt;/p>
&lt;ol>
&lt;li>不是直接压缩现有电池的利润空间。&lt;/li>
&lt;li>而是从最基本的组成材料（如锂、钴、镍等）入手。&lt;/li>
&lt;li>通过分析原材料的成本，重新设计生产流程。&lt;/li>
&lt;li>最终成功将电池成本降低约50%。&lt;/li>
&lt;/ol>
&lt;h3 id="spacex-的火箭研发">SpaceX 的火箭研发
&lt;/h3>&lt;p>传统思维：火箭很贵，因为&amp;quot;火箭一直都很贵&amp;quot;&lt;/p>
&lt;p>运用第一性原理：&lt;/p>
&lt;ol>
&lt;li>分析火箭的基本组成材料，计算原材料成本。&lt;/li>
&lt;li>重新设计火箭制造流程。&lt;/li>
&lt;li>通过实现可重复使用的火箭，大幅降低了发射成本。&lt;/li>
&lt;/ol>
&lt;h2 id="如何运用第一性原理">如何运用第一性原理
&lt;/h2>&lt;h3 id="基本步骤">基本步骤
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>识别问题&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>明确要解决的核心问题，避免被表象迷惑。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>拆解组成&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>将问题拆解为最基本的要素，识别关键变量和约束条件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>重新构建&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>从基本要素出发，构建新的解决方案，探索创新的方法。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>验证方案&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>测试新方案的可行性，并持续优化改进。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="注意事项">注意事项
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>避免过度简化&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>确保不遗漏重要因素，避免忽视系统复杂性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>平衡效率&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>不是所有问题都需要追溯到最基础层面，视情况决定是否采用第一性原理思维。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>保持开放性&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>不断质疑现有认知，愿意接受新的可能性和解决方案。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="应用领域">应用领域
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>技术创新&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>通过第一性原理突破技术瓶颈，开发新产品或技术。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>商业模式&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>重新定义市场、颠覆传统商业模式，创造新的商业机会。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>问题解决&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>解决复杂技术问题，优化现有流程。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>个人成长&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>在个人学习和职业发展中，突破思维局限，找到更高效的成长路径。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="在软件开发中的应用">在软件开发中的应用
&lt;/h2>&lt;h3 id="1-编程语言设计">1. 编程语言设计
&lt;/h3>&lt;p>&lt;strong>传统思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>借鉴已有语言的特性，模仿流行语言的语法结构。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第一性原理思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>深入思考编程语言的本质：人与机器的沟通桥梁。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分析目标用户的实际需求，设计符合需求的语言特性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>例如&lt;strong>Rust语言&lt;/strong>，从系统编程的基本需求出发，设计了&lt;strong>所有权&lt;/strong>、&lt;strong>借用&lt;/strong>和&lt;strong>生命周期&lt;/strong>等独特特性，以确保内存安全和高效并发。&lt;/p>
&lt;p>&lt;strong>&lt;a class="link" href="https://blog.yellster.top/p/ownership/" >Rust的所有权模型&lt;/a>&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>所有权&lt;/strong>确保每个值只能有一个所有者，这使得内存管理变得更可控，避免了内存泄漏和悬挂指针的问题。&lt;/li>
&lt;li>&lt;strong>借用&lt;/strong>和&lt;strong>生命周期&lt;/strong>的概念，使得Rust能够通过编译时检查，确保数据不会在不合法的情况下被访问。&lt;/li>
&lt;li>这些设计原则并不是简单模仿其他语言，而是从解决内存安全和并发编程的基本问题出发，重新构建了语言的核心特性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-系统架构设计">2. 系统架构设计
&lt;/h3>&lt;p>&lt;strong>传统思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>采用流行架构模式，照搬热门技术栈或成功案例。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第一性原理思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>分析业务的本质需求，考虑系统的基本约束（性能、可用性、扩展性、维护成本等）。&lt;/li>
&lt;li>从零开始设计最适合的架构，确保架构的灵活性和可维护性。&lt;/li>
&lt;li>例如，&lt;strong>微服务架构&lt;/strong>的选择不是因为它流行，而是基于以下分析：业务模块的独立性、团队协作效率、系统扩展需求、维护成本等。&lt;/li>
&lt;/ul>
&lt;h3 id="3-代码重构">3. 代码重构
&lt;/h3>&lt;p>&lt;strong>传统思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>简单修补问题代码，堆积临时解决方案。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第一性原理思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>理解代码的核心功能，识别根本的设计问题。&lt;/li>
&lt;li>从根本上重新设计代码，遵循&lt;a class="link" href="https://blog.yellster.top/p/design-principles/" >设计原则&lt;/a>（如单一职责、开闭原则、依赖倒置等）。&lt;/li>
&lt;/ul>
&lt;h3 id="4-问题调试">4. 问题调试
&lt;/h3>&lt;p>&lt;strong>传统思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>基于经验猜测问题，尝试常见解决方案，修复表面症状。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第一性原理思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>理解系统的工作原理，收集诊断数据，分析问题根本原因。&lt;/li>
&lt;li>设计全面的解决方案，如在 &lt;strong>&lt;a class="link" href="https://blog.yellster.top/p/performance-optimization/" >性能优化&lt;/a>&lt;/strong> 中，通过分析性能瓶颈的本质，优化算法和数据结构，而非简单依赖缓存或硬件升级。&lt;/li>
&lt;/ul>
&lt;h3 id="5-技术选型">5. 技术选型
&lt;/h3>&lt;p>&lt;strong>传统思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>选择流行技术，跟随大公司的技术栈或盲目采用新技术。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第一性原理思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>基于项目的实际需求、团队能力、维护成本等因素评估技术选型。&lt;/li>
&lt;li>评估技术的本质特性，选择最适合的技术，而非仅仅追求“潮流”。&lt;/li>
&lt;/ul>
&lt;h3 id="实践建议">实践建议
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>培养基础思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>深入学习计算机基础理论，掌握核心算法和数据结构。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>问题分析&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>在解决问题时，不急于采用现成方案，先深刻理解问题本质，分析基本约束和需求。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>方案设计&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>从基本原则出发，设计简洁且可维护的解决方案，注重系统的扩展性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>持续优化&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>定期回顾和重构代码，关注系统的健康度，避免技术债务积累。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="总结">总结
&lt;/h3>&lt;p>运用&lt;strong>第一性原理&lt;/strong>思维，在软件开发中能够帮助我们：&lt;/p>
&lt;ul>
&lt;li>设计出更加优雅和高效的解决方案。&lt;/li>
&lt;li>构建更加可靠、可扩展的系统架构。&lt;/li>
&lt;li>编写更易维护的代码，解决更复杂的技术问题。&lt;/li>
&lt;/ul>
&lt;p>这种思维方式要求我们投入更多的时间和精力，但它所带来的长期收益是无可比拟的。因此，掌握并运用第一性原理，将是每个优秀开发者必须具备的能力。&lt;/p></description></item><item><title>零拷贝</title><link>https://blog.yellster.top/p/zero-copy/</link><pubDate>Sat, 21 Sep 2024 16:09:09 +0800</pubDate><author>xyp_selune@163.com (Yellster)</author><guid>https://blog.yellster.top/p/zero-copy/</guid><description>&lt;img src="https://blog.yellster.top/p/zero-copy/zero-copy.png" alt="Featured image of post 零拷贝" />&lt;p>&lt;strong>​零拷贝（Zero-Copy）&lt;/strong> 是一种操作系统级别的 I/O 优化技术，旨在减少或避免数据在内存中的多次拷贝，降低 CPU 占用率，提高数据传输效率，尤其适用于高并发、大吞吐量的场景，如网络通信、文件传输等。&lt;/p>
&lt;h2 id="传统-io-的调用">传统 I/O 的调用
&lt;/h2>&lt;p>传统 I/O 操作中，数据需要从磁盘文件拷贝到内核空间，再从内核空间拷贝到用户空间，然后再拷贝到 &lt;code>Socket Buffer&lt;/code> 中，再拷贝到网卡设备。&lt;/p>
&lt;p>&lt;img src="https://blog.yellster.top/p/zero-copy/%E4%BC%A0%E7%BB%9F%E6%8B%B7%E8%B4%9D.png"
width="1080"
height="607"
srcset="https://blog.yellster.top/p/zero-copy/%E4%BC%A0%E7%BB%9F%E6%8B%B7%E8%B4%9D_hu_f7b29adf1e79d7de.png 480w, https://blog.yellster.top/p/zero-copy/%E4%BC%A0%E7%BB%9F%E6%8B%B7%E8%B4%9D_hu_d56501e2b550c485.png 1024w"
loading="lazy"
alt="传统拷贝"
class="gallery-image"
data-flex-grow="177"
data-flex-basis="427px"
>&lt;/p>
&lt;p>传统的 I/O 操作过程中，涉及到 &lt;strong>4 次上下文切换&lt;/strong>（用户态和内核态的上下文切换）和 &lt;strong>4 次数据拷贝&lt;/strong>（2 次 CPU 拷贝、2 次 DMA 拷贝）：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>上下文从用户态切换到内核态&lt;/strong>：应用程序进程调用 &lt;code>read&lt;/code> ，发起 &lt;code>I/O 调用&lt;/code>；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 将数据从 &lt;code>磁盘文件（硬件设备）&lt;/code> 拷贝到 &lt;code>内核缓冲区（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>上下文从内核态切换到用户态&lt;/strong>：&lt;code>read&lt;/code> 调用返回；&lt;/li>
&lt;li>&lt;strong>CPU 拷贝&lt;/strong>：&lt;code>CPU&lt;/code> 将数据从 &lt;code>内核缓冲区（内核空间）&lt;/code> 拷贝到 &lt;code>用户缓冲区（用户空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>上下文从用户态切换到内核态&lt;/strong>：应用程序进程调用 &lt;code>write&lt;/code> ，发起 &lt;code>I/O 调用&lt;/code>；&lt;/li>
&lt;li>&lt;strong>CPU 拷贝&lt;/strong>：&lt;code>CPU&lt;/code> 将数据从 &lt;code>用户缓冲区（用户空间）&lt;/code> 拷贝到 &lt;code>Socket Buffer（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 将数据从 &lt;code>Socket Buffer（内核空间）&lt;/code> 拷贝到 &lt;code>网卡设备（硬件设备）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>上下文从内核态切换到用户态&lt;/strong>：&lt;code>wirte&lt;/code> 调用返回。&lt;/li>
&lt;/ol>
&lt;h2 id="零拷贝">零拷贝
&lt;/h2>&lt;p>相比 传统 I/O 调用，零拷贝通过直接拷贝数据，避免了多次拷贝操作。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>零拷贝并不是没有拷贝数据，而是减少用户态/内核态的切换次数以及CPU拷贝的次数&lt;/strong>。&lt;/p>&lt;/blockquote>
&lt;h2 id="零拷贝的实现方式">零拷贝的实现方式
&lt;/h2>&lt;h3 id="mmap--write">mmap + write
&lt;/h3>&lt;ol>
&lt;li>&lt;strong>上下文从用户态切换到内核态&lt;/strong>：应用程序进程发起 &lt;code>mmap&lt;/code> 调用；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 将数据从 &lt;code>磁盘文件（硬件设备）&lt;/code> 拷贝到 &lt;code>内核缓冲区（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>上下文从内核态切换到用户态&lt;/strong>：&lt;code>内核缓冲区（内核空间）&lt;/code> 地址和 &lt;code>用户缓冲区（用户空间）&lt;/code>地址映射，内核缓冲区和应用缓冲区共享，&lt;code>mmap&lt;/code> 调用返回；&lt;/li>
&lt;li>&lt;strong>上下文从用户态切换到内核态&lt;/strong>：应用程序进程调用 &lt;code>write&lt;/code> ，发起 &lt;code>I/O 调用&lt;/code>；&lt;/li>
&lt;li>&lt;strong>CPU 拷贝&lt;/strong>：&lt;code>CPU&lt;/code> 将数据从 &lt;code>用户缓冲区（用户空间）&lt;/code> 拷贝到 &lt;code>Socket Buffer（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 根据 &lt;strong>文件描述符信息&lt;/strong> 直接把数据从 &lt;code>内核缓冲区（内核空间）&lt;/code> 拷贝到 &lt;code>网卡设备（硬件设备）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>上下文从内核态切换到用户态&lt;/strong>：&lt;code>write&lt;/code> 调用返回。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://blog.yellster.top/p/zero-copy/mmap.png"
width="2140"
height="1274"
srcset="https://blog.yellster.top/p/zero-copy/mmap_hu_5a941f8777696c89.png 480w, https://blog.yellster.top/p/zero-copy/mmap_hu_34d26fd28530ab6.png 1024w"
loading="lazy"
alt="mmap &amp;#43; write"
class="gallery-image"
data-flex-grow="167"
data-flex-basis="403px"
>&lt;/p>
&lt;p>mmap + write 调用涉及到 &lt;strong>4 次上下文切换&lt;/strong> 和 &lt;strong>3 次数据拷贝&lt;/strong>（1 次 CPU 拷贝、2 次 DMA 拷贝）。&lt;/p>
&lt;blockquote>
&lt;p>&lt;code>mmap&lt;/code> 是将读缓冲区的地址和用户缓冲区的地址进行映射，内核缓冲区和应用缓冲区共享，所以节省了一次CPU拷贝，并且用户进程内存是&lt;strong>虚拟的&lt;/strong>，只是&lt;strong>映射到内核的读缓冲区&lt;/strong>，可以节省一半的内存空间。&lt;/p>&lt;/blockquote>
&lt;h3 id="sendfile">sendfile
&lt;/h3>&lt;p>sendfile表示在两个文件描述符之间传输数据，它是在 &lt;strong>操作系统内核&lt;/strong> 中操作的，&lt;strong>避免了数据从内核缓冲区和用户缓冲区之间的拷贝操作&lt;/strong>，因此可以使用它来实现零拷贝。&lt;/p>
&lt;ol>
&lt;li>&lt;strong>上下文从用户态切换到内核态&lt;/strong>：应用程序进程发起 &lt;code>sendfile&lt;/code> 调用；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 将数据从 &lt;code>磁盘文件（硬件设备）&lt;/code> 拷贝到 &lt;code>内核缓冲区（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>CPU 拷贝&lt;/strong>：&lt;code>CPU&lt;/code> 将数据从 &lt;code>内核缓冲区（内核空间）&lt;/code> 拷贝到 &lt;code>Socket Buffer（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 将数据从 &lt;code>Socket Buffer（内核空间）&lt;/code> 拷贝到 &lt;code>网卡设备（硬件设备）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>上下文从内核态切换到用户态&lt;/strong>：&lt;code>sendfile&lt;/code> 调用返回。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://blog.yellster.top/p/zero-copy/sendfile.png"
width="1080"
height="602"
srcset="https://blog.yellster.top/p/zero-copy/sendfile_hu_e7b239b45142fd65.png 480w, https://blog.yellster.top/p/zero-copy/sendfile_hu_9c62413f8190d489.png 1024w"
loading="lazy"
alt="sendfile"
class="gallery-image"
data-flex-grow="179"
data-flex-basis="430px"
>&lt;/p>
&lt;p>相比传统 I/O 调用，&lt;code>sendfile&lt;/code> 调用涉及到 &lt;strong>2 次上下文切换&lt;/strong> 和 &lt;strong>3 次数据拷贝&lt;/strong>（1 次 CPU 拷贝、2 次 DMA 拷贝）。&lt;/p>
&lt;h3 id="sendfile--sg-dma">sendfile + SG-DMA
&lt;/h3>&lt;blockquote>
&lt;p>Linux 2.4+版本提出。&lt;/p>&lt;/blockquote>
&lt;ol>
&lt;li>&lt;strong>上下文从用户态切换到内核态&lt;/strong>：应用程序进程发起 &lt;code>sendfile&lt;/code> 调用；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 将数据从 &lt;code>磁盘文件（硬件设备）&lt;/code> 拷贝到 &lt;code>内核缓冲区（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>只拷贝文件描述符信息&lt;/strong>：&lt;code>CPU&lt;/code> 将 &lt;code>内核缓冲区（内核空间）&lt;/code> 中的 &lt;strong>文件描述符信息&lt;/strong>（包括内核缓冲区的内存地址和偏移量） 拷贝到 &lt;code>Socket Buffer（内核空间）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>DMA 拷贝&lt;/strong>：&lt;code>DMA 控制器&lt;/code> 根据 &lt;strong>文件描述符信息&lt;/strong> 直接把数据从 &lt;code>内核缓冲区（内核空间）&lt;/code> 拷贝到 &lt;code>网卡设备（硬件设备）&lt;/code>；&lt;/li>
&lt;li>&lt;strong>上下文从内核态切换到用户态&lt;/strong>：&lt;code>sendfile&lt;/code> 调用返回。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://blog.yellster.top/p/zero-copy/sendfile&amp;#43;SG-DMA.png"
width="1080"
height="606"
srcset="https://blog.yellster.top/p/zero-copy/sendfile&amp;#43;SG-DMA_hu_7557d5dfc97a5e05.png 480w, https://blog.yellster.top/p/zero-copy/sendfile&amp;#43;SG-DMA_hu_3efc44873afcaced.png 1024w"
loading="lazy"
alt="sendfile &amp;#43; SG-DMA"
class="gallery-image"
data-flex-grow="178"
data-flex-basis="427px"
>&lt;/p>
&lt;p>相比单独的 sendfile，&lt;code>sendfile + SG-DMA&lt;/code> 调用涉及到 &lt;strong>2 次上下文切换&lt;/strong> 和 &lt;strong>2 次数据拷贝&lt;/strong>（2 次 DMA 拷贝）。&lt;/p>
&lt;blockquote>
&lt;p>真正实现了 零拷贝，全程都没有通过CPU来搬运数据，所有的数据都是通过DMA来进行传输的。&lt;/p>&lt;/blockquote>
&lt;h3 id="对比">对比
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>方法&lt;/th>
&lt;th>上下文切换&lt;/th>
&lt;th>拷贝次数&lt;/th>
&lt;th>CPU参与&lt;/th>
&lt;th>适用场景&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>传统I/O&lt;/td>
&lt;td>4次&lt;/td>
&lt;td>4次&lt;/td>
&lt;td>2次&lt;/td>
&lt;td>通用场景（性能较低）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>mmap + write&lt;/td>
&lt;td>4次&lt;/td>
&lt;td>3次&lt;/td>
&lt;td>1次&lt;/td>
&lt;td>需用户态处理数据的场景&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sendfile&lt;/td>
&lt;td>2次&lt;/td>
&lt;td>3次&lt;/td>
&lt;td>1次&lt;/td>
&lt;td>文件到网络的高性能传输&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>sendfile + SG-DMA&lt;/td>
&lt;td>2次&lt;/td>
&lt;td>2次&lt;/td>
&lt;td>0次&lt;/td>
&lt;td>文件到网络的高性能传输&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="扩展">扩展
&lt;/h2>&lt;h3 id="内核空间和用户空间">内核空间和用户空间
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>内核空间&lt;/strong>：操作系统内核运行的内存区域，具有最高权限，可以直接访问硬件、内存管理、文件系统等底层资源。&lt;/li>
&lt;li>&lt;strong>用户空间&lt;/strong>：应用程序运行的内存区域，具有较低权限，只能访问受限的资源，如自己的内存、文件等，必须通过 &lt;strong>系统调用（System Call）&lt;/strong> 请求内核资源。&lt;/li>
&lt;/ul>
&lt;h4 id="地址空间划分以-32-位系统4gb-为例">&lt;strong>地址空间划分（以 32 位系统、4GB 为例）：&lt;/strong>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>内核空间&lt;/strong>：0xC0000000 ~ 0xFFFFFFFF，约占 1GB，所有进程共享，用于存放内核代码、内核数据、设备驱动等。&lt;/li>
&lt;li>&lt;strong>用户空间&lt;/strong>：0x00000000 ~ 0xBFFFFFFF，约占 3GB，每个进程独享，用于存放用户代码、用户数据、栈、堆等。&lt;/li>
&lt;/ul>
&lt;h4 id="隔离性">&lt;strong>隔离性&lt;/strong>
&lt;/h4>&lt;ul>
&lt;li>&lt;strong>安全性&lt;/strong>：防止用户程序误操作（如内存越界）导致系统崩溃。例如，用户态程序无法直接清空内存或配置硬件参数。&lt;/li>
&lt;li>&lt;strong>稳定性&lt;/strong>：若用户程序崩溃（如空指针异常），仅影响自身用户空间，内核空间仍可正常运行，保障系统其他进程。&lt;/li>
&lt;li>&lt;strong>资源管理&lt;/strong>：内核统一管理硬件资源（CPU、内存、I/O），避免用户程序直接竞争资源。&lt;/li>
&lt;/ul>
&lt;h3 id="内核态和用户态">内核态和用户态
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>内核态&lt;/strong>：操作系统内核运行的模式，具有最高权限，可直接访问硬件、内存管理、文件系统等底层资源。&lt;/li>
&lt;li>&lt;strong>用户态&lt;/strong>：应用程序运行的模式，具有较低权限，只能访问受限的资源，如自己的内存、文件等，必须通过 &lt;strong>系统调用（System Call）&lt;/strong> 请求内核资源。&lt;/li>
&lt;/ul>
&lt;h4 id="如何切换">&lt;strong>如何切换？&lt;/strong>
&lt;/h4>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>场景&lt;/strong>&lt;/th>
&lt;th>描述&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>系统调用&lt;/strong>&lt;/td>
&lt;td>用户程序主动请求内核服务（如&lt;code>write()&lt;/code>），通过&lt;code>int 0x80&lt;/code>指令触发切换。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>异常&lt;/strong>&lt;/td>
&lt;td>CPU执行用户程序时发生错误（如缺页异常），强制切换到内核态处理。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>硬件中断&lt;/strong>&lt;/td>
&lt;td>外设完成操作后（如磁盘I/O完成），中断信号触发切换。&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>用户态 → 内核态&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>执行特权指令（如&lt;code>int 0x80&lt;/code>），CPU切换到Ring 0。&lt;/li>
&lt;li>保存用户态现场（寄存器、用户栈指针）到内核栈。&lt;/li>
&lt;li>执行内核代码（如系统调用处理程序）。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>内核态 → 用户态&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>内核代码执行完毕（如文件写入完成）。&lt;/li>
&lt;li>恢复用户态现场（从内核栈加载寄存器、用户栈指针）。&lt;/li>
&lt;li>通过&lt;code>sysret&lt;/code>指令切换回Ring 3，继续用户程序。&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;strong>示例&lt;/strong>：用户程序调用&lt;code>write()&lt;/code>写入文件时：&lt;/p>
&lt;ol>
&lt;li>用户态程序通过库函数触发系统调用。&lt;/li>
&lt;li>CPU切换到内核态，保存用户栈到内核栈。&lt;/li>
&lt;li>内核执行文件写入，完成后恢复用户栈。&lt;/li>
&lt;li>CPU切换回用户态，程序继续执行。&lt;/li>
&lt;/ol>&lt;/blockquote>
&lt;h3 id="微内核和宏内核">微内核和宏内核
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>微内核（Micro Kernel）&lt;/strong>：
&lt;ul>
&lt;li>一种精简的内核设计，仅包含操作系统最基本的核心功能，如进程管理、线程管理、IPC和基本的内存管理。&lt;/li>
&lt;li>其他操作系统功能，如设备驱动、文件系统和网络协议等，则以用户态进程的形式运行。这种设计使得内核代码量小、结构清晰，便于扩展和维护，同时提高了系统的稳定性和安全性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>宏内核（Monolithic Kernel）&lt;/strong>：
&lt;ul>
&lt;li>一种将大部分操作系统功能（如进程管理、内存管理、设备驱动、文件系统等）集成在一个大内核中的设计。&lt;/li>
&lt;li>所有这些功能都运行在内核空间，通过函数调用直接交互。这种设计使得系统性能较高，因为减少了上下文切换和IPC的开销，但内核代码庞大且复杂，维护困难，且一个模块的崩溃可能导致整个系统崩溃。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>主要区别&lt;/strong>：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>结构设计&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>微内核&lt;/strong> 将大部分功能分离到用户空间，通过IPC通信；&lt;/li>
&lt;li>&lt;strong>宏内核&lt;/strong> 将所有功能集成在内核空间，通过函数调用通信；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>性能&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>微内核&lt;/strong> 由于频繁的IPC和上下文切换，性能可能较低；&lt;/li>
&lt;li>&lt;strong>宏内核&lt;/strong> 通常性能更高，因为减少了IPC开销；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>稳定性和安全性&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>微内核&lt;/strong> 由于内核代码少，攻击面小，且服务隔离，稳定性更高；&lt;/li>
&lt;li>&lt;strong>宏内核&lt;/strong> 由于功能集中，一个模块的崩溃可能导致整个系统崩溃；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>扩展性和维护&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>微内核&lt;/strong> 的模块化设计便于扩展和维护；&lt;/li>
&lt;li>&lt;strong>宏内核&lt;/strong> 由于代码复杂，维护和扩展较为困难。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>典型例子&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>微内核&lt;/strong>：QNX、Minix、华为鸿蒙系统；&lt;/li>
&lt;li>&lt;strong>宏内核&lt;/strong>：Linux、传统的Unix系统、Windows。&lt;/li>
&lt;/ul>
&lt;h3 id="上下文切换">上下文切换
&lt;/h3>&lt;p>&lt;strong>上下文切换&lt;/strong> 是操作系统在CPU核心上切换任务执行状态的过程，具体包括：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>保存当前任务状态&lt;/strong>：用户态虚拟内存、寄存器、程序计数器、内核堆栈等。&lt;/li>
&lt;li>&lt;strong>加载新任务状态&lt;/strong>：从内核的进程控制块（PCB）中恢复新任务的资源。&lt;/li>
&lt;li>&lt;strong>触发条件&lt;/strong>：进程调度（时间片耗尽、I/O完成）、线程切换、中断响应等。&lt;/li>
&lt;/ol>
&lt;p>&lt;strong>关键点&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>系统调用会触发两次上下文切换（用户态→内核态→用户态），但&lt;strong>不涉及进程切换&lt;/strong>。&lt;/li>
&lt;li>切换耗时：每次约几十纳秒到数微秒，高频切换会显著降低CPU利用率。&lt;/li>
&lt;/ul>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;strong>类型&lt;/strong>&lt;/th>
&lt;th>&lt;strong>触发场景&lt;/strong>&lt;/th>
&lt;th>&lt;strong>涉及资源&lt;/strong>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>进程切换&lt;/strong>&lt;/td>
&lt;td>多进程竞争CPU（时间片耗尽、进程终止、资源等待）&lt;/td>
&lt;td>用户态虚拟内存、内核堆栈、寄存器、全局变量（需完全切换）&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>线程切换&lt;/strong>&lt;/td>
&lt;td>多线程共享进程资源（同进程内线程切换更高效）&lt;/td>
&lt;td>仅切换线程私有数据（寄存器、栈），共享进程虚拟内存和全局变量&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>中断切换&lt;/strong>&lt;/td>
&lt;td>硬件中断（如I/O完成、定时器中断）触发内核中断服务程序（ISR）&lt;/td>
&lt;td>仅内核态资源（寄存器、内核堆栈），不涉及用户态资源&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>&lt;strong>进程切换耗时更高&lt;/strong>：需刷新TLB（Translation Lookaside Buffer），导致内存访问延迟。&lt;/li>
&lt;li>&lt;strong>线程切换更轻量&lt;/strong>：共享虚拟内存，无需刷新TLB，耗时约为进程切换的1/10。&lt;/li>
&lt;/ul>
&lt;h3 id="dma">DMA
&lt;/h3>&lt;p>&lt;strong>DMA（Direct Memory Access，直接内存访问）&lt;/strong> 是一种硬件机制，允许外设直接与计算机内存交换数据，&lt;strong>不需要 CPU 介入每一步拷贝&lt;/strong>。它是现代计算机系统中提升效率、减少CPU占用率的核心技术。&lt;/p>
&lt;p>&lt;strong>以从磁盘读取数据到内存为例&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>传统数据传输&lt;/strong>：
&lt;ol>
&lt;li>CPU发送读取命令；&lt;/li>
&lt;li>磁盘将数据读取到设备侧的 &lt;strong>内部缓冲区（Buffer）&lt;/strong> 中；&lt;/li>
&lt;li>CPU 通过 &lt;strong>轮询或中断&lt;/strong> 方式获取数据，&lt;strong>逐字节或逐块&lt;/strong> 读取设备 Buffer 中的数据，再写入内存；&lt;/li>
&lt;li>在数据传输期间，&lt;strong>CPU 需持续参与搬运工作，无法执行其他任务&lt;/strong>，效率较低。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>&lt;strong>DMA 数据传输&lt;/strong>：
&lt;ol>
&lt;li>CPU发送读取命令，并配置 DMA 控制器（源地址、目的地址、数据长度）；&lt;/li>
&lt;li>磁盘将数据读取到设备缓冲区；&lt;/li>
&lt;li>DMA控制器 &lt;strong>自动将数据从设备 Buffer 直接写入内存&lt;/strong>，无需 CPU 参与；&lt;/li>
&lt;li>传输完成后，DMA 发出 &lt;strong>中断通知&lt;/strong> CPU，&lt;strong>CPU 可在此期间处理其他任务&lt;/strong>，整体效率显著提升。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://blog.yellster.top/p/zero-copy/DMA.png"
width="1080"
height="525"
srcset="https://blog.yellster.top/p/zero-copy/DMA_hu_9dc8951193a0bfda.png 480w, https://blog.yellster.top/p/zero-copy/DMA_hu_be4799bd5e34cdde.png 1024w"
loading="lazy"
alt="DMA"
class="gallery-image"
data-flex-grow="205"
data-flex-basis="493px"
>&lt;/p></description></item><item><title>KISS原则</title><link>https://blog.yellster.top/p/kiss-principle/</link><pubDate>Tue, 17 Sep 2024 19:44:43 +0800</pubDate><author>xyp_selune@163.com (Yellster)</author><guid>https://blog.yellster.top/p/kiss-principle/</guid><description>&lt;img src="https://blog.yellster.top/p/kiss-principle/kiss.webp" alt="Featured image of post KISS原则" />&lt;h2 id="什么是kiss原则">什么是KISS原则？
&lt;/h2>&lt;p>&lt;strong>KISS原则&lt;/strong>（Keep It Simple, Stupid - 保持简单，笨蛋）是一种强调&lt;strong>简洁性&lt;/strong>的设计哲学，主张在面对问题时，采用最直接、最简单的解决方案，避免不必要的复杂性。&lt;/p>
&lt;blockquote>
&lt;p>这个原则最初由洛克希德公司的首席工程师&lt;strong>凯利·约翰逊&lt;/strong>提出，他要求设计的飞机必须足够简单，普通机械师只需基础工具便能进行维修。这一理念随后被广泛应用到软件开发领域。&lt;/p>&lt;/blockquote>
&lt;h2 id="核心思想">核心思想
&lt;/h2>&lt;h3 id="1-追求简单性">1. 追求简单性
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>选择最直接的解决方案&lt;/strong>：每个问题都有多种解决方案，选择其中最简洁的一种。&lt;/li>
&lt;li>&lt;strong>避免过度设计和不必要的功能&lt;/strong>：避免“过度工程”导致的冗余和复杂性。&lt;/li>
&lt;li>&lt;strong>保持代码清晰易懂&lt;/strong>：通过简洁明了的命名和结构，提高代码的可读性。&lt;/li>
&lt;/ul>
&lt;h3 id="2-消除复杂性">2. 消除复杂性
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>减少依赖关系&lt;/strong>：尽量避免复杂的相互依赖，让系统更易于扩展和维护。&lt;/li>
&lt;li>&lt;strong>避免深层嵌套&lt;/strong>：避免过深的层级结构，使代码更加直观。&lt;/li>
&lt;li>&lt;strong>简化业务逻辑&lt;/strong>：简化逻辑实现，减少不必要的分支和判断。&lt;/li>
&lt;/ul>
&lt;h3 id="3-关注可维护性">3. 关注可维护性
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>编写自文档化的代码&lt;/strong>：代码应该本身就能表达它的功能和意图，减少依赖外部文档。&lt;/li>
&lt;li>&lt;strong>保持代码结构扁平&lt;/strong>：避免过多的嵌套和深层次的层级结构，保持代码结构简单明了。&lt;/li>
&lt;li>&lt;strong>提高代码复用性&lt;/strong>：编写高内聚、低耦合的模块，增加代码的可复用性。&lt;/li>
&lt;/ul>
&lt;h2 id="实践指南">实践指南
&lt;/h2>&lt;h3 id="代码层面">代码层面
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>函数设计&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>保持函数短小精悍，专注于单一职责。&lt;/li>
&lt;li>每个函数只做一件事，避免函数承担过多任务。&lt;/li>
&lt;li>命名要清晰、准确，避免模糊不清。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>类设计&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>避免过度继承，适当使用组合来减少类之间的耦合。&lt;/li>
&lt;li>使用设计模式时，选择最合适的模式，避免过度设计。&lt;/li>
&lt;li>限制类的大小，使其职责单一，保持代码可维护性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>架构设计&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>采用模块化设计，分解复杂问题为更简单的子问题。&lt;/li>
&lt;li>低耦合，高内聚：确保模块之间的依赖最小化，内部功能紧密相关。&lt;/li>
&lt;li>简化数据流和控制流，让系统的工作方式一目了然。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="最佳实践">最佳实践
&lt;/h3>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 反面示例：过度复杂，逻辑分散&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">process_user_data&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">user&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">user&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;name&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">user&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;name&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="s1">&amp;#39;&amp;#39;&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">user&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;age&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">user&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;email&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="s1">&amp;#39;@&amp;#39;&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">user&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;email&amp;#39;&lt;/span>&lt;span class="p">]:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 处理逻辑&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s2">&amp;#34;处理成功&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s2">&amp;#34;处理失败&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 好的示例：简洁且易于维护，逻辑清晰&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">process_user_data&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">is_valid_user&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s2">&amp;#34;处理失败&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s2">&amp;#34;处理成功&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">is_valid_user&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">user&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">is_valid_name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;name&amp;#39;&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">is_valid_age&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;age&amp;#39;&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">is_valid_email&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">user&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;email&amp;#39;&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">is_valid_name&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="nb">bool&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">is_valid_age&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">age&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">age&lt;/span> &lt;span class="o">&amp;gt;&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">def&lt;/span> &lt;span class="nf">is_valid_email&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">email&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="s1">&amp;#39;@&amp;#39;&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">email&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="常见误区">常见误区
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>过度简化&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>简单不等于简陋：过度简化可能会让系统功能丧失，需要在简单性和功能性之间找到平衡。&lt;/li>
&lt;li>需要有适当的复杂度：一些复杂的问题需要通过合理的设计进行解决，不能一味追求简单。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>理解偏差&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>KISS原则并不意味着功能简陋或牺牲必要的功能。简洁应该是经过深思熟虑的“简约”设计，而不是忽略某些核心需求。&lt;/li>
&lt;li>简单并不等于易于实现：复杂问题有时需要更细致的解决方案，简化不意味着放弃细节。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="相关原则">相关原则
&lt;/h2>&lt;p>KISS原则与其他设计原则和思想有密切的联系：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>奥卡姆剃刀&lt;/strong>：
&amp;ldquo;如无必要，勿增实体&amp;rdquo;
强调在多个解释中选择最简单的方案，避免不必要的复杂性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>爱因斯坦&lt;/strong>：
&amp;ldquo;让一切尽可能简单，但不要过于简单&amp;rdquo;
强调简单的同时，需要考虑适度的复杂性，以保证功能的全面性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>达芬奇&lt;/strong>：
&amp;ldquo;简单是最终的复杂性&amp;rdquo;
通过深入的思考和提炼，最终可以将复杂的事物简化到最本质的层面。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="实际应用价值">实际应用价值
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>提高开发效率&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>通过减少复杂性和冗余，减少开发时间。&lt;/li>
&lt;li>更容易理解和调试，提升开发团队的工作效率。&lt;/li>
&lt;li>能快速定位并解决问题，减少开发周期。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>降低维护成本&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>简洁的代码更容易修改和扩展，降低后期维护的复杂度。&lt;/li>
&lt;li>清晰的结构和良好的命名使得代码更易于理解，减少了开发人员的学习曲线。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>提升系统质量&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>通过简化设计和减少不必要的功能，减少潜在的bug。&lt;/li>
&lt;li>更可靠的系统架构，便于后期扩展和优化。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>KISS原则不仅是一个技术原则，更是一种思维方式。它提醒我们，在软件开发中，我们始终应该追求简洁性，但这种简洁并不是功能简陋，而是在保证系统功能的同时，去除冗余和不必要的复杂性。遵循KISS原则可以帮助我们开发出更加可靠、可维护、易扩展的系统。&lt;/p></description></item><item><title>性能优化：从数据出发，基于实际需求</title><link>https://blog.yellster.top/p/performance-optimization/</link><pubDate>Wed, 11 Sep 2024 18:19:26 +0800</pubDate><author>xyp_selune@163.com (Yellster)</author><guid>https://blog.yellster.top/p/performance-optimization/</guid><description>&lt;img src="https://blog.yellster.top/p/performance-optimization/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96.webp" alt="Featured image of post 性能优化：从数据出发，基于实际需求" />&lt;blockquote>
&lt;ul>
&lt;li>&lt;strong>脱离场景谈性能，都是耍流氓。&lt;/strong>&lt;/li>
&lt;li>&lt;strong>过早的优化是万恶之源。&lt;/strong>&lt;/li>
&lt;li>&lt;strong>优化要基于数据，而非猜测。&lt;/strong>&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;h2 id="性能的本质">性能的本质
&lt;/h2>&lt;p>性能优化的最终目标是提升用户体验，并提高系统的效率。要达成这一目标，我们需要从系统最基本的组成部分和性能指标入手。&lt;/p>
&lt;h2 id="计算机系统的基本组成">计算机系统的基本组成
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>CPU&lt;/strong>：执行计算的核心&lt;/p>
&lt;ul>
&lt;li>&lt;strong>指令执行&lt;/strong>：处理各种指令，影响程序的执行速度。&lt;/li>
&lt;li>&lt;strong>数据处理&lt;/strong>：进行数值计算、数据操作。&lt;/li>
&lt;li>&lt;strong>任务调度&lt;/strong>：协调系统中的多个任务并合理分配资源。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>内存&lt;/strong>：临时数据存储&lt;/p>
&lt;ul>
&lt;li>&lt;strong>数据读写&lt;/strong>：内存的读写速度直接影响系统的响应时间。&lt;/li>
&lt;li>&lt;strong>缓存管理&lt;/strong>：缓存优化有助于减少重复计算，提高效率。&lt;/li>
&lt;li>&lt;strong>内存分配&lt;/strong>：合理管理内存的分配与回收，避免内存泄漏。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>I/O&lt;/strong>：数据交换&lt;/p>
&lt;ul>
&lt;li>&lt;strong>网络通信&lt;/strong>：数据在网络中传输的延迟和带宽。&lt;/li>
&lt;li>&lt;strong>磁盘读写&lt;/strong>：磁盘操作的延迟和吞吐量。&lt;/li>
&lt;li>&lt;strong>设备交互&lt;/strong>：外部设备的访问速度。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="性能的关键指标">性能的关键指标
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>响应时间 (Response Time)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>定义&lt;/strong>：从请求发起到响应完成的时间。&lt;/li>
&lt;li>&lt;strong>衡量方式&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>平均响应时间&lt;/strong>：常用的基准，衡量系统的总体性能。&lt;/li>
&lt;li>&lt;strong>P95 / P99&lt;/strong>：95%或99%的请求响应时间，可以更准确地反映系统在高负载下的表现。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>影响因素&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>计算复杂度&lt;/strong>：算法和数据结构的设计。&lt;/li>
&lt;li>&lt;strong>资源等待时间&lt;/strong>：CPU、内存或I/O的占用情况。&lt;/li>
&lt;li>&lt;strong>网络延迟&lt;/strong>：数据传输中的延迟。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>吞吐量 (Throughput)&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>定义&lt;/strong>：单位时间内系统处理的请求数量。&lt;/li>
&lt;li>&lt;strong>衡量方式&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>TPS（每秒事务数）&lt;/strong>&lt;/li>
&lt;li>&lt;strong>QPS（每秒查询数）&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>影响因素&lt;/strong>：
&lt;ul>
&lt;li>&lt;strong>系统资源容量&lt;/strong>：硬件性能的上限。&lt;/li>
&lt;li>&lt;strong>并发处理能力&lt;/strong>：系统处理多个请求的能力。&lt;/li>
&lt;li>&lt;strong>请求处理效率&lt;/strong>：处理每个请求的速度。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>资源利用率&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>CPU 使用率&lt;/strong>：CPU资源是否被充分利用。&lt;/li>
&lt;li>&lt;strong>内存占用&lt;/strong>：内存是否得到了合理使用，避免内存过度使用或浪费。&lt;/li>
&lt;li>&lt;strong>I/O 负载&lt;/strong>：磁盘与网络的负载情况，避免出现I/O瓶颈。&lt;/li>
&lt;li>&lt;strong>网络带宽&lt;/strong>：数据传输的速度和效率。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="性能优化的方法论">性能优化的方法论
&lt;/h2>&lt;h3 id="确定优化目标">确定优化目标
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>明确业务需求&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>响应时间&lt;/strong>：设定用户期望的响应时间。&lt;/li>
&lt;li>&lt;strong>并发量&lt;/strong>：定义系统能承载的最大并发请求数。&lt;/li>
&lt;li>&lt;strong>资源成本&lt;/strong>：优化是否能控制在可接受的资源消耗范围内。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>设定具体指标&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>性能目标&lt;/strong>：设置明确、量化的性能目标。&lt;/li>
&lt;li>&lt;strong>可测量标准&lt;/strong>：确保所有优化都可以通过实际数据进行验证。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="性能分析">性能分析
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>收集性能数据&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>系统监控&lt;/strong>：使用监控工具采集实时的系统指标。&lt;/li>
&lt;li>&lt;strong>性能测试&lt;/strong>：通过负载测试、压力测试等手段获取数据。&lt;/li>
&lt;li>&lt;strong>用户反馈&lt;/strong>：关注用户的使用体验，发现性能瓶颈。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>定位性能瓶颈&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>CPU 密集型&lt;/strong>：算法或代码的计算量过大。&lt;/li>
&lt;li>&lt;strong>内存问题&lt;/strong>：内存分配不当，可能导致频繁的垃圾回收或内存泄漏。&lt;/li>
&lt;li>&lt;strong>I/O 瓶颈&lt;/strong>：磁盘或网络读写延迟过高。&lt;/li>
&lt;li>&lt;strong>网络延迟&lt;/strong>：服务器与客户端之间的传输延迟。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="优化策略">优化策略
&lt;/h3>&lt;h4 id="cpu-优化">CPU 优化
&lt;/h4>&lt;ol>
&lt;li>
&lt;p>&lt;strong>算法优化&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>降低时间复杂度&lt;/strong>：选择合适的算法来减少计算量。&lt;/li>
&lt;li>&lt;strong>减少不必要的计算&lt;/strong>：优化代码，避免重复的计算操作。&lt;/li>
&lt;li>&lt;strong>利用缓存&lt;/strong>：缓存计算结果，避免重复计算。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>并发处理&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>多线程优化&lt;/strong>：通过多核 CPU 的并行计算提高效率。&lt;/li>
&lt;li>&lt;strong>异步处理&lt;/strong>：避免阻塞操作，提高响应速度。&lt;/li>
&lt;li>&lt;strong>任务调度优化&lt;/strong>：合理安排任务执行的顺序，减少等待时间。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="内存优化">内存优化
&lt;/h4>&lt;ol>
&lt;li>
&lt;p>&lt;strong>内存管理&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>避免内存泄漏&lt;/strong>：及时释放不再使用的内存。&lt;/li>
&lt;li>&lt;strong>优化对象创建与回收&lt;/strong>：减少内存分配的频率，避免频繁的GC。&lt;/li>
&lt;li>&lt;strong>合理设置内存参数&lt;/strong>：根据业务需求调优JVM或其他内存配置。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>缓存策略&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>多级缓存设计&lt;/strong>：使用本地缓存、分布式缓存等技术提高读取性能。&lt;/li>
&lt;li>&lt;strong>缓存预热&lt;/strong>：提前加载常用数据，减少请求时的延迟。&lt;/li>
&lt;li>&lt;strong>缓存更新策略&lt;/strong>：确保缓存中的数据保持最新，避免缓存不一致问题。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h4 id="io-优化">I/O 优化
&lt;/h4>&lt;ol>
&lt;li>
&lt;p>&lt;strong>磁盘 I/O&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>批量处理&lt;/strong>：减少频繁的磁盘读写，采用批量处理来提高效率。&lt;/li>
&lt;li>&lt;strong>异步 I/O&lt;/strong>：避免阻塞操作，通过异步方式提高吞吐量。&lt;/li>
&lt;li>&lt;strong>数据压缩&lt;/strong>：通过压缩数据减少磁盘读写的负载。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>网络 I/O&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>连接池管理&lt;/strong>：有效管理网络连接，避免频繁创建和销毁连接。&lt;/li>
&lt;li>&lt;strong>数据传输优化&lt;/strong>：优化数据传输协议，减少数据传输的延迟。&lt;/li>
&lt;li>&lt;strong>协议优化&lt;/strong>：使用合适的协议提高通信效率，如 HTTP/2 或 gRPC。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="优化实施">优化实施
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>循序渐进&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>从瓶颈开始&lt;/strong>：先优化影响最大、最容易解决的瓶颈。&lt;/li>
&lt;li>&lt;strong>一处改动，一次验证&lt;/strong>：避免一次性改动过多，确保每次优化都有明确的效果验证。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>验证效果&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>性能测试&lt;/strong>：每次优化后进行详细的性能测试，确保效果可量化。&lt;/li>
&lt;li>&lt;strong>A/B 测试&lt;/strong>：在真实用户环境中验证优化效果。&lt;/li>
&lt;li>&lt;strong>生产环境验证&lt;/strong>：持续在生产环境中监控优化后的效果。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="常见优化场景">常见优化场景
&lt;/h2>&lt;h3 id="web-应用优化">Web 应用优化
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>前端优化&lt;/strong>：减少资源加载时间，提升渲染性能。&lt;/li>
&lt;li>&lt;strong>后端优化&lt;/strong>：优化接口响应时间，减少数据库查询延迟。&lt;/li>
&lt;li>&lt;strong>数据库优化&lt;/strong>：使用索引、查询优化等手段提升数据库性能。&lt;/li>
&lt;/ul>
&lt;h3 id="分布式系统优化">分布式系统优化
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>负载均衡&lt;/strong>：均衡地分配请求到多个服务节点，提高系统的并发能力。&lt;/li>
&lt;li>&lt;strong>服务拆分&lt;/strong>：将单一服务拆分为多个小服务，减少单一服务的压力。&lt;/li>
&lt;li>&lt;strong>数据分片&lt;/strong>：将数据分片存储，减少单节点的数据压力。&lt;/li>
&lt;/ul>
&lt;h3 id="大数据处理优化">大数据处理优化
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>数据分区&lt;/strong>：将数据按一定规则分区，减少单个查询的扫描量。&lt;/li>
&lt;li>&lt;strong>并行计算&lt;/strong>：利用分布式计算框架（如 Spark）进行并行计算，提高处理速度。&lt;/li>
&lt;li>&lt;strong>资源调度&lt;/strong>：合理分配资源，避免资源浪费和过载。&lt;/li>
&lt;/ul>
&lt;h2 id="优化的注意事项">优化的注意事项
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>避免过早优化&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>优化应基于真实的性能数据，而不是主观臆断。&lt;/li>
&lt;li>&lt;strong>先保证功能正确&lt;/strong>，再根据数据进行优化。&lt;/li>
&lt;li>优化时要考虑成本和收益，不要在不必要的地方过度优化。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>保持简单性&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>可维护性优先&lt;/strong>，避免过度设计和复杂化。&lt;/li>
&lt;li>优化应该以简洁、可扩展的方式进行，避免对系统产生负担。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>持续监控&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>建立监控体系&lt;/strong>：对系统性能进行实时监控。&lt;/li>
&lt;li>&lt;strong>及时发现问题&lt;/strong>：通过监控数据及时发现潜在的性能瓶颈。&lt;/li>
&lt;li>&lt;strong>评估优化效果&lt;/strong>：通过监控工具评估每次优化的实际效果。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="总结">总结
&lt;/h2>&lt;p>性能优化是一个持续不断的过程，需要：&lt;/p>
&lt;ul>
&lt;li>深入理解系统架构，准确定位瓶颈。&lt;/li>
&lt;li>建立科学的优化方法，避免过早优化和盲目优化。&lt;/li>
&lt;li>持续进行监控和改进，以确保系统始终处于最佳状态。&lt;/li>
&lt;/ul>
&lt;p>最重要的是，&lt;strong>性能优化永远要基于实际需求和数据，而不是单纯的经验或猜测&lt;/strong>。始终保持对性能的敏感度，并根据业务变化进行动态调整。&lt;/p></description></item><item><title>ODBC</title><link>https://blog.yellster.top/p/odbc/</link><pubDate>Mon, 12 Aug 2024 12:57:17 +0800</pubDate><author>xyp_selune@163.com (Yellster)</author><guid>https://blog.yellster.top/p/odbc/</guid><description>&lt;ul>
&lt;li>&lt;strong>ODBC, Open Database Connectivity&lt;/strong> 是由 Microsoft 开发的数据库连接标准。&lt;/li>
&lt;li>它允许应用程序使用标准化的接口访问不同的数据库系统。&lt;/li>
&lt;/ul>
&lt;h2 id="特点">特点
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>跨语言支持&lt;/strong>：
&lt;ul>
&lt;li>ODBC 不是绑定于某种编程语言的，因此可以用于多种编程语言，包括 C、C++、Python 等。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>平台依赖性&lt;/strong>：
&lt;ul>
&lt;li>ODBC 原本是为 Windows 平台设计的，但也有跨平台版本，如 unixODBC 用于 Linux 系统。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;strong>使用方式&lt;/strong>：
&lt;ul>
&lt;li>ODBC 通过 ODBC 驱动与数据库通信。驱动程序通常由数据库供应商提供，或者可以使用第三方驱动。&lt;/li>
&lt;li>ODBC 需要在系统中配置数据源名称（DSN），通过 DSN 来标识和连接数据库。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="使用">使用
&lt;/h2>&lt;p>&lt;a class="link" href="https://www.easysoft.com/developer/interfaces/odbc/linux.html#getting_unixodbc" target="_blank" rel="noopener"
>参考地址&lt;/a>&lt;/p>
&lt;h3 id="安装驱动">安装驱动
&lt;/h3>&lt;ul>
&lt;li>Ubuntu/Debian
&lt;ul>
&lt;li>&lt;code>sudo apt-get install unixodbc unixodbc-dev odbcinst&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CentOS/RHEL
&lt;ul>
&lt;li>&lt;code>sudo yum install unixODBC unixODBC-devel&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Windows
在 Windows 上，你可以通过安装 ODBC 数据源管理器和相应的数据库驱动来支持 ODBC。&lt;/li>
&lt;/ul>
&lt;h3 id="配置数据源">配置数据源
&lt;/h3>&lt;p>Linux下，odbc依赖两个配置文件（以达梦8为例）&lt;/p>
&lt;h4 id="配置驱动-etcodbcinstini">配置驱动, /etc/odbcinst.ini
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="k">[DM8]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">Description&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">ODBC DRIVER FOR Dameng8&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">Driver&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">/data0/dm_db/dmdbms/drivers/odbc/libdodbc.so&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>两个属性，&lt;/p>
&lt;ul>
&lt;li>Description，驱动说明&lt;/li>
&lt;li>Driver，驱动文件&lt;/li>
&lt;/ul>
&lt;h4 id="配置数据源-etcodbcini">配置数据源, /etc/odbc.ini
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="line">&lt;span class="cl">&lt;span class="k">[DM8]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">Description&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">DM ODBC DSN&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">Driver&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">DM8&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">SERVER&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">localhost&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">UID&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">SYSDBA&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">PWD&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">SYSDBA&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">TCP_PORT&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">5236&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="na">LANGUAGE&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">CHINESE&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>Description，数据源说明&lt;/li>
&lt;li>Driver，驱动，要和 odbcinst.ini 中的 &lt;strong>selection&lt;/strong> 保持一致&lt;/li>
&lt;li>SERVER，连接的ip&lt;/li>
&lt;li>UID，账户名称&lt;/li>
&lt;li>PWD，账户密码&lt;/li>
&lt;li>TCP_PORT，连接端口&lt;/li>
&lt;li>LANGUAGE，环境语言&lt;/li>
&lt;/ul>
&lt;h2 id="测试">测试
&lt;/h2>&lt;p>&lt;code>isql &amp;lt;DSN数据源名称&amp;gt; [UID [PWD]]&lt;/code>&lt;/p>
&lt;p>&lt;img src="https://blog.yellster.top/p/odbc/isql.png"
width="804"
height="354"
srcset="https://blog.yellster.top/p/odbc/isql_hu_b5d6120f34669dd3.png 480w, https://blog.yellster.top/p/odbc/isql_hu_776897a581b61958.png 1024w"
loading="lazy"
alt="isql"
class="gallery-image"
data-flex-grow="227"
data-flex-basis="545px"
>&lt;/p></description></item><item><title>I/O</title><link>https://blog.yellster.top/p/io/</link><pubDate>Fri, 31 May 2024 11:20:31 +0800</pubDate><author>xyp_selune@163.com (Yellster)</author><guid>https://blog.yellster.top/p/io/</guid><description>&lt;img src="https://blog.yellster.top/p/io/io.png" alt="Featured image of post I/O" />&lt;h2 id="什么是io">什么是I/O
&lt;/h2>&lt;p>I/O，&lt;strong>Input/Output&lt;/strong>，&lt;strong>即输入/输出&lt;/strong>，是计算机系统中用于数据传输的机制，指的是在计算机和外部设备（键盘、显示器、磁盘等）之间，或在计算机内部组件（内存和 CPU）之间的数据传输过程。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>输入（input）&lt;/strong>：指将数据从外部设备或内存传入到计算机系统的过程。&lt;/li>
&lt;li>&lt;strong>输出（output）&lt;/strong>：指将数据从计算机系统传送到外部设备或内存的过程。&lt;/li>
&lt;/ul>
&lt;p>I/O 设备类型：&lt;/p>
&lt;ul>
&lt;li>块设备：磁盘、光盘、USB设备等，以块为单位读写数据，适合随机访问。&lt;/li>
&lt;li>字符设备：键盘、鼠标、串口、打印机等，以字符流为单位读写数据，适合顺序访问。&lt;/li>
&lt;/ul>
&lt;h3 id="计算机角度的io">计算机角度的I/O
&lt;/h3>&lt;p>我们常说的输入输出，比较直观的意思就是&lt;strong>计算机的输入输出&lt;/strong>，&lt;strong>计算机就是主体&lt;/strong>。&lt;/p>
&lt;p>&lt;strong>冯.诺依曼结构&lt;/strong>，它将计算机分成分为5个部分：运算器、控制器、存储器、输入设备、输出设备。&lt;/p>
&lt;p>&lt;img src="https://blog.yellster.top/p/io/%E5%86%AF-%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84.png"
width="1784"
height="932"
srcset="https://blog.yellster.top/p/io/%E5%86%AF-%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84_hu_604897a2b548d3fb.png 480w, https://blog.yellster.top/p/io/%E5%86%AF-%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84_hu_b2a2d5a893c71c27.png 1024w"
loading="lazy"
alt="冯.诺依曼结构"
class="gallery-image"
data-flex-grow="191"
data-flex-basis="459px"
>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>输入设备&lt;/strong>是向计算机输入数据和信息的设备，键盘，鼠标都属于输入设备；&lt;/li>
&lt;li>&lt;strong>输出设备&lt;/strong>是计算机硬件系统的终端设备，用于接收计算机数据的输出显示，一般显示器、打印机属于输出设备。&lt;/li>
&lt;/ul>
&lt;p>鼠标、显示器这只是直观表面的输入输出，回到计算机架构来说，&lt;strong>涉及计算机核心与其他设备间数据迁移的过程，就是I/O&lt;/strong>。&lt;/p>
&lt;p>如磁盘I/O，就是从磁盘读取数据到内存，这算一次输入，对应的，将内存中的数据写入磁盘，就算输出。这就是I/O的本质。&lt;/p>
&lt;h3 id="操作系统的io">操作系统的I/O
&lt;/h3>&lt;p>我们要将内存中的数据写入到磁盘的话，主体会是什么呢？主体可能是一个应用程序，比如一个Java进程（假设网络传来二进制流，一个Java进程可以把它写入到磁盘）。&lt;/p>
&lt;p>&lt;strong>操作系统&lt;/strong>负责计算机的资源管理和进程的调度。我们电脑上跑着的应用程序，其实是需要经过&lt;strong>操作系统&lt;/strong>，才能做一些特殊操作，如&lt;strong>磁盘文件读写、内存的读写&lt;/strong>等等。因为这些都是比较危险的操作，不可以由应用程序乱来，只能交给底层操作系统来。也就是说，你的应用程序要把数据写入磁盘，只能通过调用操作系统开放出来的API来操作。&lt;/p>
&lt;p>我们应用程序是跑在用户空间的，它不存在实质的I/O过程，真正的I/O是在&lt;strong>操作系统&lt;/strong>执行的。即应用程序的I/O操作分为两种动作：&lt;strong>I/O调用和I/O执行&lt;/strong>。&lt;/p>
&lt;p>I/O调用是由进程（应用程序的运行态）发起，而I/O执行是&lt;strong>操作系统内核&lt;/strong>的工作。此时所说的I/O是应用程序对操作系统I/O功能的一次触发，即I/O调用。&lt;/p>
&lt;blockquote>
&lt;p>&lt;strong>什么是用户空间？什么是内核空间?&lt;/strong>&lt;/p>
&lt;p>以32位操作系统为例，它为每一个进程都分配了4G(2的32次方)的内存空间。这4G可访问的内存空间分为二部分，一部分是用户空间，一部分是内核空间。内核空间是操作系统内核访问的区域，是受保护的内存空间，而用户空间是用户应用程序访问的内存区域。&lt;/p>&lt;/blockquote>
&lt;h3 id="操作系统的一次io过程">操作系统的一次I/O过程
&lt;/h3>&lt;p>应用程序发起的一次I/O操作包含两个阶段：&lt;/p>
&lt;ul>
&lt;li>I/O调用：应用程序进程向&lt;strong>操作系统内核&lt;/strong>发起调用。&lt;/li>
&lt;li>I/O执行：操作系统内核完成I/O操作。&lt;/li>
&lt;/ul>
&lt;p>操作系统内核完成I/O操作还包括两个过程：&lt;/p>
&lt;ul>
&lt;li>准备数据：内核等待I/O设备准备好数据。&lt;/li>
&lt;li>拷贝数据：将数据从内核缓冲区拷贝到用户进程缓冲区。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://blog.yellster.top/p/io/IO%E8%BF%87%E7%A8%8B.png"
width="2160"
height="1106"
srcset="https://blog.yellster.top/p/io/IO%E8%BF%87%E7%A8%8B_hu_8deae71b6d751300.png 480w, https://blog.yellster.top/p/io/IO%E8%BF%87%E7%A8%8B_hu_5e8163623202590d.png 1024w"
loading="lazy"
alt="I/O过程"
class="gallery-image"
data-flex-grow="195"
data-flex-basis="468px"
>&lt;/p>
&lt;p>其实I/O就是把进程的内部数据转移到外部设备，或者把外部设备的数据迁移到进程内部。外部设备一般指硬盘、socket通讯的网卡。一个完整的&lt;strong>I/O过程&lt;/strong>包括以下几个步骤：&lt;/p>
&lt;ul>
&lt;li>应用程序进程向操作系统发起&lt;strong>I/O调用请求&lt;/strong>&lt;/li>
&lt;li>操作系统&lt;strong>准备数据&lt;/strong>，把I/O外部设备的数据，加载到&lt;strong>内核缓冲区&lt;/strong>&lt;/li>
&lt;li>操作系统拷贝数据，即将内核缓冲区的数据，拷贝到用户进程缓冲区&lt;/li>
&lt;/ul>
&lt;h2 id="io模型">I/O模型
&lt;/h2>&lt;h3 id="阻塞-vs-非阻塞-vs-异步">阻塞 vs 非阻塞 vs 异步
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>阻塞&lt;/strong>：调用 &lt;code>read()/write()&lt;/code> 时，进程被挂起直至操作完成，简单易用但会导致资源空转。&lt;/li>
&lt;li>&lt;strong>非阻塞&lt;/strong>：通过在文件描述符上设置 &lt;code>O_NONBLOCK&lt;/code> 标志，使得 &lt;code>read()/write()&lt;/code> 调用不会阻塞，而是立即返回，需配合 &lt;code>select/poll&lt;/code> 等多路复用手段实现效率提升。&lt;/li>
&lt;li>&lt;strong>异步&lt;/strong>：调用类似 &lt;code>aio_read()/aio_write()&lt;/code>，进程发起调用后立即返回，内核完成I/O操作后通过&lt;strong>回调或事件通知&lt;/strong>告知进程，无需轮询，允许并行处理其他任务。&lt;/li>
&lt;/ul>
&lt;h3 id="五种经典-io-模型">五种经典 I/O 模型
&lt;/h3>&lt;h4 id="阻塞io模型-bio-blocking-io">阻塞I/O模型 (BIO, Blocking I/O)
&lt;/h4>&lt;p>假设应用程序的进程发起&lt;strong>I/O调用&lt;/strong>（&lt;code>read()&lt;/code> 或 &lt;code>write()&lt;/code>），但是如果&lt;strong>内核的数据还没准备好&lt;/strong>的话，那应用程序进程就一直在&lt;strong>阻塞等待&lt;/strong>，一直等到内核数据准备好了，从内核拷贝到用户空间，才返回成功提示，此次I/O操作，称之为&lt;strong>阻塞I/O&lt;/strong>。&lt;/p>
&lt;p>&lt;img src="https://blog.yellster.top/p/io/%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png"
width="2160"
height="1130"
srcset="https://blog.yellster.top/p/io/%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B_hu_96fa08004de89fd9.png 480w, https://blog.yellster.top/p/io/%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B_hu_e19611a2a189f803.png 1024w"
loading="lazy"
alt="阻塞I/O模型"
class="gallery-image"
data-flex-grow="191"
data-flex-basis="458px"
>&lt;/p>
&lt;ul>
&lt;li>阻塞I/O比较经典的应用就是&lt;strong>阻塞socket、Java BIO&lt;/strong>。&lt;/li>
&lt;li>阻塞I/O的缺点就是：如果内核数据一直没准备好，那用户进程将一直阻塞，&lt;strong>浪费性能&lt;/strong>，可以使用&lt;strong>非阻塞I/O&lt;/strong>优化。&lt;/li>
&lt;/ul>
&lt;h4 id="非阻塞io模型-nio-non-blocking-io">非阻塞I/O模型 (NIO, Non-Blocking I/O)
&lt;/h4>&lt;p>在文件描述符上设置 &lt;code>O_NONBLOCK&lt;/code>，使 &lt;code>read()/write()&lt;/code> 调用立即返回，若无法立刻完成则返回 &lt;code>EAGAIN&lt;/code>（对于套接字也可能是 &lt;code>EWOULDBLOCK&lt;/code>），要求开发者主动轮询或结合多路复用进行事件驱动处理。&lt;/p>
&lt;blockquote>
&lt;ul>
&lt;li>&lt;strong>成功完成&lt;/strong>：返回实际读写的字节数（0 表示 EOF）&lt;/li>
&lt;li>&lt;strong>无法立即完成（会阻塞）&lt;/strong>：返回 -1，&lt;code>errno == EAGAIN&lt;/code>；若是套接字，也可能 &lt;code>errno == EWOULDBLOCK&lt;/code>&lt;/li>
&lt;li>&lt;strong>其他错误&lt;/strong>：如 &lt;code>EBADF&lt;/code>、&lt;code>EFAULT&lt;/code>、&lt;code>EINTR&lt;/code> 等，根据具体场景返回对应错误码&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;p>&lt;img src="https://blog.yellster.top/p/io/%E9%9D%9E%E9%98%BB%E5%A1%9EIO.png"
width="2160"
height="1528"
srcset="https://blog.yellster.top/p/io/%E9%9D%9E%E9%98%BB%E5%A1%9EIO_hu_4c28639776292d8e.png 480w, https://blog.yellster.top/p/io/%E9%9D%9E%E9%98%BB%E5%A1%9EIO_hu_53fadcaaef01d490.png 1024w"
loading="lazy"
alt="非阻塞I/O"
class="gallery-image"
data-flex-grow="141"
data-flex-basis="339px"
>&lt;/p>
&lt;p>非阻塞I/O模型，简称&lt;strong>NIO&lt;/strong>，&lt;code>Non-Blocking I/O&lt;/code>。它相对于阻塞I/O，虽然大幅提升了性能，但是它依然存在&lt;strong>性能问题&lt;/strong>，即&lt;strong>频繁的轮询&lt;/strong>，导致频繁的系统调用，同样会消耗大量的CPU资源。可以考虑&lt;strong>I/O复用模型&lt;/strong>，去解决这个问题。&lt;/p>
&lt;h4 id="多路复用io模型-mio-multiplexing-io">多路复用I/O模型 (MIO, Multiplexing I/O)
&lt;/h4>&lt;p>既然&lt;strong>NIO&lt;/strong>无效的轮询会导致CPU资源消耗，我们等到内核数据准备好了，主动通知应用进程再去进行系统调用，那不就好了嘛？&lt;/p>
&lt;p>I/O复用模型核心思路：系统给我们提供&lt;strong>一类函数&lt;/strong>（&lt;strong>select、poll、epoll&lt;/strong>函数），在单个线程中监控大量&lt;strong>文件描述符&lt;/strong>的可读写状态，实现阻塞或边缘触发的事件分发机制，从而避免因阻塞 I/O 导致的线程资源浪费。&lt;/p>
&lt;blockquote>
&lt;p>在 UNIX/Linux 中，&lt;strong>文件描述符（FD，File Descriptor）&lt;/strong> 是内核为每个已打开资源（常见有普通文件、管道、套接字、字符设备等）分配的一个&lt;strong>非负整数&lt;/strong>，它充当用户空间进程与内核 I/O 子系统之间的句柄。例如：&lt;/p>
&lt;ul>
&lt;li>FD = 0：标准输入（stdin）&lt;/li>
&lt;li>FD = 1：标准输出（stdout）&lt;/li>
&lt;li>FD ≥ 3：其他打开的文件或套接字&lt;/li>
&lt;/ul>
&lt;p>所有 I/O 系统调用（如 &lt;code>read(fd, buf, n)&lt;/code>、&lt;code>write(fd, buf, n)&lt;/code>）均通过这个整数索引来标识目标资源。&lt;/p>&lt;/blockquote>
&lt;h5 id="select">select
&lt;/h5>&lt;p>应用进程通过调用&lt;strong>select&lt;/strong>函数，可以同时监控多个 &lt;code>fd&lt;/code>，在 &lt;code>select&lt;/code>函数监控的 &lt;code>fd&lt;/code> 中，只要有任何一个数据状态准备就绪了，&lt;code>select&lt;/code> 函数就会返回可读状态，这时应用进程再发起 &lt;code>recvfrom&lt;/code> 请求去读取数据。&lt;/p>
&lt;p>&lt;img src="https://blog.yellster.top/p/io/select.png"
width="2160"
height="1320"
srcset="https://blog.yellster.top/p/io/select_hu_7d14980e6febe213.png 480w, https://blog.yellster.top/p/io/select_hu_bd2e0c412fc285a6.png 1024w"
loading="lazy"
alt="select"
class="gallery-image"
data-flex-grow="163"
data-flex-basis="392px"
>&lt;/p>
&lt;p>非阻塞I/O模型（NIO）中，需要 &lt;code>N&lt;/code>（N&amp;gt;=1）次轮询系统调用，然而借助 &lt;code>select&lt;/code> 的I/O多路复用模型，只需要发起一次询问就够了，大大优化了性能。&lt;/p>
&lt;p>但是呢，&lt;code>select&lt;/code>有几个缺点：&lt;/p>
&lt;ul>
&lt;li>监听的I/O最大连接数有限，在Linux系统上一般为1024。&lt;/li>
&lt;li>select函数返回后，是通过&lt;strong>遍历&lt;/strong> &lt;code>fdset&lt;/code>，找到就绪的描述符 &lt;code>fd&lt;/code>。（仅知道有I/O事件发生，却不知是哪几个流，所以&lt;strong>遍历所有流&lt;/strong>）&lt;/li>
&lt;/ul>
&lt;p>因为&lt;strong>存在连接数限制&lt;/strong>，所以后来又提出了&lt;strong>poll&lt;/strong>。与select相比，&lt;strong>poll&lt;/strong>解决了&lt;strong>连接数限制问题&lt;/strong>。但是呢，select和poll一样，还是需要通过遍历文件描述符来获取已经就绪的 &lt;code>socket&lt;/code>。如果同时连接的大量客户端，在一时刻可能只有极少处于就绪状态，伴随着监视的描述符数量的增长，&lt;strong>效率也会线性下降&lt;/strong>。&lt;/p>
&lt;p>因此经典的多路复用模型 &lt;code>epoll&lt;/code>诞生。&lt;/p>
&lt;h5 id="epoll">epoll
&lt;/h5>&lt;p>为了解决 &lt;code>select/poll&lt;/code>存在的问题，多路复用模型 &lt;code>epoll&lt;/code>诞生，它采用事件驱动来实现，流程图如下：&lt;/p>
&lt;p>&lt;img src="https://blog.yellster.top/p/io/epoll.png"
width="2160"
height="1312"
srcset="https://blog.yellster.top/p/io/epoll_hu_26385753c109246.png 480w, https://blog.yellster.top/p/io/epoll_hu_3fd15b2fd037a372.png 1024w"
loading="lazy"
alt="epoll"
class="gallery-image"
data-flex-grow="164"
data-flex-basis="395px"
>&lt;/p>
&lt;p>&lt;strong>epoll&lt;/strong>先通过 &lt;code>epoll_ctl()&lt;/code> 来注册一个 &lt;code>fd&lt;/code>，一旦基于某个 &lt;code>fd&lt;/code> 就绪时，内核会采用回调机制，迅速激活这个 &lt;code>fd&lt;/code>，当进程调用 &lt;code>epoll_wait()&lt;/code>时便得到通知。这里去掉了&lt;strong>遍历文件描述符&lt;/strong>的操作，而是采用&lt;strong>监听事件回调&lt;/strong>的机制。这就是epoll的亮点。&lt;/p>
&lt;h5 id="selectpollepoll的区别">select、poll、epoll的区别
&lt;/h5>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>&lt;/th>
&lt;th>select&lt;/th>
&lt;th>poll&lt;/th>
&lt;th>epoll&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>底层数据结构&lt;/td>
&lt;td>数组&lt;/td>
&lt;td>链表&lt;/td>
&lt;td>红黑树和双链表&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>获取就绪的fd&lt;/td>
&lt;td>遍历&lt;/td>
&lt;td>遍历&lt;/td>
&lt;td>事件回调&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>事件复杂度&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>O(n)&lt;/td>
&lt;td>O(1)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>最大连接数&lt;/td>
&lt;td>1024&lt;/td>
&lt;td>无限制&lt;/td>
&lt;td>无限制&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>fd数据拷贝&lt;/td>
&lt;td>每次调用select，需要将fd数据从用户空间拷贝到内核空间&lt;/td>
&lt;td>每次调用poll，需要将fd数据从用户空间拷贝到内核空间&lt;/td>
&lt;td>使用内存映射(mmap)，不需要从用户空间频繁拷贝fd数据到内核空间&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>epoll&lt;/strong>明显优化了I/O的执行效率，但在进程调用 &lt;code>epoll_wait()&lt;/code>时，仍然可能被阻塞。&lt;/p>
&lt;h4 id="信号驱动io模型-sdio-signal-driven-io">信号驱动I/O模型 (SDIO, Signal-driven I/O)
&lt;/h4>&lt;p>信号驱动I/O不再用主动询问的方式去确认数据是否就绪，而是向内核发送一个信号（调用 &lt;code>sigaction&lt;/code> 的时候建立一个 &lt;code>SIGIO&lt;/code> 的信号），然后应用用户进程可以去做别的事，不用阻塞。当内核数据准备好后，再通过 &lt;code>SIGIO&lt;/code> 信号通知应用进程，数据准备好后的可读状态。应用用户进程收到信号之后，立即调用 &lt;code>recvfrom&lt;/code>，去读取数据。&lt;/p>
&lt;p>&lt;img src="https://blog.yellster.top/p/io/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B.png"
width="2160"
height="1324"
srcset="https://blog.yellster.top/p/io/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B_hu_a20f69c0ec854949.png 480w, https://blog.yellster.top/p/io/%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8IO%E6%A8%A1%E5%9E%8B_hu_fb0f40ed63b73bfa.png 1024w"
loading="lazy"
alt="信号驱动I/O模型"
class="gallery-image"
data-flex-grow="163"
data-flex-basis="391px"
>&lt;/p>
&lt;p>信号驱动I/O模型，在应用进程发出信号后，是立即返回的，不会阻塞进程。它已经有异步操作的感觉了。但是你细看上面的流程图，&lt;strong>发现数据复制到应用缓冲的时候&lt;/strong>，应用进程还是阻塞的。回过头来看下，不管是BIO，还是NIO，还是信号驱动，在数据从内核复制到应用缓冲的时候，都是阻塞的。&lt;/p>
&lt;h4 id="异步io模型-aio-asynchronous-io">异步I/O模型 (AIO, Asynchronous I/O)
&lt;/h4>&lt;p>前面讲的 &lt;code>BIO&lt;/code>，&lt;code>NIO&lt;/code>和&lt;code>SDIO&lt;/code>，在数据从内核复制到应用缓冲的时候，都是&lt;strong>阻塞&lt;/strong>的，因此都不算是真正的异步。&lt;code>AIO&lt;/code>实现了I/O全流程的非阻塞，就是应用进程发出系统调用后，是立即返回的，但是&lt;strong>立即返回的不是处理结果，而是表示提交成功类似的意思&lt;/strong>。等内核数据准备好，将数据拷贝到用户进程缓冲区，发送信号通知用户进程I/O操作执行完毕。&lt;/p>
&lt;p>&lt;img src="https://blog.yellster.top/p/io/%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B.png"
width="2160"
height="1352"
srcset="https://blog.yellster.top/p/io/%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B_hu_7c09de5e6fbebc58.png 480w, https://blog.yellster.top/p/io/%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B_hu_bb84c71d731079d4.png 1024w"
loading="lazy"
alt="异步I/O模型"
class="gallery-image"
data-flex-grow="159"
data-flex-basis="383px"
>&lt;/p>
&lt;p>异步I/O的优化思路很简单，只需要向内核发送一次请求，就可以完成数据状态询问和数据拷贝的所有操作，并且不用阻塞等待结果。日常开发中，有类似思想的业务场景：&lt;/p>
&lt;blockquote>
&lt;p>比如发起一笔批量转账，但是批量转账处理比较耗时，这时候后端可以先告知前端转账提交成功，等到结果处理完，再通知前端结果即可。&lt;/p>&lt;/blockquote>
&lt;h3 id="io-模型对比">I/O 模型对比
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>模型&lt;/th>
&lt;th>调用时阻塞？&lt;/th>
&lt;th>数据就绪时阻塞？&lt;/th>
&lt;th>特点&lt;/th>
&lt;th>常见应用&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>阻塞 I/O（Blocking I/O）&lt;/td>
&lt;td>是&lt;/td>
&lt;td>—&lt;/td>
&lt;td>最简单，单线程也能完成&lt;/td>
&lt;td>Java BIO&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>非阻塞 I/O（Non-Blocking）&lt;/td>
&lt;td>否&lt;/td>
&lt;td>是&lt;/td>
&lt;td>需轮询 &lt;code>EAGAIN&lt;/code>&lt;/td>
&lt;td>C++ low-level&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>多路复用 I/O&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>单线程管理上万 FD，不轮询所有 FD&lt;/td>
&lt;td>Nginx、Node.js&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>信号驱动 I/O（SIGIO）&lt;/td>
&lt;td>否&lt;/td>
&lt;td>是&lt;/td>
&lt;td>用信号通知，信号处理函数中读写&lt;/td>
&lt;td>较少使用&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>异步 I/O（POSIX AIO）&lt;/td>
&lt;td>否&lt;/td>
&lt;td>否&lt;/td>
&lt;td>真异步，全流程不阻塞&lt;/td>
&lt;td>高性能文件服务&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="何时选哪种模型">何时选哪种模型
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>简单脚本／小工具&lt;/strong>：阻塞 I/O 足矣。&lt;/li>
&lt;li>&lt;strong>多连接高并发&lt;/strong>：首选多路复用（&lt;code>epoll&lt;/code>/&lt;code>kqueue&lt;/code>）＋非阻塞。&lt;/li>
&lt;li>&lt;strong>极致性能&lt;/strong>：结合零拷贝（&lt;code>sendfile&lt;/code>、&lt;code>splice&lt;/code>）或 Linux &lt;code>io_uring&lt;/code>。&lt;/li>
&lt;li>&lt;strong>跨平台服务&lt;/strong>：可借助 Java Netty、Rust Tokio、Go runtime 等，它们底层封装了最佳模型。&lt;/li>
&lt;/ul>
&lt;h2 id="拓展">拓展
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>&lt;a class="link" href="https://blog.yellster.top/p/zero-copy/" >零拷贝技术&lt;/a>&lt;/strong>：&lt;code>sendfile()&lt;/code>、&lt;code>splice()&lt;/code>、&lt;code>mmap()&lt;/code>&lt;/li>
&lt;li>&lt;strong>&lt;a class="link" href="https://blog.yellster.top/p/io_uring/" >io_uring&lt;/a>&lt;/strong>：Linux 5.1+ 提供的真正零系统调用异步接口&lt;/li>
&lt;li>&lt;strong>Windows IOCP&lt;/strong>：高性能 proactor 模型&lt;/li>
&lt;li>&lt;strong>虚拟化 I/O&lt;/strong>：Virtio、SR-IOV、DDIO 加速&lt;/li>
&lt;/ul></description></item><item><title>访问网站缺少样式</title><link>https://blog.yellster.top/p/missing-styles/</link><pubDate>Mon, 23 Oct 2023 15:14:25 +0800</pubDate><author>xyp_selune@163.com (Yellster)</author><guid>https://blog.yellster.top/p/missing-styles/</guid><description>&lt;img src="https://blog.yellster.top/p/missing-styles/unsafe_link.png" alt="Featured image of post 访问网站缺少样式" />&lt;h2 id="现状">现状
&lt;/h2>&lt;p>某些网站打开，因为当前网络等其他原因，无法正常访问页面，只能显示网站的基本文字，而没有图片，样式等&lt;/p>
&lt;p>&lt;img src="https://blog.yellster.top/p/missing-styles/stackoverflow.png"
width="1872"
height="1009"
srcset="https://blog.yellster.top/p/missing-styles/stackoverflow_hu_c2a8e32698bf36e.png 480w, https://blog.yellster.top/p/missing-styles/stackoverflow_hu_baee5d9fd8301d8a.png 1024w"
loading="lazy"
alt="stackoverflow无法显示样式"
class="gallery-image"
data-flex-grow="185"
data-flex-basis="445px"
>&lt;/p>
&lt;h2 id="产生原因">产生原因
&lt;/h2>&lt;p>当前网站的样式地址、静态文件地址，无法访问，或者不安全被浏览器拦截&lt;/p>
&lt;p>&lt;img src="https://blog.yellster.top/p/missing-styles/unsafe_link.png"
width="836"
height="578"
srcset="https://blog.yellster.top/p/missing-styles/unsafe_link_hu_a49e9a68e70d05c4.png 480w, https://blog.yellster.top/p/missing-styles/unsafe_link_hu_c6c14e1e13d3f64e.png 1024w"
loading="lazy"
alt="您的链接不是私密链接"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/p>
&lt;h2 id="解决办法">解决办法
&lt;/h2>&lt;ol>
&lt;li>打开无法正常访问的网站&lt;/li>
&lt;li>F12，打开审查，切换到 &lt;code>Network&lt;/code> tab页，刷新页面，会发现很多地址都是显示红色
&lt;img src="https://blog.yellster.top/p/missing-styles/not_access.png"
width="1167"
height="722"
srcset="https://blog.yellster.top/p/missing-styles/not_access_hu_72b813cf8e6a741c.png 480w, https://blog.yellster.top/p/missing-styles/not_access_hu_28976e8a69818606.png 1024w"
loading="lazy"
alt="F12"
class="gallery-image"
data-flex-grow="161"
data-flex-basis="387px"
>&lt;/li>
&lt;li>选择任意一个红色的无法访问的地址，双击打开，会发现浏览器出现隐私错误提示
&lt;img src="https://blog.yellster.top/p/missing-styles/unsafe_link.png"
width="836"
height="578"
srcset="https://blog.yellster.top/p/missing-styles/unsafe_link_hu_a49e9a68e70d05c4.png 480w, https://blog.yellster.top/p/missing-styles/unsafe_link_hu_c6c14e1e13d3f64e.png 1024w"
loading="lazy"
alt="您的链接不是私密链接"
class="gallery-image"
data-flex-grow="144"
data-flex-basis="347px"
>&lt;/li>
&lt;li>高级，仍然访问，(或者直接在当前页面上键盘输入 &lt;code>thisisunsafe&lt;/code>)&lt;/li>
&lt;li>当前页面会刷新重新访问，并正常访问&lt;/li>
&lt;li>这时，继续切换到 该网站 的标签页，刷新，会发现当前页面可以正常访问了
&lt;img src="https://blog.yellster.top/p/missing-styles/success.png"
width="1915"
height="1007"
srcset="https://blog.yellster.top/p/missing-styles/success_hu_8642798c149c8012.png 480w, https://blog.yellster.top/p/missing-styles/success_hu_30fedbb631d12831.png 1024w"
loading="lazy"
alt="正常访问"
class="gallery-image"
data-flex-grow="190"
data-flex-basis="456px"
>&lt;/li>
&lt;/ol>
&lt;h2 id="猜测">猜测
&lt;/h2>&lt;p>猜测该类网站无法访问，是因为Chrome不信任这些静态资源地址 &lt;code>自签名ssl证书&lt;/code>，为了安全起见，直接禁止访问了&lt;/p></description></item></channel></rss>