<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Rust on Yellster - Blog</title><link>https://blog.yellster.top/tags/rust/</link><description>Recent content in Rust on Yellster - Blog</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><managingEditor>xyp_selune@163.com (Yellster)</managingEditor><webMaster>xyp_selune@163.com (Yellster)</webMaster><lastBuildDate>Mon, 21 Apr 2025 17:56:08 +0800</lastBuildDate><atom:link href="https://blog.yellster.top/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>第一性原理</title><link>https://blog.yellster.top/p/first-principle/</link><pubDate>Mon, 21 Apr 2025 17:56:08 +0800</pubDate><author>xyp_selune@163.com (Yellster)</author><guid>https://blog.yellster.top/p/first-principle/</guid><description>&lt;img src="https://blog.yellster.top/p/first-principle/%E7%AC%AC%E4%B8%80%E6%80%A7%E5%8E%9F%E7%90%86.webp" alt="Featured image of post 第一性原理" />&lt;h2 id="什么是第一性原理">什么是第一性原理？
&lt;/h2>&lt;p>&lt;strong>第一性原理（First Principles）&lt;/strong> 是一种从最基本、最本质的层面思考问题的方法，要求我们抛开所有假设和成见，从最基础的真理出发重新构建认知。这种思维方式强调从根本问题出发，剖析和理解事物本质，而不是依赖传统认知或经验。&lt;/p>
&lt;h3 id="起源">起源
&lt;/h3>&lt;ul>
&lt;li>第一性原理的概念最早可以追溯到&lt;strong>亚里士多德&lt;/strong>的哲学思想。&lt;/li>
&lt;li>他认为，在任何系统中，都存在一些最基本的命题或假设，这些命题不能进一步简化或从其他命题推导出来。&lt;/li>
&lt;li>这些基本命题构成了所有知识的基础，是我们认知的出发点。&lt;/li>
&lt;/ul>
&lt;h3 id="与传统思维的区别">与传统思维的区别
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>类比思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>基于已知经验，寻找相似性，容易受限于现有认知，创新性有限。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>第一性原理思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>回归本质，剖析问题的基本组成要素，突破认知局限，有可能产生突破性的创新。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="实际应用案例">实际应用案例
&lt;/h2>&lt;h3 id="特斯拉的电池革新">特斯拉的电池革新
&lt;/h3>&lt;p>马斯克运用第一性原理思维降低电池成本：&lt;/p>
&lt;ol>
&lt;li>不是直接压缩现有电池的利润空间。&lt;/li>
&lt;li>而是从最基本的组成材料（如锂、钴、镍等）入手。&lt;/li>
&lt;li>通过分析原材料的成本，重新设计生产流程。&lt;/li>
&lt;li>最终成功将电池成本降低约50%。&lt;/li>
&lt;/ol>
&lt;h3 id="spacex-的火箭研发">SpaceX 的火箭研发
&lt;/h3>&lt;p>传统思维：火箭很贵，因为&amp;quot;火箭一直都很贵&amp;quot;&lt;/p>
&lt;p>运用第一性原理：&lt;/p>
&lt;ol>
&lt;li>分析火箭的基本组成材料，计算原材料成本。&lt;/li>
&lt;li>重新设计火箭制造流程。&lt;/li>
&lt;li>通过实现可重复使用的火箭，大幅降低了发射成本。&lt;/li>
&lt;/ol>
&lt;h2 id="如何运用第一性原理">如何运用第一性原理
&lt;/h2>&lt;h3 id="基本步骤">基本步骤
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>识别问题&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>明确要解决的核心问题，避免被表象迷惑。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>拆解组成&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>将问题拆解为最基本的要素，识别关键变量和约束条件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>重新构建&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>从基本要素出发，构建新的解决方案，探索创新的方法。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>验证方案&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>测试新方案的可行性，并持续优化改进。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="注意事项">注意事项
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>避免过度简化&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>确保不遗漏重要因素，避免忽视系统复杂性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>平衡效率&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>不是所有问题都需要追溯到最基础层面，视情况决定是否采用第一性原理思维。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>保持开放性&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>不断质疑现有认知，愿意接受新的可能性和解决方案。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="应用领域">应用领域
&lt;/h2>&lt;ol>
&lt;li>
&lt;p>&lt;strong>技术创新&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>通过第一性原理突破技术瓶颈，开发新产品或技术。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>商业模式&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>重新定义市场、颠覆传统商业模式，创造新的商业机会。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>问题解决&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>解决复杂技术问题，优化现有流程。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>个人成长&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>在个人学习和职业发展中，突破思维局限，找到更高效的成长路径。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="在软件开发中的应用">在软件开发中的应用
&lt;/h2>&lt;h3 id="1-编程语言设计">1. 编程语言设计
&lt;/h3>&lt;p>&lt;strong>传统思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>借鉴已有语言的特性，模仿流行语言的语法结构。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第一性原理思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>深入思考编程语言的本质：人与机器的沟通桥梁。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>分析目标用户的实际需求，设计符合需求的语言特性。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>例如&lt;strong>Rust语言&lt;/strong>，从系统编程的基本需求出发，设计了&lt;strong>所有权&lt;/strong>、&lt;strong>借用&lt;/strong>和&lt;strong>生命周期&lt;/strong>等独特特性，以确保内存安全和高效并发。&lt;/p>
&lt;p>&lt;strong>&lt;a class="link" href="https://blog.yellster.top/p/ownership/" >Rust的所有权模型&lt;/a>&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>所有权&lt;/strong>确保每个值只能有一个所有者，这使得内存管理变得更可控，避免了内存泄漏和悬挂指针的问题。&lt;/li>
&lt;li>&lt;strong>借用&lt;/strong>和&lt;strong>生命周期&lt;/strong>的概念，使得Rust能够通过编译时检查，确保数据不会在不合法的情况下被访问。&lt;/li>
&lt;li>这些设计原则并不是简单模仿其他语言，而是从解决内存安全和并发编程的基本问题出发，重新构建了语言的核心特性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="2-系统架构设计">2. 系统架构设计
&lt;/h3>&lt;p>&lt;strong>传统思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>采用流行架构模式，照搬热门技术栈或成功案例。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第一性原理思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>分析业务的本质需求，考虑系统的基本约束（性能、可用性、扩展性、维护成本等）。&lt;/li>
&lt;li>从零开始设计最适合的架构，确保架构的灵活性和可维护性。&lt;/li>
&lt;li>例如，&lt;strong>微服务架构&lt;/strong>的选择不是因为它流行，而是基于以下分析：业务模块的独立性、团队协作效率、系统扩展需求、维护成本等。&lt;/li>
&lt;/ul>
&lt;h3 id="3-代码重构">3. 代码重构
&lt;/h3>&lt;p>&lt;strong>传统思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>简单修补问题代码，堆积临时解决方案。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第一性原理思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>理解代码的核心功能，识别根本的设计问题。&lt;/li>
&lt;li>从根本上重新设计代码，遵循&lt;a class="link" href="https://blog.yellster.top/p/design-principles/" >设计原则&lt;/a>（如单一职责、开闭原则、依赖倒置等）。&lt;/li>
&lt;/ul>
&lt;h3 id="4-问题调试">4. 问题调试
&lt;/h3>&lt;p>&lt;strong>传统思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>基于经验猜测问题，尝试常见解决方案，修复表面症状。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第一性原理思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>理解系统的工作原理，收集诊断数据，分析问题根本原因。&lt;/li>
&lt;li>设计全面的解决方案，如在 &lt;strong>&lt;a class="link" href="https://blog.yellster.top/p/performance-optimization/" >性能优化&lt;/a>&lt;/strong> 中，通过分析性能瓶颈的本质，优化算法和数据结构，而非简单依赖缓存或硬件升级。&lt;/li>
&lt;/ul>
&lt;h3 id="5-技术选型">5. 技术选型
&lt;/h3>&lt;p>&lt;strong>传统思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>选择流行技术，跟随大公司的技术栈或盲目采用新技术。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>第一性原理思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>基于项目的实际需求、团队能力、维护成本等因素评估技术选型。&lt;/li>
&lt;li>评估技术的本质特性，选择最适合的技术，而非仅仅追求“潮流”。&lt;/li>
&lt;/ul>
&lt;h3 id="实践建议">实践建议
&lt;/h3>&lt;ol>
&lt;li>
&lt;p>&lt;strong>培养基础思维&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>深入学习计算机基础理论，掌握核心算法和数据结构。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>问题分析&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>在解决问题时，不急于采用现成方案，先深刻理解问题本质，分析基本约束和需求。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>方案设计&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>从基本原则出发，设计简洁且可维护的解决方案，注重系统的扩展性。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>持续优化&lt;/strong>：&lt;/p>
&lt;ul>
&lt;li>定期回顾和重构代码，关注系统的健康度，避免技术债务积累。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h3 id="总结">总结
&lt;/h3>&lt;p>运用&lt;strong>第一性原理&lt;/strong>思维，在软件开发中能够帮助我们：&lt;/p>
&lt;ul>
&lt;li>设计出更加优雅和高效的解决方案。&lt;/li>
&lt;li>构建更加可靠、可扩展的系统架构。&lt;/li>
&lt;li>编写更易维护的代码，解决更复杂的技术问题。&lt;/li>
&lt;/ul>
&lt;p>这种思维方式要求我们投入更多的时间和精力，但它所带来的长期收益是无可比拟的。因此，掌握并运用第一性原理，将是每个优秀开发者必须具备的能力。&lt;/p></description></item><item><title>Rust学习笔记01 - 所有权</title><link>https://blog.yellster.top/p/ownership/</link><pubDate>Mon, 09 Dec 2024 12:46:41 +0800</pubDate><author>xyp_selune@163.com (Yellster)</author><guid>https://blog.yellster.top/p/ownership/</guid><description>&lt;h2 id="所有权ownership">所有权，ownership
&lt;/h2>&lt;p>&lt;a class="link" href="https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html" target="_blank" rel="noopener"
>What is Ownership? - The Rust Programming Language (rust-lang.org)&lt;/a>&lt;/p>
&lt;h3 id="所有权规则">所有权规则
&lt;/h3>&lt;ul>
&lt;li>Rust 中的每一个值都有一个 &lt;strong>所有者&lt;/strong>（&lt;em>owner&lt;/em>）&lt;/li>
&lt;li>值在任一时刻有且只有一个所有者&lt;/li>
&lt;li>当所有者（变量）离开作用域，这个值将被丢弃，（例如，函数执行完）&lt;/li>
&lt;/ul>
&lt;h3 id="变量作用域">变量作用域
&lt;/h3>&lt;p>变量的作用域从声明开始，到最后一次使用的地方结束&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">    &lt;/span>&lt;span class="c1">// s 在这里无效，它尚未声明
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 从此处起，s 是有效的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">    &lt;/span>&lt;span class="fm">println!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 使用 s
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 此作用域已结束，s 不再有效
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>[!tip]&lt;/p>
&lt;ul>
&lt;li>当 &lt;code>s&lt;/code> &lt;strong>进入作用域&lt;/strong> 时，它就是有效的&lt;/li>
&lt;li>这一直持续到它 &lt;strong>离开作用域&lt;/strong> 为止&lt;/li>
&lt;/ul>&lt;/blockquote>
&lt;h3 id="内存与分配">内存与分配
&lt;/h3>&lt;p>在有 &lt;strong>垃圾回收&lt;/strong>（&lt;em>garbage collector&lt;/em>，&lt;em>GC&lt;/em>）的语言中，GC 记录并清除不再使用的内存，而我们并不需要关心它。
在大部分没有 GC 的语言中，识别出不再使用的内存并调用代码显式释放就是我们的责任了，跟请求内存的时候一样。
从历史的角度上说正确处理内存回收曾经是一个困难的编程问题。&lt;/p>
&lt;ul>
&lt;li>如果忘记回收了会浪费内存&lt;/li>
&lt;li>如果过早回收了，将会出现无效变量&lt;/li>
&lt;li>如果重复回收，这也是个 bug、&lt;/li>
&lt;li>我们需要精确的为一个 &lt;code>allocate&lt;/code> 配对一个 &lt;code>free&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>Rust 采取了一个不同的策略：内存在拥有它的变量离开作用域后就被自动释放。&lt;/strong>&lt;/p>
&lt;p>当变量离开作用域，Rust 为我们调用一个特殊的函数。这个函数叫做 &lt;a class="link" href="https://doc.rust-lang.org/std/ops/trait.Drop.html#tymethod.drop" target="_blank" rel="noopener"
>&lt;code>drop&lt;/code>&lt;/a>。
在这里 &lt;code>String&lt;/code> 的作者可以放置释放内存的代码，Rust 在结尾的 &lt;code>}&lt;/code> 处自动调用 &lt;code>drop&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="line">&lt;span class="cl">&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 从此处起，s 是有效的
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="c1">// 使用 s
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 此作用域已结束，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// s 不再有效
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>[!warning]
在 C++ 中，这种 item 在生命周期结束时释放资源的模式有时被称作 &lt;strong>资源获取即初始化&lt;/strong>（&lt;em>Resource Acquisition Is Initialization (RAII)&lt;/em>）&lt;/p>&lt;/blockquote>
&lt;h4 id="移动-变量与数据交互的方式">移动: 变量与数据交互的方式
&lt;/h4>&lt;p>在 Rust 中，多个变量可以采取不同的方式与同一数据进行交互。&lt;/p>
&lt;p>将变量 &lt;code>x&lt;/code> 的整数值赋给 &lt;code>y&lt;/code>：&lt;/p>
&lt;ul>
&lt;li>将 &lt;code>5&lt;/code> 绑定到 &lt;code>x&lt;/code>&lt;/li>
&lt;li>将 &lt;code>x&lt;/code> 的拷贝并绑定到 &lt;code>y&lt;/code>&lt;/li>
&lt;li>整数是有已知固定大小的简单值，所以这两个 &lt;code>5&lt;/code> 被放入了栈中&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在看看这个 &lt;code>String&lt;/code> 版本：
第二行可能会生成一个 &lt;code>s1&lt;/code> 的拷贝并绑定到 &lt;code>s2&lt;/code> 上。不过，事实上并不完全是这样&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>String&lt;/code> 由三部分组成&lt;/p>
&lt;ul>
&lt;li>左侧所示：
&lt;ul>
&lt;li>&lt;code>ptr&lt;/code>，指向存放字符串内容内存的指针&lt;/li>
&lt;li>&lt;code>len&lt;/code>，长度，表示当前 &lt;code>String&lt;/code> 内容使用了多少字符数&lt;/li>
&lt;li>&lt;code>capacity&lt;/code>，容量，表示当前 &lt;code>String&lt;/code> 内容从分配器总共获取了多少字节的内存&lt;/li>
&lt;li>&lt;code>capacity &amp;gt;= len&lt;/code>，&lt;code>capacity&lt;/code> 包括了为字符串内容预留的内存量，即使在字符串为空时也是如此&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>这一组数据存储在栈上，右侧则是堆上存放内容的内存部分
![[1.学习/1.开发语言/Rust/assets/trpl04-01.svg|300]]&lt;/li>
&lt;/ul>
&lt;p>当我们将 &lt;code>s1&lt;/code> 赋值给 &lt;code>s2&lt;/code>，&lt;code>String&lt;/code> 的数据被&lt;strong>复制&lt;/strong>了，这意味着我们从栈上拷贝了它的指针、长度和容量。
我们并没有复制指针指向的堆上数据。
![[1.学习/1.开发语言/Rust/assets/trpl04-02.svg|300]]&lt;/p>
&lt;p>如果 Rust 也&lt;strong>拷贝&lt;/strong>了堆上的数据，那么内存看起来就是这样的。
如果 Rust 这么做了，那么操作 &lt;code>s2 = s1&lt;/code> 在堆上数据比较大的时候会对运行时性能造成非常大的影响。
![[1.学习/1.开发语言/Rust/assets/trpl04-03.svg|300]]&lt;/p>
&lt;blockquote>
&lt;p>[!WANING]
当变量离开作用域后，Rust 自动调用 &lt;code>drop&lt;/code> 函数并清理变量的堆内存。
复制，两个数据指针指向了同一位置。
这就有了一个问题：当 &lt;code>s2&lt;/code> 和 &lt;code>s1&lt;/code> 离开作用域，它们都会尝试释放相同的内存。
这是一个叫做 &lt;strong>二次释放&lt;/strong>（&lt;em>double free&lt;/em>）的错误，也是之前提到过的内存安全性 bug 之一。
两次释放（相同）内存会导致内存污染，它可能会导致潜在的安全漏洞。&lt;/p>&lt;/blockquote>
&lt;p>为了确保内存安全，在 &lt;code>let s2 = s1;&lt;/code> 之后，Rust 认为 &lt;code>s1&lt;/code> 不再有效，因此 Rust 不需要在 &lt;code>s1&lt;/code> 离开作用域后清理任何东西。
这段代码不能运行：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="fm">println!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="si">{s1}&lt;/span>&lt;span class="s">, world!&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>你会得到一个类似如下的错误，因为 Rust 禁止你使用无效的引用。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">$ cargo run
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> Compiling ownership v0.1.0 &lt;span class="o">(&lt;/span>file:///projects/ownership&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">error&lt;span class="o">[&lt;/span>E0382&lt;span class="o">]&lt;/span>: borrow of moved value: &lt;span class="sb">`&lt;/span>s1&lt;span class="sb">`&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> --&amp;gt; kafka-producer/src/main.rs:16:15
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">14&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="nb">let&lt;/span> &lt;span class="nv">s1&lt;/span> &lt;span class="o">=&lt;/span> String::from&lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">|&lt;/span> -- move occurs because &lt;span class="sb">`&lt;/span>s1&lt;span class="sb">`&lt;/span> has &lt;span class="nb">type&lt;/span> &lt;span class="sb">`&lt;/span>String&lt;span class="sb">`&lt;/span>, which does not implement the &lt;span class="sb">`&lt;/span>Copy&lt;span class="sb">`&lt;/span> trait
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">15&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="nb">let&lt;/span> &lt;span class="nv">s2&lt;/span> &lt;span class="o">=&lt;/span> s1&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">|&lt;/span> -- value moved here
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">16&lt;/span> &lt;span class="p">|&lt;/span> println!&lt;span class="o">(&lt;/span>&lt;span class="s2">&amp;#34;{s1}, world!&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">|&lt;/span> ^^^^ value borrowed here after move
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">=&lt;/span> note: this error originates in the macro &lt;span class="sb">`&lt;/span>&lt;span class="nv">$crate&lt;/span>::format_args_nl&lt;span class="sb">`&lt;/span> which comes from the expansion of the macro &lt;span class="sb">`&lt;/span>println&lt;span class="sb">`&lt;/span> &lt;span class="o">(&lt;/span>in Nightly builds, run with -Z macro-backtrace &lt;span class="k">for&lt;/span> more info&lt;span class="o">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">help: consider cloning the value &lt;span class="k">if&lt;/span> the performance cost is acceptable
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">|&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="m">15&lt;/span> &lt;span class="p">|&lt;/span> &lt;span class="nb">let&lt;/span> &lt;span class="nv">s2&lt;/span> &lt;span class="o">=&lt;/span> s1.clone&lt;span class="o">()&lt;/span>&lt;span class="p">;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">|&lt;/span> ++++++++
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">For more information about this error, try &lt;span class="sb">`&lt;/span>rustc --explain E0382&lt;span class="sb">`&lt;/span>.
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">warning: &lt;span class="sb">`&lt;/span>kafka-producer&lt;span class="sb">`&lt;/span> &lt;span class="o">(&lt;/span>bin &lt;span class="s2">&amp;#34;kafka-producer&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> generated &lt;span class="m">1&lt;/span> warning
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">error: could not compile &lt;span class="sb">`&lt;/span>kafka-producer&lt;span class="sb">`&lt;/span> &lt;span class="o">(&lt;/span>bin &lt;span class="s2">&amp;#34;kafka-producer&amp;#34;&lt;/span>&lt;span class="o">)&lt;/span> due to &lt;span class="m">1&lt;/span> previous error
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;blockquote>
&lt;p>[!TIP]
如果你在其他语言中听说过术语 &lt;strong>浅拷贝&lt;/strong>（&lt;em>shallow copy&lt;/em>）和 &lt;strong>深拷贝&lt;/strong>（&lt;em>deep copy&lt;/em>），那么拷贝指针、长度和容量而不拷贝数据可能听起来像浅拷贝。
不过因为 Rust 同时使第一个变量无效了，这个操作被称为 &lt;strong>移动&lt;/strong>（&lt;em>move&lt;/em>），而不是叫做浅拷贝。
上面的例子可以解读为 &lt;code>s1&lt;/code> 被 &lt;strong>移动&lt;/strong> 到了 &lt;code>s2&lt;/code> 中。
![[1.学习/1.开发语言/Rust/assets/trpl04-04.svg|300]]&lt;/p>&lt;/blockquote>
&lt;p>这样就解决了我们的问题！因为只有 &lt;code>s2&lt;/code> 是有效的，当其离开作用域，它就释放自己的内存，完毕。&lt;/p>
&lt;p>另外，这里还隐含了一个设计选择：Rust 永远也不会自动创建数据的 “深拷贝”。
因此，任何 &lt;strong>自动&lt;/strong> 的复制都可以被认为是对运行时性能影响较小的。&lt;/p>
&lt;h4 id="克隆-变量与数据交互的方式">克隆: 变量与数据交互的方式
&lt;/h4>&lt;p>如果 &lt;strong>确实&lt;/strong> 需要深度复制 &lt;code>String&lt;/code> 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 &lt;code>clone&lt;/code> 的通用函数。&lt;/p>
&lt;p>这是一个实际使用 &lt;code>clone&lt;/code> 方法的例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">clone&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="fm">println!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;s1 = &lt;/span>&lt;span class="si">{s1}&lt;/span>&lt;span class="s">, s2 = &lt;/span>&lt;span class="si">{s2}&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这段代码能正常运行，这里堆上的数据 &lt;strong>确实&lt;/strong> 被复制了。
![[1.学习/1.开发语言/Rust/assets/trpl04-03.svg|300]]&lt;/p>
&lt;h4 id="拷贝-只在栈上的数据">拷贝: 只在栈上的数据
&lt;/h4>&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="line">&lt;span class="cl">&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="fm">println!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;x = &lt;/span>&lt;span class="si">{x}&lt;/span>&lt;span class="s">, y = &lt;/span>&lt;span class="si">{y}&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但这段代码似乎似乎和上面的内容相矛盾：没有调用 &lt;code>clone&lt;/code>，不过 &lt;code>x&lt;/code> 依然有效且没有被移动到 &lt;code>y&lt;/code> 中。&lt;/p>
&lt;p>原因是像整型这样的在编译时已知大小的类型被整个存储在栈上，所以拷贝其实际的值是快速的。&lt;strong>这意味着没有理由在创建变量 &lt;code>y&lt;/code> 后使 &lt;code>x&lt;/code> 无效&lt;/strong>。
换句话说，这里没有深浅拷贝的区别，所以这里调用 &lt;code>clone&lt;/code> 并不会与通常的浅拷贝有什么不同，可以不用管它。&lt;/p>
&lt;p>Rust 有一个叫做 &lt;code>Copy&lt;/code> trait 的特殊注解，可以用在类似整型这样的存储在栈上的类型上。
如果一个类型实现了 &lt;code>Copy&lt;/code> trait，那么一个旧的变量在将其赋值给其他变量后仍然可用。&lt;/p>
&lt;p>Rust 不允许自身或其任何部分实现了 &lt;code>Drop&lt;/code> trait 的类型使用 &lt;code>Copy&lt;/code> trait。
如果我们对其值离开作用域时需要特殊处理的类型使用 &lt;code>Copy&lt;/code> 注解，将会出现一个编译时错误。&lt;/p>
&lt;p>那么哪些类型实现了 &lt;code>Copy&lt;/code> trait 呢？你可以查看给定类型的文档来确认，不过作为一个通用的规则，任何一组简单标量值的组合都可以实现 &lt;code>Copy&lt;/code>，任何不需要分配内存或某种形式资源的类型都可以实现 &lt;code>Copy&lt;/code> 。如下是一些 &lt;code>Copy&lt;/code> 的类型：&lt;/p>
&lt;ul>
&lt;li>所有整数类型，比如 &lt;code>u32&lt;/code>。&lt;/li>
&lt;li>布尔类型，&lt;code>bool&lt;/code>，它的值是 &lt;code>true&lt;/code> 和 &lt;code>false&lt;/code>。&lt;/li>
&lt;li>所有浮点数类型，比如 &lt;code>f64&lt;/code>。&lt;/li>
&lt;li>字符类型，&lt;code>char&lt;/code>。&lt;/li>
&lt;li>元组，当且仅当其包含的类型也都实现 &lt;code>Copy&lt;/code> 的时候。比如，&lt;code>(i32, i32)&lt;/code> 实现了 &lt;code>Copy&lt;/code>，但 &lt;code>(i32, String)&lt;/code> 就没有。&lt;/li>
&lt;/ul>
&lt;h3 id="所有权与函数">所有权与函数
&lt;/h3>&lt;p>将值传递给函数与给变量赋值的原理相似。向函数传递值可能会移动或者复制，就像赋值语句一样。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// s 进入作用域
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">takes_ownership&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// s 的值移动到函数里 ...
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// ... 所以到这里不再有效
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">;&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// x 进入作用域
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">makes_copy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// x 应该移动函数里，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 但 i32 是 Copy 的，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 所以在后面可继续使用 x
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 这里，x 先移出了作用域，然后是 s。但因为 s 的值已被移走，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 没有特殊之处
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">takes_ownership&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">some_string&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// some_string 进入作用域
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="fm">println!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">some_string&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 这里，some_string 移出作用域并调用 `drop` 方法。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 占用的内存被释放
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">makes_copy&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">some_integer&lt;/span>: &lt;span class="kt">i32&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// some_integer 进入作用域
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="fm">println!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">some_integer&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 这里，some_integer 移出作用域。没有特殊之处
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当尝试在调用 &lt;code>takes_ownership&lt;/code> 后使用 &lt;code>s&lt;/code> 时，Rust 会抛出一个编译时错误。这些静态检查使我们免于犯错。&lt;/p>
&lt;h3 id="返回值与作用域">返回值与作用域
&lt;/h3>&lt;p>返回值也可以转移所有权。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">gives_ownership&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// gives_ownership 将返回值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 转移给 s1
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// s2 进入作用域
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s3&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">takes_and_gives_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// s2 被移动到
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// takes_and_gives_back 中，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 它也将返回值移给 s3
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 这里，s3 移出作用域并被丢弃。s2 也移出作用域，但已被移走，
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 所以什么也不会发生。s1 离开作用域并被丢弃
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">gives_ownership&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">String&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// gives_ownership 会将
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 返回值移动给
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 调用它的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">some_string&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;yours&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// some_string 进入作用域。
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">some_string&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 返回 some_string
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 并移出给调用的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="c1">// takes_and_gives_back 将传入字符串并返回该值
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">takes_and_gives_back&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a_string&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="nb">String&lt;/span> &lt;span class="p">{&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// a_string 进入作用域
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">//
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="n">a_string&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// 返回 a_string 并移出给调用的函数
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>变量的所有权总是遵循相同的模式：将值赋给另一个变量时移动它。
当持有堆中数据值的变量离开作用域时，其值将通过 &lt;code>drop&lt;/code> 被清理掉，除非数据被移动为另一个变量所有。&lt;/p>
&lt;p>虽然这样是可以的，但是在每一个函数中都获取所有权并接着返回所有权有些啰嗦。如果我们想要函数使用一个值但不获取所有权该怎么办呢？如果我们还要接着使用它的话，每次都传进去再返回来就有点烦人了，除此之外，我们也可能想返回函数体中产生的一些数据。&lt;/p>
&lt;p>我们可以使用元组来返回多个值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-rust" data-lang="rust">&lt;span class="line">&lt;span class="cl">&lt;span class="k">fn&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nb">String&lt;/span>::&lt;span class="n">from&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;hello&amp;#34;&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">calculate_length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s1&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="fm">println!&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;The length of &amp;#39;&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">&amp;#39; is &lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s">.&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s2&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">);&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="k">fn&lt;/span> &lt;span class="nf">calculate_length&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>: &lt;span class="nb">String&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>-&amp;gt; &lt;span class="p">(&lt;/span>&lt;span class="nb">String&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kt">usize&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="kd">let&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">len&lt;/span>&lt;span class="p">();&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c1">// len() 返回字符串的长度
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1">&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w"> &lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="w">&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="w">
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但是这未免有些形式主义，而且这种场景应该很常见。幸运的是，Rust 对此提供了一个不用获取所有权就可以使用值的功能，叫做 &lt;strong>引用&lt;/strong>（&lt;em>references&lt;/em>）。&lt;/p></description></item><item><title>Rust学习笔记00 - 开发工具和环境</title><link>https://blog.yellster.top/p/rust-development-environment/</link><pubDate>Sat, 19 Oct 2024 10:32:07 +0800</pubDate><author>xyp_selune@163.com (Yellster)</author><guid>https://blog.yellster.top/p/rust-development-environment/</guid><description>&lt;p>在开始 Rust 开发之旅之前，我们需要配置一个高效的开发环境。本文将详细介绍如何搭建一个完整的 Rust 开发环境，包括必要的工具和插件。&lt;/p>
&lt;h2 id="1-安装-rust">1. 安装 Rust
&lt;/h2>&lt;p>首先，我们需要安装 Rust 编程语言。使用以下命令安装 Rust：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">curl --proto &lt;span class="s1">&amp;#39;=https&amp;#39;&lt;/span> --tlsv1.2 -sSf https://sh.rustup.rs &lt;span class="p">|&lt;/span> sh
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个命令会安装 Rust 编译器（rustc）和包管理器（cargo）。&lt;/p>
&lt;h2 id="2-vscode-插件配置">2. VSCode 插件配置
&lt;/h2>&lt;p>VSCode 是推荐的 Rust 开发 IDE，以下是一些必备的插件：&lt;/p>
&lt;h3 id="核心插件">核心插件
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>rust-analyzer&lt;/strong>: Rust 语言支持，提供代码补全、类型检查等功能&lt;/li>
&lt;li>&lt;strong>crates&lt;/strong>: Rust 包管理工具&lt;/li>
&lt;li>&lt;strong>Even Better TOML&lt;/strong>: TOML 文件支持&lt;/li>
&lt;li>&lt;strong>Better Comments&lt;/strong>: 优化注释显示&lt;/li>
&lt;li>&lt;strong>Error Lens&lt;/strong>: 错误提示优化&lt;/li>
&lt;/ul>
&lt;h3 id="开发效率插件">开发效率插件
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>GitLens&lt;/strong>: Git 增强功能&lt;/li>
&lt;li>&lt;strong>Github Copilot&lt;/strong>: AI 代码提示&lt;/li>
&lt;li>&lt;strong>indent-rainbow&lt;/strong>: 缩进显示优化&lt;/li>
&lt;li>&lt;strong>Prettier&lt;/strong>: 代码格式化&lt;/li>
&lt;li>&lt;strong>REST client&lt;/strong>: REST API 调试工具&lt;/li>
&lt;/ul>
&lt;h3 id="测试相关插件">测试相关插件
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>Rust Test lens&lt;/strong>: Rust 测试支持&lt;/li>
&lt;li>&lt;strong>Rust Test Explorer&lt;/strong>: Rust 测试概览&lt;/li>
&lt;/ul>
&lt;h3 id="其他实用插件">其他实用插件
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>TODO Highlight&lt;/strong>: TODO 高亮&lt;/li>
&lt;li>&lt;strong>vscode-icons&lt;/strong>: 文件图标优化&lt;/li>
&lt;li>&lt;strong>YAML&lt;/strong>: YAML 文件支持&lt;/li>
&lt;/ul>
&lt;h2 id="3-开发工具链配置">3. 开发工具链配置
&lt;/h2>&lt;h3 id="cargo-generate">Cargo Generate
&lt;/h3>&lt;p>用于生成项目模板的工具：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cargo install cargo-generate
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>使用模板创建新项目：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cargo generate tyr-rust-bootcamp/template
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="pre-commit">Pre-commit
&lt;/h3>&lt;p>代码提交前的检查工具：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">pipx install pre-commit
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">pre-commit install
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="cargo-deny">Cargo Deny
&lt;/h3>&lt;p>依赖安全检查工具：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cargo install --locked cargo-deny
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="typos">Typos
&lt;/h3>&lt;p>拼写检查工具：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cargo install typos-cli
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="git-cliff">Git Cliff
&lt;/h3>&lt;p>生成 changelog 的工具：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cargo install git-cliff
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="cargo-nextest">Cargo Nextest
&lt;/h3>&lt;p>增强的测试工具：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">cargo install cargo-nextest --locked
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="总结">总结
&lt;/h2>&lt;p>配置一个完整的 Rust 开发环境需要安装多个工具和插件。这些工具共同构成了一个高效的开发工作流：&lt;/p>
&lt;ol>
&lt;li>使用 rust-analyzer 提供智能的代码补全和错误检查&lt;/li>
&lt;li>通过 pre-commit 确保代码质量&lt;/li>
&lt;li>使用 cargo-deny 保证依赖安全&lt;/li>
&lt;li>借助 cargo-nextest 进行高效的测试&lt;/li>
&lt;/ol>
&lt;p>这些工具的组合使用可以显著提升 Rust 开发效率和代码质量。建议根据实际需求选择性地安装这些工具，不必一次性全部配置。&lt;/p></description></item></channel></rss>