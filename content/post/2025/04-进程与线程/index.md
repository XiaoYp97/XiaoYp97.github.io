---
title: "进程与线程"
description:
date: "2025-04-11T13:38:57+08:00"
slug: "process-thread"
image: "process-thread.webp"
license: false
hidden: false
comments: false
draft: false
tags: ["Linux", "进程", "线程", "操作系统", "虚拟地址", "协程"]
categories: ["Linux", "操作系统"]
# weight: 1 # You can add weight to some posts to override the default sorting (date descending)
---

在现代操作系统中，**进程**、**线程**和**虚拟地址**是支撑高效执行、内存管理与资源隔离的三大核心概念。它们相互配合，共同保证系统的稳定性、安全性与并发性能。

## 进程：资源隔离与调度的基本单位

### 概念

- **进程**：正在运行的程序实例，拥有独立的地址空间、数据段、堆与栈，以及各类系统资源（文件描述符、信号、IPC 对象等）。

### 创建与执行

- **创建**：Linux 中通过 `fork()` 复制父进程，再用 `exec()` 系列函数加载新程序。
  - **fork()——复制当前进程**

    父进程调用 `fork()`，内核在后台复制出一个“子进程”，这个子进程和父进程几乎一模一样（地址空间、打开的文件描述符等都拷贝或共享）。
  - **execve()（或其它 exec\* 系列函数）——在子进程里加载新程序**

    子进程中立即调用 `execve("/path/to/newprog", argv, envp)`，内核就会丢弃掉原来的地址空间，把可执行文件 `/path/to/newprog` 映射进来，初始化全新的代码段、数据段、堆栈，真正运行“一个全新的进程镜像”。

- **调度**：内核调度器（scheduler）负责分配 CPU 时间片，维护多任务并发运行。

### 进程间通信（IPC）

由于进程地址空间独立，IPC 机制尤为重要：

| 方式           | 场景                   | 优势                   | 注意点                       |
| -------------- | ---------------------- | ---------------------- | ---------------------------- |
| 管道（Pipe）   | 父子进程               | 简单、快速             | 仅限亲缘进程，单向           |
| 命名管道       | 任意本地进程           | 双向、可见文件系统     | 性能略低                     |
| 消息队列       | 异步通信               | 支持优先级、可靠传输   | 大量小消息时开销增大         |
| 共享内存       | 大块数据交换           | 零拷贝、高吞吐         | 需同步机制（锁、信号量）     |
| 套接字（Socket）| 本地／跨网络进程       | 灵活、多协议           | 网络开销相对较大             |
| 信号（Signal） | 异步通知               | 轻量级、实时性好       | 数据传输能力有限             |

> **IPC（进程间通信，Inter-Process Communication）** 是指在操作系统中，不同进程之间为交换数据或进行同步而提供的一系列机制。
>
> 由于操作系统给每个进程分配了独立的地址空间，直接读写对方内存是不被允许的，IPC 就是为了解决“**进程如何安全、高效地互相协作**”而产生的。

## 线程：轻量级执行流与并行处理

### 概念

- **线程**：依附于进程的执行单元，共享进程的地址空间和大部分资源，但拥有各自的寄存器上下文和栈。

### 创建与管理

- **Linux 实现**：基于 `clone()` 系统调用；POSIX 线程库（pthread）提供了更友好的 API。
- **切换开销**：比进程轻量，适用于高并发场景。

### 并发挑战

- **竞态条件**：无同步的并发访问可能导致数据不一致。
- **死锁**：多线程间相互等待锁时出现永久阻塞。
- **活锁与饥饿**：线程过度谦让或被长期剥夺执行机会。

> **示例**（Rust 风格伪代码）：
>
> ```rust
> let counter = Arc::new(Mutex::new(0));
> let handles: Vec<_> = (0..10).map(|_| {
>     let c = Arc::clone(&counter);
>     thread::spawn(move || {
>         let mut num = c.lock().unwrap();
>         *num += 1;
>     })
> }).collect();
> for h in handles { h.join().unwrap(); }
> println!("Result: {}", *counter.lock().unwrap());
> ```

## 虚拟地址：抽象内存与安全保护

### 概念

- **虚拟地址**：操作系统为每个进程提供的连续逻辑地址空间，与物理内存无直接一一映射。

### 管理机制

1. **分页（Paging）**
   - **页大小**：通常 4 KB，也有大页（2 MB/1 GB）。
   - **多级页表**：如 x86_64 的 4 级页表，减少内存占用。
2. **地址转换**

   ```text
   虚拟地址 = [页目录索引][页表索引][页内偏移]
   物理地址 = 页框号 + 偏移
   ```

   - 通过 MMU 与 TLB 快速完成转换。
3. **保护与优化**
   - **访问权限**：读/写/执行标志。
   - **用户/内核隔离**：防止越权访问。
   - **写时复制（COW）**：延迟复制，降低 fork 开销。

### 能当做 IPC 吗？

- **虚拟地址本身不共享**，不能直接跨进程使用。
- **共享内存** 或 **mmap(MAP_SHARED)** 是利用虚拟地址“映射”同一段物理页到不同进程，从而实现高效的 IPC。
- 你只需要在各自进程里拿到映射后自己的虚拟指针，就能像访问本地内存一样进行读写。

## 协程：更轻量的用户态并发

### 概念

- **协程（Coroutine）**：用户态的轻量级执行单元，又称“微线程”或“纤程”。它在单线程内通过显式的调度点（yield）实现多任务切换，无需内核参与。

### 特点

| 特性           | 线程                     | 协程                         |
| -------------- | ------------------------ | ---------------------------- |
| 调度           | 内核调度（抢占式）       | 用户态调度（协作式）         |
| 上下文切换开销 | 高（进入内核，保存/恢复寄存器、内核栈） | 低（仅保存/恢复少量寄存器和用户栈指针） |
| 通信           | 共享内存需锁、IPC        | 函数调用/Channel/队列 等     |
| 并发规模       | 受限于内核线程数         | 数万乃至数十万轻松支持       |

### 调度模型

- **协作式**：运行到显式 `yield` 或 `await` 才切换，开发者可精确控制切换点。
- **预emptive（部分语言支持）**：语言运行时定期打断协程，但大多数主流实现（如 Python、Go）采用协作式。

### 常见实现

- **Go**：goroutine + M:N 调度，M 代表系统线程，N 代表用户协程，由 runtime 自动分配。
- **Python**：`async def` + `await`，基于事件循环（`asyncio`）或第三方库（如 Trio、Curio）。
- **Rust**：`async/await` + Futures + executor（如 Tokio、async-std），通过状态机驱动。
- **JavaScript**：基于事件循环的 Promise + `async/await`，单线程协程模型。

### 应用场景

- **高并发 I/O**：Web 服务器、爬虫、网络代理等，常用事件驱动 + 协程模型实现百万级并发。
- **异步任务流**：管道化处理、大量小任务的并行调度。
- **可控并发**：无需锁或细粒度锁，简化并发控制。

## 四者对比与协同

| 模型   | 调度方式     | 切换开销     | 共享资源       | 适用场景                 |
| ------ | ------------ | ------------ | -------------- | ------------------------ |
| 进程   | 内核（抢占） | 最大         | 无（需 IPC）   | 资源隔离、强隔离需求     |
| 线程   | 内核（抢占） | 较大         | 共享进程资源   | CPU 并行、I/O 并发       |
| 协程   | 用户（协作） | 最小         | 共享线程资源   | 海量并发 I/O、异步流程   |
| 虚拟地址 | ——           | ——           | ——             | 为进程/线程/协程提供统一内存抽象 |

- **进程** 提供最强隔离。
- **线程** 在同一地址空间内并行。
- **协程** 在单线程内更高效地调度。
- **虚拟地址** 是上述模型的基础，屏蔽物理内存复杂性并提供保护。

### 应用场景选型

| 场景                | 建议方案                                               |
| ------------------ | ----------------------------------------------------- |
| 资源隔离优先         | 对安全或稳定性要求极高的组件，首选进程                       |
| 并行计算            | CPU 密集任务可用多进程或多线程                             |
| 高并发 I/O          | 首选协程框架，结合事件驱动（如 epoll、kqueue）              |
| 混合模式            | Web 服务常用 “多进程 + 协程” 的组合：进程隔离，协程高并发     |

## 总结

- **进程**、**线程** 和 **协程** 是三种层次不同的并发单元，各自有取舍。
- **虚拟地址** 为它们提供了统一、隔离且安全的内存视图。
- 在实际系统设计中，合理组合使用，才能兼顾隔离性、并发性与性能，打造高性能、高可靠的应用架构。
