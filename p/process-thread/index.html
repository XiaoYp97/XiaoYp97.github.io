<!doctype html><html lang=zh-cn dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='在现代操作系统中，进程、线程和虚拟地址是支撑高效执行、内存管理与资源隔离的三大核心概念。它们相互配合，共同保证系统的稳定性、安全性与并发性能。\n进程：资源隔离与调度的基本单位 概念 进程：正在运行的程序实例，拥有独立的地址空间、数据段、堆与栈，以及各类系统资源（文件描述符、信号、IPC 对象等）。 创建与执行 创建：Linux 中通过 fork() 复制父进程，再用 exec() 系列函数加载新程序。\nfork()——复制当前进程\n父进程调用 fork()，内核在后台复制出一个“子进程”，这个子进程和父进程几乎一模一样（地址空间、打开的文件描述符等都拷贝或共享）。\nexecve()（或其它 exec* 系列函数）——在子进程里加载新程序\n子进程中立即调用 execve("/path/to/newprog", argv, envp)，内核就会丢弃掉原来的地址空间，把可执行文件 /path/to/newprog 映射进来，初始化全新的代码段、数据段、堆栈，真正运行“一个全新的进程镜像”。\n调度：内核调度器（scheduler）负责分配 CPU 时间片，维护多任务并发运行。\n进程间通信（IPC） 由于进程地址空间独立，IPC 机制尤为重要：\n方式 场景 优势 注意点 管道（Pipe） 父子进程 简单、快速 仅限亲缘进程，单向 命名管道 任意本地进程 双向、可见文件系统 性能略低 消息队列 异步通信 支持优先级、可靠传输 大量小消息时开销增大 共享内存 大块数据交换 零拷贝、高吞吐 需同步机制（锁、信号量） 套接字（Socket） 本地／跨网络进程 灵活、多协议 网络开销相对较大 信号（Signal） 异步通知 轻量级、实时性好 数据传输能力有限 IPC（进程间通信，Inter-Process Communication） 是指在操作系统中，不同进程之间为交换数据或进行同步而提供的一系列机制。\n由于操作系统给每个进程分配了独立的地址空间，直接读写对方内存是不被允许的，IPC 就是为了解决“进程如何安全、高效地互相协作”而产生的。\n线程：轻量级执行流与并行处理 概念 线程：依附于进程的执行单元，共享进程的地址空间和大部分资源，但拥有各自的寄存器上下文和栈。 创建与管理 Linux 实现：基于 clone() 系统调用；POSIX 线程库（pthread）提供了更友好的 API。 切换开销：比进程轻量，适用于高并发场景。 并发挑战 竞态条件：无同步的并发访问可能导致数据不一致。 死锁：多线程间相互等待锁时出现永久阻塞。 活锁与饥饿：线程过度谦让或被长期剥夺执行机会。 示例（Rust 风格伪代码）：\n'><title>进程与线程</title><link rel=canonical href=https://blog.yellster.top/p/process-thread/><link rel=stylesheet href=/scss/style.min.946cca6c6259ef94ac55abfae7c7bf3291ea3ed5eea17ef77500b257217c6710.css><meta property='og:title' content="进程与线程"><meta property='og:description' content='在现代操作系统中，进程、线程和虚拟地址是支撑高效执行、内存管理与资源隔离的三大核心概念。它们相互配合，共同保证系统的稳定性、安全性与并发性能。\n进程：资源隔离与调度的基本单位 概念 进程：正在运行的程序实例，拥有独立的地址空间、数据段、堆与栈，以及各类系统资源（文件描述符、信号、IPC 对象等）。 创建与执行 创建：Linux 中通过 fork() 复制父进程，再用 exec() 系列函数加载新程序。\nfork()——复制当前进程\n父进程调用 fork()，内核在后台复制出一个“子进程”，这个子进程和父进程几乎一模一样（地址空间、打开的文件描述符等都拷贝或共享）。\nexecve()（或其它 exec* 系列函数）——在子进程里加载新程序\n子进程中立即调用 execve("/path/to/newprog", argv, envp)，内核就会丢弃掉原来的地址空间，把可执行文件 /path/to/newprog 映射进来，初始化全新的代码段、数据段、堆栈，真正运行“一个全新的进程镜像”。\n调度：内核调度器（scheduler）负责分配 CPU 时间片，维护多任务并发运行。\n进程间通信（IPC） 由于进程地址空间独立，IPC 机制尤为重要：\n方式 场景 优势 注意点 管道（Pipe） 父子进程 简单、快速 仅限亲缘进程，单向 命名管道 任意本地进程 双向、可见文件系统 性能略低 消息队列 异步通信 支持优先级、可靠传输 大量小消息时开销增大 共享内存 大块数据交换 零拷贝、高吞吐 需同步机制（锁、信号量） 套接字（Socket） 本地／跨网络进程 灵活、多协议 网络开销相对较大 信号（Signal） 异步通知 轻量级、实时性好 数据传输能力有限 IPC（进程间通信，Inter-Process Communication） 是指在操作系统中，不同进程之间为交换数据或进行同步而提供的一系列机制。\n由于操作系统给每个进程分配了独立的地址空间，直接读写对方内存是不被允许的，IPC 就是为了解决“进程如何安全、高效地互相协作”而产生的。\n线程：轻量级执行流与并行处理 概念 线程：依附于进程的执行单元，共享进程的地址空间和大部分资源，但拥有各自的寄存器上下文和栈。 创建与管理 Linux 实现：基于 clone() 系统调用；POSIX 线程库（pthread）提供了更友好的 API。 切换开销：比进程轻量，适用于高并发场景。 并发挑战 竞态条件：无同步的并发访问可能导致数据不一致。 死锁：多线程间相互等待锁时出现永久阻塞。 活锁与饥饿：线程过度谦让或被长期剥夺执行机会。 示例（Rust 风格伪代码）：\n'><meta property='og:url' content='https://blog.yellster.top/p/process-thread/'><meta property='og:site_name' content='Yellster - Blog'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Linux'><meta property='article:tag' content='进程'><meta property='article:tag' content='线程'><meta property='article:tag' content='操作系统'><meta property='article:tag' content='虚拟地址'><meta property='article:tag' content='协程'><meta property='article:published_time' content='2025-04-11T13:38:57+08:00'><meta property='article:modified_time' content='2025-04-11T13:38:57+08:00'><meta property='og:image' content='https://blog.yellster.top/p/process-thread/process-thread.webp'><meta name=twitter:title content="进程与线程"><meta name=twitter:description content='在现代操作系统中，进程、线程和虚拟地址是支撑高效执行、内存管理与资源隔离的三大核心概念。它们相互配合，共同保证系统的稳定性、安全性与并发性能。\n进程：资源隔离与调度的基本单位 概念 进程：正在运行的程序实例，拥有独立的地址空间、数据段、堆与栈，以及各类系统资源（文件描述符、信号、IPC 对象等）。 创建与执行 创建：Linux 中通过 fork() 复制父进程，再用 exec() 系列函数加载新程序。\nfork()——复制当前进程\n父进程调用 fork()，内核在后台复制出一个“子进程”，这个子进程和父进程几乎一模一样（地址空间、打开的文件描述符等都拷贝或共享）。\nexecve()（或其它 exec* 系列函数）——在子进程里加载新程序\n子进程中立即调用 execve("/path/to/newprog", argv, envp)，内核就会丢弃掉原来的地址空间，把可执行文件 /path/to/newprog 映射进来，初始化全新的代码段、数据段、堆栈，真正运行“一个全新的进程镜像”。\n调度：内核调度器（scheduler）负责分配 CPU 时间片，维护多任务并发运行。\n进程间通信（IPC） 由于进程地址空间独立，IPC 机制尤为重要：\n方式 场景 优势 注意点 管道（Pipe） 父子进程 简单、快速 仅限亲缘进程，单向 命名管道 任意本地进程 双向、可见文件系统 性能略低 消息队列 异步通信 支持优先级、可靠传输 大量小消息时开销增大 共享内存 大块数据交换 零拷贝、高吞吐 需同步机制（锁、信号量） 套接字（Socket） 本地／跨网络进程 灵活、多协议 网络开销相对较大 信号（Signal） 异步通知 轻量级、实时性好 数据传输能力有限 IPC（进程间通信，Inter-Process Communication） 是指在操作系统中，不同进程之间为交换数据或进行同步而提供的一系列机制。\n由于操作系统给每个进程分配了独立的地址空间，直接读写对方内存是不被允许的，IPC 就是为了解决“进程如何安全、高效地互相协作”而产生的。\n线程：轻量级执行流与并行处理 概念 线程：依附于进程的执行单元，共享进程的地址空间和大部分资源，但拥有各自的寄存器上下文和栈。 创建与管理 Linux 实现：基于 clone() 系统调用；POSIX 线程库（pthread）提供了更友好的 API。 切换开销：比进程轻量，适用于高并发场景。 并发挑战 竞态条件：无同步的并发访问可能导致数据不一致。 死锁：多线程间相互等待锁时出现永久阻塞。 活锁与饥饿：线程过度谦让或被长期剥夺执行机会。 示例（Rust 风格伪代码）：\n'><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content='https://blog.yellster.top/p/process-thread/process-thread.webp'><link rel="shortcut icon" href=https://avatars.githubusercontent.com/u/37898221></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky compact"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src="https://avatars.githubusercontent.com/u/37898221?v=4" width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🇨🇳</span></figure><div class=site-meta><h1 class=site-name><a href=/>Yellster - Blog</a></h1><h2 class=site-description>想都是问题，做才是答案</h2></div></header><ol class=menu-social><li><a href=https://github.com/Yellster target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/about/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>首页</span></a></li><li><a href=/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li><a href=/links/><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>链接</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#进程资源隔离与调度的基本单位>进程：资源隔离与调度的基本单位</a><ol><li><a href=#概念>概念</a></li><li><a href=#创建与执行>创建与执行</a></li><li><a href=#进程间通信ipc>进程间通信（IPC）</a></li></ol></li><li><a href=#线程轻量级执行流与并行处理>线程：轻量级执行流与并行处理</a><ol><li><a href=#概念-1>概念</a></li><li><a href=#创建与管理>创建与管理</a></li><li><a href=#并发挑战>并发挑战</a></li></ol></li><li><a href=#虚拟地址抽象内存与安全保护>虚拟地址：抽象内存与安全保护</a><ol><li><a href=#概念-2>概念</a></li><li><a href=#管理机制>管理机制</a></li><li><a href=#能当做-ipc-吗>能当做 IPC 吗？</a></li></ol></li><li><a href=#协程更轻量的用户态并发>协程：更轻量的用户态并发</a><ol><li><a href=#概念-3>概念</a></li><li><a href=#特点>特点</a></li><li><a href=#调度模型>调度模型</a></li><li><a href=#常见实现>常见实现</a></li><li><a href=#应用场景>应用场景</a></li></ol></li><li><a href=#四者对比与协同>四者对比与协同</a><ol><li><a href=#应用场景选型>应用场景选型</a></li></ol></li><li><a href=#总结>总结</a></li><li><a href=#进程调度算法>进程调度算法</a><ol><li><a href=#非抢占式调度>非抢占式调度</a></li><li><a href=#抢占式调度>抢占式调度</a></li><li><a href=#现代与实时调度>现代与实时调度</a></li><li><a href=#选择与权衡>选择与权衡</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class="has-image main-article"><header class=article-header><div class=article-image><a href=/p/process-thread/><img src=/p/process-thread/process-thread_hu_ff6299e29f32ffa0.webp srcset="/p/process-thread/process-thread_hu_ff6299e29f32ffa0.webp 800w, /p/process-thread/process-thread_hu_1dcef21f65a31373.webp 1600w" width=800 height=800 loading=lazy alt="Featured image of post 进程与线程"></a></div><div class=article-details><header class=article-category><a href=/categories/linux/>Linux
</a><a href=/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/process-thread/>进程与线程</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>2025-04-11</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 3 分钟</time></div></footer></div></header><section class=article-content><p>在现代操作系统中，<strong>进程</strong>、<strong>线程</strong>和<strong>虚拟地址</strong>是支撑高效执行、内存管理与资源隔离的三大核心概念。它们相互配合，共同保证系统的稳定性、安全性与并发性能。</p><h2 id=进程资源隔离与调度的基本单位>进程：资源隔离与调度的基本单位</h2><h3 id=概念>概念</h3><ul><li><strong>进程</strong>：正在运行的程序实例，拥有独立的地址空间、数据段、堆与栈，以及各类系统资源（文件描述符、信号、IPC 对象等）。</li></ul><h3 id=创建与执行>创建与执行</h3><ul><li><p><strong>创建</strong>：Linux 中通过 <code>fork()</code> 复制父进程，再用 <code>exec()</code> 系列函数加载新程序。</p><ul><li><p><strong>fork()——复制当前进程</strong></p><p>父进程调用 <code>fork()</code>，内核在后台复制出一个“子进程”，这个子进程和父进程几乎一模一样（地址空间、打开的文件描述符等都拷贝或共享）。</p></li><li><p><strong>execve()（或其它 exec* 系列函数）——在子进程里加载新程序</strong></p><p>子进程中立即调用 <code>execve("/path/to/newprog", argv, envp)</code>，内核就会丢弃掉原来的地址空间，把可执行文件 <code>/path/to/newprog</code> 映射进来，初始化全新的代码段、数据段、堆栈，真正运行“一个全新的进程镜像”。</p></li></ul></li><li><p><strong>调度</strong>：内核调度器（scheduler）负责分配 CPU 时间片，维护多任务并发运行。</p></li></ul><h3 id=进程间通信ipc>进程间通信（IPC）</h3><p>由于进程地址空间独立，IPC 机制尤为重要：</p><div class=table-wrapper><table><thead><tr><th>方式</th><th>场景</th><th>优势</th><th>注意点</th></tr></thead><tbody><tr><td>管道（Pipe）</td><td>父子进程</td><td>简单、快速</td><td>仅限亲缘进程，单向</td></tr><tr><td>命名管道</td><td>任意本地进程</td><td>双向、可见文件系统</td><td>性能略低</td></tr><tr><td>消息队列</td><td>异步通信</td><td>支持优先级、可靠传输</td><td>大量小消息时开销增大</td></tr><tr><td>共享内存</td><td>大块数据交换</td><td><a class=link href=/p/zero-copy/>零拷贝</a>、高吞吐</td><td>需同步机制（锁、信号量）</td></tr><tr><td>套接字（Socket）</td><td>本地／跨网络进程</td><td>灵活、多协议</td><td>网络开销相对较大</td></tr><tr><td>信号（Signal）</td><td>异步通知</td><td>轻量级、实时性好</td><td>数据传输能力有限</td></tr></tbody></table></div><blockquote><p><strong>IPC（进程间通信，Inter-Process Communication）</strong> 是指在操作系统中，不同进程之间为交换数据或进行同步而提供的一系列机制。</p><p>由于操作系统给每个进程分配了独立的地址空间，直接读写对方内存是不被允许的，IPC 就是为了解决“<strong>进程如何安全、高效地互相协作</strong>”而产生的。</p></blockquote><h2 id=线程轻量级执行流与并行处理>线程：轻量级执行流与并行处理</h2><h3 id=概念-1>概念</h3><ul><li><strong>线程</strong>：依附于进程的执行单元，共享进程的地址空间和大部分资源，但拥有各自的寄存器上下文和栈。</li></ul><h3 id=创建与管理>创建与管理</h3><ul><li><strong>Linux 实现</strong>：基于 <code>clone()</code> 系统调用；POSIX 线程库（pthread）提供了更友好的 API。</li><li><strong>切换开销</strong>：比进程轻量，适用于高并发场景。</li></ul><h3 id=并发挑战>并发挑战</h3><ul><li><strong>竞态条件</strong>：无同步的并发访问可能导致数据不一致。</li><li><strong>死锁</strong>：多线程间相互等待锁时出现永久阻塞。</li><li><strong>活锁与饥饿</strong>：线程过度谦让或被长期剥夺执行机会。</li></ul><blockquote><p><strong>示例</strong>（Rust 风格伪代码）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=kd>let</span><span class=w> </span><span class=n>counter</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arc</span>::<span class=n>new</span><span class=p>(</span><span class=n>Mutex</span>::<span class=n>new</span><span class=p>(</span><span class=mi>0</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=kd>let</span><span class=w> </span><span class=n>handles</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>_</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=mi>0</span><span class=o>..</span><span class=mi>10</span><span class=p>).</span><span class=n>map</span><span class=p>(</span><span class=o>|</span><span class=n>_</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>c</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Arc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>counter</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>thread</span>::<span class=n>spawn</span><span class=p>(</span><span class=k>move</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>num</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>c</span><span class=p>.</span><span class=n>lock</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>*</span><span class=n>num</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>})</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}).</span><span class=n>collect</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=n>h</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>handles</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>h</span><span class=p>.</span><span class=n>join</span><span class=p>().</span><span class=n>unwrap</span><span class=p>();</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=fm>println!</span><span class=p>(</span><span class=s>&#34;Result: </span><span class=si>{}</span><span class=s>&#34;</span><span class=p>,</span><span class=w> </span><span class=o>*</span><span class=n>counter</span><span class=p>.</span><span class=n>lock</span><span class=p>().</span><span class=n>unwrap</span><span class=p>());</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div></blockquote><h2 id=虚拟地址抽象内存与安全保护>虚拟地址：抽象内存与安全保护</h2><h3 id=概念-2>概念</h3><ul><li><strong>虚拟地址</strong>：操作系统为每个进程提供的连续逻辑地址空间，与物理内存无直接一一映射。</li></ul><h3 id=管理机制>管理机制</h3><ol><li><p><strong>分页（Paging）</strong></p><ul><li><strong>页大小</strong>：通常 4 KB，也有大页（2 MB/1 GB）。</li><li><strong>多级页表</strong>：如 x86_64 的 4 级页表，减少内存占用。</li></ul></li><li><p><strong>地址转换</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>虚拟地址 = [页目录索引][页表索引][页内偏移]
</span></span><span class=line><span class=cl>物理地址 = 页框号 + 偏移
</span></span></code></pre></td></tr></table></div></div><ul><li>通过 MMU 与 TLB 快速完成转换。</li></ul></li><li><p><strong>保护与优化</strong></p><ul><li><strong>访问权限</strong>：读/写/执行标志。</li><li><strong>用户/内核隔离</strong>：防止越权访问。</li><li><strong>写时复制（COW）</strong>：延迟复制，降低 fork 开销。</li></ul></li></ol><h3 id=能当做-ipc-吗>能当做 IPC 吗？</h3><ul><li><strong>虚拟地址本身不共享</strong>，不能直接跨进程使用。</li><li><strong>共享内存</strong> 或 <strong>mmap(MAP_SHARED)</strong> 是利用虚拟地址“映射”同一段物理页到不同进程，从而实现高效的 IPC。</li><li>你只需要在各自进程里拿到映射后自己的虚拟指针，就能像访问本地内存一样进行读写。</li></ul><h2 id=协程更轻量的用户态并发>协程：更轻量的用户态并发</h2><h3 id=概念-3>概念</h3><ul><li><strong>协程（Coroutine）</strong>：用户态的轻量级执行单元，又称“微线程”或“纤程”。它在单线程内通过显式的调度点（yield）实现多任务切换，无需内核参与。</li></ul><h3 id=特点>特点</h3><div class=table-wrapper><table><thead><tr><th>特性</th><th>线程</th><th>协程</th></tr></thead><tbody><tr><td>调度</td><td>内核调度（抢占式）</td><td>用户态调度（协作式）</td></tr><tr><td>上下文切换开销</td><td>高（进入内核，保存/恢复寄存器、内核栈）</td><td>低（仅保存/恢复少量寄存器和用户栈指针）</td></tr><tr><td>通信</td><td>共享内存需锁、IPC</td><td>函数调用/Channel/队列 等</td></tr><tr><td>并发规模</td><td>受限于内核线程数</td><td>数万乃至数十万轻松支持</td></tr></tbody></table></div><h3 id=调度模型>调度模型</h3><ul><li><strong>协作式</strong>：运行到显式 <code>yield</code> 或 <code>await</code> 才切换，开发者可精确控制切换点。</li><li><strong>预emptive（部分语言支持）</strong>：语言运行时定期打断协程，但大多数主流实现（如 Python、Go）采用协作式。</li></ul><h3 id=常见实现>常见实现</h3><ul><li><strong>Go</strong>：goroutine + M:N 调度，M 代表系统线程，N 代表用户协程，由 runtime 自动分配。</li><li><strong>Python</strong>：<code>async def</code> + <code>await</code>，基于事件循环（<code>asyncio</code>）或第三方库（如 Trio、Curio）。</li><li><strong>Rust</strong>：<code>async/await</code> + Futures + executor（如 Tokio、async-std），通过状态机驱动。</li><li><strong>JavaScript</strong>：基于事件循环的 Promise + <code>async/await</code>，单线程协程模型。</li></ul><h3 id=应用场景>应用场景</h3><ul><li><strong>高并发 I/O</strong>：Web 服务器、爬虫、网络代理等，常用事件驱动 + 协程模型实现百万级并发。</li><li><strong>异步任务流</strong>：管道化处理、大量小任务的并行调度。</li><li><strong>可控并发</strong>：无需锁或细粒度锁，简化并发控制。</li></ul><h2 id=四者对比与协同>四者对比与协同</h2><div class=table-wrapper><table><thead><tr><th>模型</th><th>调度方式</th><th>切换开销</th><th>共享资源</th><th>适用场景</th></tr></thead><tbody><tr><td>进程</td><td>内核（抢占）</td><td>最大</td><td>无（需 IPC）</td><td>资源隔离、强隔离需求</td></tr><tr><td>线程</td><td>内核（抢占）</td><td>较大</td><td>共享进程资源</td><td>CPU 并行、I/O 并发</td></tr><tr><td>协程</td><td>用户（协作）</td><td>最小</td><td>共享线程资源</td><td>海量并发 I/O、异步流程</td></tr><tr><td>虚拟地址</td><td>——</td><td>——</td><td>——</td><td>为进程/线程/协程提供统一内存抽象</td></tr></tbody></table></div><ul><li><strong>进程</strong>： <strong>是资源分配的基本单位</strong>，每个进程都有独立的内存空间（代码段、数据段、堆栈等），提供最强隔离。</li><li><strong>线程</strong>： <strong>是 CPU 调度的基本单位</strong>，属于进程，一个进程可以包含多个线程。共享进程的内存空间和资源（文件句柄、数据段等）在同一地址空间内并行。</li><li><strong>协程</strong>： 在单线程内更高效地调度。</li><li><strong>虚拟地址</strong>： 是上述模型的基础，屏蔽物理内存复杂性并提供保护。</li></ul><h3 id=应用场景选型>应用场景选型</h3><div class=table-wrapper><table><thead><tr><th>场景</th><th>建议方案</th></tr></thead><tbody><tr><td>资源隔离优先</td><td>对安全或稳定性要求极高的组件，首选进程</td></tr><tr><td>并行计算</td><td>CPU 密集任务可用多进程或多线程</td></tr><tr><td>高并发 I/O</td><td>首选协程框架，结合事件驱动（如 epoll、kqueue）</td></tr><tr><td>混合模式</td><td>Web 服务常用 “多进程 + 协程” 的组合：进程隔离，协程高并发</td></tr></tbody></table></div><h2 id=总结>总结</h2><ul><li><strong>进程</strong>、<strong>线程</strong> 和 <strong>协程</strong> 是三种层次不同的并发单元，各自有取舍。</li><li><strong>虚拟地址</strong> 为它们提供了统一、隔离且安全的内存视图。</li><li>在实际系统设计中，合理组合使用，才能兼顾隔离性、并发性与性能，打造高性能、高可靠的应用架构。</li></ul><h2 id=进程调度算法>进程调度算法</h2><h3 id=非抢占式调度>非抢占式调度</h3><ol><li><p><strong>先来先服务（FCFS）</strong></p><ul><li><strong>原理</strong>：按进程到达就绪队列的先后顺序依次调度，类似队列排队。</li><li><strong>优点</strong>：简单易实现；无饥饿。</li><li><strong>缺点</strong>：平均等待时间不一定最短，易出现“短作业后面跟长作业”拖慢整体效率。</li></ul></li><li><p><strong>短作业优先（SJF）／最短剩余时间优先（SRTF）</strong></p><ul><li><strong>SJF（非抢占）</strong>：每次选择执行时间最短的作业；</li><li><strong>SRTF（抢占）</strong>：新作业到达时，如果其所需时间比当前剩余时间短，则抢占。</li><li><strong>优点</strong>：能最小化平均等待时间；</li><li><strong>缺点</strong>：需要准确估计执行时间；可能导致长作业“饥饿”。</li></ul></li><li><p><strong>优先级调度（Priority）</strong></p><ul><li><strong>原理</strong>：为每个进程分配优先级，优先级高的先执行；可抢占或非抢占。</li><li><strong>优点</strong>：满足关键任务优先执行；</li><li><strong>缺点</strong>：低优先级可能长时间得不到调度（饥饿），需用“优先级老化”机制解决。</li></ul></li></ol><h3 id=抢占式调度>抢占式调度</h3><ol><li><p><strong>时间片轮转（Round Robin，RR）</strong></p><ul><li><strong>原理</strong>：给每个进程分配固定长度的时间片，时间片用完即切换到下一个进程，循环往复。</li><li><strong>优点</strong>：响应时间可控，适合交互式系统；无进程饥饿。</li><li><strong>缺点</strong>：时间片大小需平衡，过大接近 FCFS，过小切换开销大。</li></ul></li><li><p><strong>多级队列调度（Multilevel Queue）</strong></p><ul><li><strong>原理</strong>：将进程按类型（交互式、批处理、系统进程等）分到多个队列，不同队列使用不同算法和优先级。</li><li><strong>优点</strong>：可针对性地优化不同类型作业；</li><li><strong>缺点</strong>：队列间切换策略固定，灵活性较差。</li></ul></li><li><p><strong>多级反馈队列（Multilevel Feedback Queue）</strong></p><ul><li><strong>原理</strong>：允许进程在不同优先级队列间动态升降，根据其执行特性（CPU 密集或 I/O 密集）调整优先级。</li><li><strong>优点</strong>：兼顾短作业和长作业，能自动提升响应性；</li><li><strong>缺点</strong>：参数（队列数、时间片长度、反馈规则）较多，需要调优。</li></ul></li></ol><h3 id=现代与实时调度>现代与实时调度</h3><ol><li><p><strong>最早截止时间优先（EDF, Earliest Deadline First）</strong></p><ul><li><strong>应用</strong>：实时系统</li><li><strong>原理</strong>：总是选择截止时间最早的任务执行，可抢占。</li><li><strong>优点</strong>：理论上能在系统总利用率 ≤100% 时保证所有任务准时完成；</li><li><strong>缺点</strong>：需要精确的任务截止时间。</li></ul></li><li><p><strong>率先最小周期优先（RMS, Rate Monotonic Scheduling）</strong></p><ul><li><strong>应用</strong>：实时系统，周期性任务</li><li><strong>原理</strong>：周期短（率高）的任务优先级高；</li><li><strong>优点</strong>：简单固定优先级；</li><li><strong>缺点</strong>：在高利用率下不能保证可调度（理论上利用率上限 ≈69%）。</li></ul></li><li><p><strong>Linux 完全公平调度器（CFS, Completely Fair Scheduler）</strong></p><ul><li><strong>应用</strong>：通用 Linux 桌面/服务器</li><li><strong>原理</strong>：用虚拟运行时间（vruntime）衡量每个任务已经“拿过”的 CPU 时间，优先选择 vruntime 最小者执行。</li><li><strong>优点</strong>：可以在多任务间实现近似理想的公平；</li><li><strong>缺点</strong>：算法复杂度高于传统调度，切换开销略大。</li></ul></li></ol><h3 id=选择与权衡>选择与权衡</h3><ul><li><strong>交互式系统</strong>（桌面应用、Web 服务器）：优先 RR、Multilevel Feedback Queue、CFS</li><li><strong>批处理系统</strong>（后台任务、科学计算）：可选 SJF/SRTF、Multilevel Queue</li><li><strong>实时系统</strong>（控制、嵌入式）：EDF、RMS</li><li><strong>混合场景</strong>：多级反馈队列 + 结合优先级老化保证低优先级可执行</li></ul><div class=table-wrapper><table><thead><tr><th>算法</th><th>抢占</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>FCFS</td><td>否</td><td>简单易实现，无饥饿</td><td>平均等待时间高</td></tr><tr><td>SJF / SRTF</td><td>可选</td><td>最小化平均等待时间</td><td>需估计运行时长；长期作业易饥饿</td></tr><tr><td>Priority</td><td>可选</td><td>可满足关键任务优先</td><td>需防止低优先级饥饿</td></tr><tr><td>Round Robin</td><td>是</td><td>响应时间可控，无饥饿</td><td>时间片选取需平衡；频繁切换开销大</td></tr><tr><td>Multilevel Queue</td><td>可选</td><td>针对不同类型作业优化</td><td>队列间固化策略；灵活性差</td></tr><tr><td>Multilevel Feedback</td><td>是</td><td>自适应调度，兼顾短/长作业</td><td>参数调优复杂</td></tr><tr><td>EDF / RMS（实时）</td><td>是</td><td>实时可调度保证</td><td>需准确的任务参数</td></tr><tr><td>CFS</td><td>是</td><td>理想公平，适合通用场景</td><td>实现复杂，切换开销略大</td></tr></tbody></table></div></section><footer class=article-footer><section class=article-tags><a href=/tags/linux/>Linux</a>
<a href=/tags/%E8%BF%9B%E7%A8%8B/>进程</a>
<a href=/tags/%E7%BA%BF%E7%A8%8B/>线程</a>
<a href=/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/>操作系统</a>
<a href=/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/>虚拟地址</a>
<a href=/tags/%E5%8D%8F%E7%A8%8B/>协程</a></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=document.querySelector(".main-article");renderMathInElement(e,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article class=has-image><a href=/p/zero-copy/><div class=article-image><img src=/p/zero-copy/zero-copy.dac70e195d941f708d22cadb65d71c67_hu_d1e752f193a454d0.png width=250 height=150 loading=lazy alt="Featured image of post 零拷贝" data-key=zero-copy data-hash="md5-2scOGV2UH3CNIsrbZdccZw=="></div><div class=article-details><h2 class=article-title>零拷贝</h2></div></a></article><article class=has-image><a href=/p/io/><div class=article-image><img src=/p/io/io.6e22b7ab0f0dd2388a23186be7b7e919_hu_60e2856ab9152075.png width=250 height=150 loading=lazy alt="Featured image of post I/O" data-key=io data-hash="md5-biK3qw8N0jiKIxhr57fpGQ=="></div><div class=article-details><h2 class=article-title>I/O</h2></div></a></article><article class=has-image><a href=/p/iptables/><div class=article-image><img src=/p/iptables/iptables.fbfe2541eff5288fefb85339a5193521_hu_afcdc8a2c587d59.webp width=250 height=150 loading=lazy alt="Featured image of post Iptables" data-key=iptables data-hash="md5-+/4lQe/1KI/vuFM5pRk1IQ=="></div><div class=article-details><h2 class=article-title>Iptables</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2023 -
2025 Yellster - Blog</section><section class=powerby>想都是问题，做才是答案！<br>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>